<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LXiHa`Notes</title>
  
  <subtitle>The House Belong to Love and Freedom.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://liujunjie11.github.io/"/>
  <updated>2018-05-04T11:20:25.483Z</updated>
  <id>https://liujunjie11.github.io/</id>
  
  <author>
    <name>刘俊</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据结构与算法书籍资源共享</title>
    <link href="https://liujunjie11.github.io/2018/05/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%A6%E7%B1%8D%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB/"/>
    <id>https://liujunjie11.github.io/2018/05/04/数据结构与算法书籍资源共享/</id>
    <published>2018-05-04T11:15:05.000Z</published>
    <updated>2018-05-04T11:20:25.483Z</updated>
    
    <content type="html"><![CDATA[<ul><li>计算机程序设计艺术(卷1～卷四全)：</li></ul><blockquote><p><a href="https://pan.baidu.com/s/1922E16LZR0iXZHZQCgsbLg" target="_blank" rel="external">https://pan.baidu.com/s/1922E16LZR0iXZHZQCgsbLg</a></p></blockquote><ul><li>算法导论(第三版)：</li></ul><blockquote><p><a href="https://pan.baidu.com/s/1XqAeeJx803rcVCx7QMA62g" target="_blank" rel="external">https://pan.baidu.com/s/1XqAeeJx803rcVCx7QMA62g</a></p></blockquote><p>以上资源来于网络，感谢默默分享的人们！</p><p>还有一些其他的金典书籍，我都没怎么看啊..</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;计算机程序设计艺术(卷1～卷四全)：&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://pan.baidu.com/s/1922E16LZR0iXZHZQCgsbLg&quot; target=&quot;_blank&quot; rel=&quot;extern
      
    
    </summary>
    
      <category term="书籍" scheme="https://liujunjie11.github.io/categories/%E4%B9%A6%E7%B1%8D/"/>
    
    
      <category term="书籍" scheme="https://liujunjie11.github.io/tags/%E4%B9%A6%E7%B1%8D/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络知识总结</title>
    <link href="https://liujunjie11.github.io/2018/05/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    <id>https://liujunjie11.github.io/2018/05/02/计算机网络知识总结/</id>
    <published>2018-05-02T13:12:31.000Z</published>
    <updated>2018-05-02T13:18:47.590Z</updated>
    
    <content type="html"><![CDATA[<p>计算机网络也是计算机基础重要的一部分。</p><p>本来打算总结下关于计算机网络基础知识，发现下面的这些课件总结的已经非常好了，所以在此分享，我就不说多了…</p><blockquote><p>下载课件：<a href="https://pan.baidu.com/s/1uodpU6E8n050QyazgdLXVw" target="_blank" rel="external">https://pan.baidu.com/s/1uodpU6E8n050QyazgdLXVw</a></p></blockquote><ul><li>说明：</li></ul><p>课件来源：《数据通信与计算机网络》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;计算机网络也是计算机基础重要的一部分。&lt;/p&gt;
&lt;p&gt;本来打算总结下关于计算机网络基础知识，发现下面的这些课件总结的已经非常好了，所以在此分享，我就不说多了…&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;下载课件：&lt;a href=&quot;https://pan.baidu.com/s
      
    
    </summary>
    
      <category term="计算机网络" scheme="https://liujunjie11.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="https://liujunjie11.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>我对学习计算机基础的一些心得见解</title>
    <link href="https://liujunjie11.github.io/2018/04/29/%E6%88%91%E5%AF%B9%E5%AD%A6%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BF%83%E5%BE%97%E8%A7%81%E8%A7%A3/"/>
    <id>https://liujunjie11.github.io/2018/04/29/我对学习计算机基础的一些心得见解/</id>
    <published>2018-04-29T12:54:29.000Z</published>
    <updated>2018-04-29T13:26:28.269Z</updated>
    
    <content type="html"><![CDATA[<p>最近总是遇到了许多的瓶颈…即感觉认识的知道的太少了。</p><p>在前些天看到了一些关于<em>python</em>的优化内容之后，加上之前用<em>python</em>也有一段时间了，突然的感觉到一些基础细节才是最重要的，我意识到了<strong>这往往可能就是人与人技术之间的一个分水岭，也往往是突破瓶颈关键点，也往往能决定一个人技术的所在点。基础细节知识是能决定一个人能走多远的</strong></p><p>平时在写程序时不应满足于功能的实现，更加应当注意那些可优化的细节问题，就好比一个算法的时间复杂度与空间复杂度一样的，写的每一个程序(无论那种编程语言)均有可优化的最优解选择。在我平时因为涉及的数据规模不大，这种问题目前是看不出来的，如果运用到的是一个数据规模大的问题上，优化必然是重要的，不可或缺的。</p><p>平时想问题总是感觉能联想到的知识太少，回过头来看，发现自己对计算机的认识本来也不够全面(注意是全面！而非透彻！)。这往往也限制了我许多的想象，从而造成了我的瓶颈突出明显。</p><p>说了这么多，只是想说一个问题：<strong>计算机基础知识(包括编程基础知识)是能决定一个人技术的高度的。</strong>至少我现在就有这种感觉，写一个程序不应满足于功能的实现，更应探索最优解的选择。<strong>这往往就是技术<code>好</code>与<code>坏</code>的一个区分标准吧。</strong></p><p>关于如何学习以上说的基础知识，我有一些见解在此想要说明一下。</p><ul><li><p>知识尽量要了解全面，不能为了速度而一知半解的，那样只会浪费时间，最后还是什么都不知道。</p></li><li><p>有些知识可能会引起我们的好奇，想要进一步理解透彻(彻彻底底)，但是这其中却是有太多的知识链关联着的…这点我深有体会。如果顺着知识链步步了解，我们的确也能学习到许多的知识，但是最后会发现其实这些在我们实际需要中根本没有多大的作用，仅仅当时作为一种科普了，当然现在学习到的知识也是以后我们技术的一种铺垫，如果实在有兴趣就当我没说，兴趣是学习一种知识最好的引导。</p></li><li><p>有些是需要理解透彻的，有些(大部分)可能仅仅是需要了解一下就好的。</p></li><li><p>根据目前的需求来进行学习也是一种好的驱动力。</p></li><li><p>一些必要的基础知识是需要了解的，比如学习了计算机概论，那一般以后买电脑时就会有自己的一些见解了。学习了数据结构与算法基础之后，编程时就不会仅仅以达到目的而“不择手段”编写程序了，因为再学习了这些基础知识之后我们脑子里必然会有一些规则“约束”了。</p></li></ul><p>最后，我还是想说，对于底层的电路什么的那种我想我是不愿也是不情愿接触的…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近总是遇到了许多的瓶颈…即感觉认识的知道的太少了。&lt;/p&gt;
&lt;p&gt;在前些天看到了一些关于&lt;em&gt;python&lt;/em&gt;的优化内容之后，加上之前用&lt;em&gt;python&lt;/em&gt;也有一段时间了，突然的感觉到一些基础细节才是最重要的，我意识到了&lt;strong&gt;这往往可能就是人与
      
    
    </summary>
    
      <category term="学习笔记" scheme="https://liujunjie11.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="学习笔记" scheme="https://liujunjie11.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>python3爬虫与GUI：一个简易的搜索实用小工具</title>
    <link href="https://liujunjie11.github.io/2018/04/28/python3%E7%88%AC%E8%99%AB%E4%B8%8EGUI%EF%BC%9A%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93%E7%9A%84%E6%90%9C%E7%B4%A2%E5%AE%9E%E7%94%A8%E5%B0%8F%E5%B7%A5%E5%85%B7/"/>
    <id>https://liujunjie11.github.io/2018/04/28/python3爬虫与GUI：一个简易的搜索实用小工具/</id>
    <published>2018-04-28T02:31:30.000Z</published>
    <updated>2018-05-02T13:04:39.933Z</updated>
    
    <content type="html"><![CDATA[<p>平时在获取爬虫之后，会不满足于仅仅得到了结果，而是想经过一个交互式的界面来进一步的完善，获取更多的功能，从而可以更好的展示数据。</p><p>下面运用了<em>python</em>的<em>pyqt5</em>库来进行<em>GUI</em>的设计。</p><p>用<em>pyqt5</em>这个库实现简单的界面化有两种方法：</p><ul><li><p>编写代码(一般为几十行代码足够了)。</p></li><li><p>结合<em>QT Creator</em>来进行界面设计，加入信号与槽的机制，槽这一方面还是需要编写相应的几行代码。</p></li></ul><blockquote><p>下面一一进行简单的介绍。</p></blockquote><h2 id="代码编写方式"><a href="#代码编写方式" class="headerlink" title="代码编写方式"></a>代码编写方式</h2><p>假设我已经利用爬虫写出来了<em>百度百科</em>，<em>维基百科</em>的接口的代码程序，接下来仅仅需要设计好界面，再者之后利用好信号与槽的机制将接口代码与界面相连接即可完成一个简易的搜索实用小工具了。</p><p>在此简单理解一下信号与槽机制以及所谓的事件机制：<strong>比如我们有一个按钮，点击此按钮便弹出一个写有‘Hello’的窗口，点击到弹出新窗口的这一过程，有个响应的过程，我们可以理解为发送信号(点击按钮)，之后有弹出新窗口(响应),而这一系列过程包括弹出的内容我们可称之为事件。</strong></p><blockquote><p>关于学习<em>pyqt5</em>库的中文教程地址：<a href="https://maicss.gitbooks.io/pyqt5/content/事件和信号.html" target="_blank" rel="external">https://maicss.gitbooks.io/pyqt5/content/事件和信号.html</a></p></blockquote><p>从头开始看一下，之后再看这一篇大概就知道简单的交互式界面是如何生成的了。</p><p>简单描述一下思路：<strong>先设计布局好界面(包括定义好相关按钮的快捷键)，写入爬虫代码，信号与槽机制的连接设定，即完成了此次的任务。</strong></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code>import sysimport urllib.request  from bs4 import BeautifulSoupimport refrom urllib.parse import quote from PyQt5.QtWidgets import (QPushButton, QWidget, QLabel, QLineEdit, QTextEdit, QGridLayout, QApplication,    QComboBox)from PyQt5.QtCore import QCoreApplicationclass Example(QWidget):     def __init__(self):        &apos;&apos;&apos;        初始化        &apos;&apos;&apos;        super().__init__()        self.initUI()    def baidu_baike(self, entry):          &apos;&apos;&apos;        百度百科词条内容爬取代码        entry：词条        因为太懒了..所以爬取的代码没有自己写..        &apos;&apos;&apos;        url = &apos;https://baike.baidu.com/item/&apos; + urllib.parse.quote(entry)        html = urllib.request.urlopen(url)          content = html.read().decode(&apos;utf-8&apos;)        html.close()        # lxml器进行解析        soup = BeautifulSoup(content, &quot;lxml&quot;)          text = soup.find(&apos;div&apos;, class_=&quot;lemma-summary&quot;).children  # 簡介部分        intro_text = &apos;&apos;        # 数据爬取        for x in text:            word = re.sub(re.compile(r&quot;&lt;(.+?)&gt;&quot;), &apos;&apos;, str(x))            words = re.sub(re.compile(r&quot;\[(.+?)\]&quot;), &apos;&apos;, word)            intro_text += words        return intro_text  # 返回文本(str格式)    def intro_final(self, entry):          &apos;&apos;&apos;        异常处理        &apos;&apos;&apos;        try:            return self.baidu_baike(entry)        except AttributeError:            return &quot;词条定义不够清晰/词条目前未成立！&quot;    def initUI(self):        # GUI布局及控件放置        search_label = QLabel(&quot;请输入搜索词条：&quot;)        search_item = QLineEdit()        combo = QComboBox(self)        combo.addItem(&quot;百度百科&quot;)        combo.addItem(&quot;维基百科(不可用)&quot;)        btn1 = QPushButton(&quot;开始搜索&quot;, self)        # shortcut快捷键的设置        btn1.setShortcut(&apos;return&apos;)        btn2 = QPushButton(&quot;清空&quot;, self)        btn2.setShortcut(&apos;esc&apos;)        btn3 = QPushButton(&apos;退出&apos;, self)        btn3.setShortcut(&apos;command+q&apos;)        btn3.setShortcut(&apos;Ctrl+q&apos;)        btn3.clicked.connect(QCoreApplication.instance().quit)        search_result = QTextEdit()        grid = QGridLayout()        grid.setSpacing(5)        grid.addWidget(search_label, 1, 0)        grid.addWidget(btn3, 2, 1)        grid.addWidget(search_item, 2, 0)        grid.addWidget(btn1, 3, 0)        grid.addWidget(btn2, 3, 1)        grid.addWidget(search_result, 4, 0, 5 , 0)        self.setLayout(grid)        # 信号机制的设置，定义为一个方法作为反映的对象，这里很好理解        def search():            &apos;&apos;&apos;            搜索信号反映的响应            &apos;&apos;&apos;            search_result.setText(self.intro_final(search_item.text()))        btn1.clicked.connect(search)        def clear():            &apos;&apos;&apos;            清空信号反映的响应            &apos;&apos;&apos;            search_result.setText(&quot;&quot;)            search_item.setText(&quot;&quot;)        btn2.clicked.connect(clear)        # 设置窗口大小        self.setGeometry(500, 150, 600, 500)        self.setWindowTitle(&quot;搜索引擎GUI&quot;)        self.show()if __name__ == &quot;__main__&quot;:    app = QApplication(sys.argv)    ex = Example()    sys.exit(app.exec_())</code></pre><blockquote><p>以上有不懂的地方均可在<a href="https://maicss.gitbooks.io/pyqt5/content/hello_world.html" target="_blank" rel="external">pyqt5中文教程</a>中找到思路。</p></blockquote><h3 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h3><p><img src="http://owudg3xs2.bkt.clouddn.com/5%E6%9C%88-02-2018%2019-31-44.gif" alt=""></p><h2 id="结合QT-Creator的界面设计"><a href="#结合QT-Creator的界面设计" class="headerlink" title="结合QT Creator的界面设计"></a>结合<em>QT Creator</em>的界面设计</h2><p>结合<em>QT Creator</em>的界面，我们肯定会想到：那当我们进行界面设计完成之后，就算是转化为<code>.py</code>的<em>python</em>脚本，那我们又该如何定义信号与槽的机制以及事件的机制呢？</p><p>下面的解说就是解决这个疑惑的。</p><p>第一步当然是去官网下载好软件了。</p><blockquote><p>参考此篇文章：<a href="https://blog.csdn.net/win_turn/article/details/50465127" target="_blank" rel="external">https://blog.csdn.net/win_turn/article/details/50465127</a></p></blockquote><p><strong>话不多说了，下载的时候其实有一个坑，即要记得下载有调试的那个版本，否则在设计界面时无法得到运行。</strong></p><h3 id="创建文件并且设计"><a href="#创建文件并且设计" class="headerlink" title="创建文件并且设计"></a>创建文件并且设计</h3><p>在这里仅仅是为了达到解说的目的所以简单设计一下就好，说说设计下面的思路：<strong>定义一个按钮(名为确定)，一个输入框，一个输出框，达到的目的是从输入框输入文字，按下确定按钮，输出框中输出与输入框一致的内容。</strong></p><p>创建新的文件过程如图所示：</p><p><img src="http://owudg3xs2.bkt.clouddn.com/5%E6%9C%88-02-2018%2019-42-52.gif" alt=""></p><blockquote><p>总之就是如上图一路点击下去即可。</p></blockquote><p>之后会发现有这样的界面出现：</p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-05-02%20%E4%B8%8B%E5%8D%887.43.59.png" alt=""></p><p>这个<em>mainwindow.ui</em>不说就能轻易知道就是用它来进行界面设计的。双击它即可进入设计界面(如图1)，当然可选择<em>Qt Designer</em>进行设计(对其右键可弹出选项，如图2)。</p><ul><li>图1</li></ul><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-05-02%20%E4%B8%8B%E5%8D%887.49.34.png" alt=""></p><ul><li>图2</li></ul><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-05-02%20%E4%B8%8B%E5%8D%887.47.52.png" alt=""></p><p>为了尽快达到写完的目的，我简单的来进行一下示范…</p><p>先在界面中，设计一个按钮：</p><p><img src="http://owudg3xs2.bkt.clouddn.com/5%E6%9C%88-02-2018%2020-15-04.gif" alt=""></p><p>然后添加下面两种组件：</p><p><img src="http://owudg3xs2.bkt.clouddn.com/5%E6%9C%88-02-2018%2020-15-15.gif" alt=""></p><p><img src="http://owudg3xs2.bkt.clouddn.com/5%E6%9C%88-02-2018%2020-15-38.gif" alt=""></p><h3 id="定义信号与槽"><a href="#定义信号与槽" class="headerlink" title="定义信号与槽"></a>定义信号与槽</h3><p>在这之前先将设计好的转为<code>.py</code><em>python</em>脚本文件。<code>cd</code>到相应的文件的目录下(即上面的<em>mainwindow.ui</em>所在的目录。注意，此步非常重要！)利用命令行：<code>pyuic5 -o  mainwindow.py mainwindow.ui</code></p><blockquote><p>关于此命令行具体可参考：<a href="https://blog.csdn.net/yingmutongxue/article/details/8487348" target="_blank" rel="external">https://blog.csdn.net/yingmutongxue/article/details/8487348</a><br><strong>(在此需要注意的是，我使用的是<em>pyqt5</em>，所以对应的命令行应当是pyuic5开头，若是<em>pyqt4</em>，则为pyuic4开头了。)</strong></p></blockquote><p>这样在本目录下即可找到转为后的<em>python</em>文件了。</p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-05-02%20%E4%B8%8B%E5%8D%889.04.04.png" alt=""></p><p>再者，我们需要在这个文件实现上面说的思路，即相应的信号与槽机制的代码。因为时间问题，就不在此实现了(是真的写不下去了…)。</p><p>在完成之后，我们直接将此调入<em>eclipse</em>的工程目录下(我用的是<em>eclipse</em>)，之后我们直接调用此文件即可。</p><pre><code>import sysfrom PyQt5.QtWidgets import QApplication , QMainWindowfrom mainwindow import *if __name__ == &apos;__main__&apos;:#     主函数    app = QtWidgets.QApplication(sys.argv)    MainWindow = QtWidgets.QMainWindow()    ui = Ui_MainWindow()    ui.setupUi(MainWindow)    MainWindow.show()    sys.exit(app.exec_())</code></pre><blockquote><p>这样即可完成结合软件设计界面，并在<em>python</em>中运行的一条龙服务了…</p><p>其实在<em>Qt creator</em>中就有信号与槽机制以及快捷键的设置了，这个可参考：<a href="https://wizardforcel.gitbooks.io/qt-beginning/content/60.html" target="_blank" rel="external">https://wizardforcel.gitbooks.io/qt-beginning/content/60.html</a><br>(<strong>全面介绍了</strong>)</p></blockquote><p>简单认识一下设计界面上的那些按钮功能(网上的图，出处忘记了…)</p><p><img src="http://owudg3xs2.bkt.clouddn.com/d.png" alt=""></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>唉..突然感觉直接写代码都还要方便多了…结合软件设计搞的时间浪费的还要多…</p><ul><li>参考：</li></ul><blockquote><p><a href="https://blog.csdn.net/jclian91/article/details/77407723" target="_blank" rel="external">https://blog.csdn.net/jclian91/article/details/77407723</a></p><p><a href="https://maicss.gitbooks.io/pyqt5/content/介绍.html" target="_blank" rel="external">https://maicss.gitbooks.io/pyqt5/content/介绍.html</a><br><strong>(以上所有内容的拼接均可根据此pyqt5库中文教程来进行理解学习，还是一句话，要多动脑多动手实践。)</strong></p><p><a href="https://cuiqingcai.com/5551.html" target="_blank" rel="external">https://cuiqingcai.com/5551.html</a><br><strong>（pyquery的使用教程）</strong></p></blockquote><ul><li>关于将<em>python</em>文件打包生成app的工具库：</li></ul><blockquote><p>py2app:.py –&gt; .dmg</p><p>py2exe:.py –&gt; .exe </p></blockquote><ul><li>关于<em>css选择器</em>等其他内容的快速获取(基于<em>chrome</em>浏览器)：</li></ul><p><img src="http://owudg3xs2.bkt.clouddn.com/5%E6%9C%88-02-2018%2019-33-40.gif" alt=""></p><blockquote><p>看上方的动图，选择完之后粘贴即可得出对应的内容(可适当删除中间字段而不影响达到目的)，当然最好学会一点相关的内容，其实也不难上手。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;平时在获取爬虫之后，会不满足于仅仅得到了结果，而是想经过一个交互式的界面来进一步的完善，获取更多的功能，从而可以更好的展示数据。&lt;/p&gt;
&lt;p&gt;下面运用了&lt;em&gt;python&lt;/em&gt;的&lt;em&gt;pyqt5&lt;/em&gt;库来进行&lt;em&gt;GUI&lt;/em&gt;的设计。&lt;/p&gt;
&lt;p&gt;用&lt;
      
    
    </summary>
    
      <category term="python-GUI学习" scheme="https://liujunjie11.github.io/categories/python-GUI%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="python-GUI学习" scheme="https://liujunjie11.github.io/tags/python-GUI%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>关于Mac的快捷键及fn键设置</title>
    <link href="https://liujunjie11.github.io/2018/04/27/%E5%85%B3%E4%BA%8EMac%E7%9A%84%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%8F%8Afn%E9%94%AE%E8%AE%BE%E7%BD%AE/"/>
    <id>https://liujunjie11.github.io/2018/04/27/关于Mac的快捷键及fn键设置/</id>
    <published>2018-04-27T05:06:18.000Z</published>
    <updated>2018-04-27T07:36:01.031Z</updated>
    
    <content type="html"><![CDATA[<p>最近因为需要，就花了点时间看了一下。本文用于记录下一些常用的在<em>Mac</em>下的一些设置。</p><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><p>关于在认识<em>Macbook</em>的一些快捷键时，进入步骤：<code>系统偏好设置</code> –&gt; <code>键盘</code>–&gt;<code>快捷键</code>–&gt; <code>左边栏</code>。一个一个都看看，发现快捷键系统的都在。</p><p><img src="http://owudg3xs2.bkt.clouddn.com/4%E6%9C%88-27-2018%2015-27-50.gif" alt=""></p><blockquote><p>当然可根据需要自行更改。</p></blockquote><h2 id="fn健的设置"><a href="#fn健的设置" class="headerlink" title="fn健的设置"></a>fn健的设置</h2><p>按下<em>fn</em>健可显示<code>F1</code>～<code>F12</code>的按键，关于如何设置在特定的软件打开时无需按此就显示<code>F1</code>～<code>F12</code>的按键：<code>系统偏好设置</code> –&gt; <code>键盘</code>–&gt;<code>快捷键</code>–&gt;<code>(fn)功能键</code>–&gt;添加软件即可。在这之后会发现打开相应的软件之后，无需按下<em>fn</em>健即可显示出<code>F1</code>～<code>F12</code>的按键了。</p><p><img src="http://owudg3xs2.bkt.clouddn.com/4%E6%9C%88-27-2018%2015-28-06.gif" alt=""></p><h2 id="关于设置文件的默认打开方式"><a href="#关于设置文件的默认打开方式" class="headerlink" title="关于设置文件的默认打开方式"></a>关于设置文件的默认打开方式</h2><p>例子：右键打开一个文件，点击<code>显示简介</code>–&gt;<code>打开方式</code>–&gt;选择好想要默认打开用的软件–&gt;<code>全部更改</code>。再次打开此类型的文件均以选定的软件打开显示。</p><p><img src="http://owudg3xs2.bkt.clouddn.com/4%E6%9C%88-27-2018%2015-28-21.gif" alt=""></p><h2 id="关闭软件通知"><a href="#关闭软件通知" class="headerlink" title="关闭软件通知"></a>关闭软件通知</h2><p>有时用的破解软件经常提醒要更新…<code>系统偏好设置</code> –&gt; <code>通知</code>。里面设置停止通知即可。</p><p><img src="http://owudg3xs2.bkt.clouddn.com/4%E6%9C%88-27-2018%2015-28-39.gif" alt=""></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>如果有时发现没有相关的内容，可先重新启动，再次进行操作。不仅此类型的问题需要重新启动，只要是发现很系统奇怪跟往常不一致时均可通过重新启动来解决。</p><p>以后有需要用的上的再补上。</p><blockquote><p>主要资料可参考<em>Apple</em>官网的说明即可。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近因为需要，就花了点时间看了一下。本文用于记录下一些常用的在&lt;em&gt;Mac&lt;/em&gt;下的一些设置。&lt;/p&gt;
&lt;h2 id=&quot;快捷键&quot;&gt;&lt;a href=&quot;#快捷键&quot; class=&quot;headerlink&quot; title=&quot;快捷键&quot;&gt;&lt;/a&gt;快捷键&lt;/h2&gt;&lt;p&gt;关于在认识&lt;em
      
    
    </summary>
    
      <category term="Mac教程笔记" scheme="https://liujunjie11.github.io/categories/Mac%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Mac教程笔记" scheme="https://liujunjie11.github.io/tags/Mac%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>关于Jupyter Notebook的简单使用</title>
    <link href="https://liujunjie11.github.io/2018/04/21/%E5%85%B3%E4%BA%8EJupyter-Notebook%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <id>https://liujunjie11.github.io/2018/04/21/关于Jupyter-Notebook的简单使用/</id>
    <published>2018-04-21T12:37:03.000Z</published>
    <updated>2018-04-21T13:43:33.581Z</updated>
    
    <content type="html"><![CDATA[<p>关于<em>Jupyter Notebook</em>的介绍就不在此多说了。</p><p>官网教程：</p><blockquote><p><a href="https://jupyter-notebook.readthedocs.io/en/stable/notebook.html" target="_blank" rel="external">https://jupyter-notebook.readthedocs.io/en/stable/notebook.html</a></p></blockquote><p>直接开始介绍整个流程好了。</p><p>先下载<em>Anaconda</em>，里面有包含了现成的<em>Jupyter Notebook</em>，之后我们打开<em>Anaconda</em>客户端即可直接使用<em>Jupyter Notebook</em>了。</p><blockquote><p><em>Anaconda</em>官网：<a href="https://www.anaconda.com/download/#macos" target="_blank" rel="external">https://www.anaconda.com/download/#macos</a></p><p>其中有两个版本，选择需要的下载的版本与完成之后打开的<em>Jupyter Notebook</em>中的<em>python</em>版本是一致的。</p></blockquote><p>打开客户端，进入<em>Jupyter Notebook</em>：</p><p><img src="http://owudg3xs2.bkt.clouddn.com/4%E6%9C%88-21-2018%2020-55-27.gif" alt=""></p><p>在<em>Jupyter Notebook</em>中新建一个文本：</p><p><img src="http://owudg3xs2.bkt.clouddn.com/4%E6%9C%88-21-2018%2020-55-59.gif" alt=""></p><p>在创建了一个脚本文件之后的界面上的小图标各有不同的功能，可以自己点击一下就知道是怎么回事了，再不然可结合文档来进行操作即可。再者接下来就是根据个人的需要来进行编码了，更多的功能暂时用不到，可参考上面的官网教程。</p><blockquote><p>关于<em>Ipython</em>教程可参考：<a href="https://itacey.gitbooks.io/learning_ipython/content/第一章.html" target="_blank" rel="external">https://itacey.gitbooks.io/learning_ipython/content/第一章.html</a></p><p>关于在<em>Mac</em>中使用<em>Jupyter Notebook</em>编码时的快捷键可参考：<a href="https://www.jianshu.com/p/20f6a77dd23c" target="_blank" rel="external">https://www.jianshu.com/p/20f6a77dd23c</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;关于&lt;em&gt;Jupyter Notebook&lt;/em&gt;的介绍就不在此多说了。&lt;/p&gt;
&lt;p&gt;官网教程：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://jupyter-notebook.readthedocs.io/en/stable/notebo
      
    
    </summary>
    
      <category term="python" scheme="https://liujunjie11.github.io/categories/python/"/>
    
    
      <category term="python" scheme="https://liujunjie11.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>搭建Django开发环境</title>
    <link href="https://liujunjie11.github.io/2018/04/19/%E6%90%AD%E5%BB%BADjango%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
    <id>https://liujunjie11.github.io/2018/04/19/搭建Django开发环境/</id>
    <published>2018-04-19T11:00:28.000Z</published>
    <updated>2018-04-19T11:34:00.935Z</updated>
    
    <content type="html"><![CDATA[<p>老早就想将一些数据库里的数据来进行交互式的实现了，之前看了有主要的两种方法：</p><ul><li><p>一是<em>pyQt5</em>这个库，结合<em>Qt creator</em>来进行完成。</p></li><li><p>另外就是通过网页形式来进行交互式的实现了。</p></li></ul><blockquote><p>在接触了前者之后发现学习的时间成本比较高一些，所以打算选择后者了…</p></blockquote><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>在终端使用命令行：<code>pip3 install Django</code></p><blockquote><p>默认<em>python3</em>进行。<em>python2</em>:<code>pip install Django</code>。两者均会下载<em>Django</em>库的最新版本，亦可指定下载那个版本。</p></blockquote><h3 id="测试安装："><a href="#测试安装：" class="headerlink" title="测试安装："></a>测试安装：</h3><p>在编译器中：</p><pre><code>import django  # @UnresolvedImportif __name__ == &apos;__main__&apos;:        print(django.get_version())</code></pre><blockquote><p><strong>在<em>eclipse</em>中会提示导入Django库找不到，但是运行是可以成功的，加上# @UnresolvedImport 让错误提示不再提示。</strong></p></blockquote><p>在终端，先打开<em>python</em>的编译环境，依次输入：</p><pre><code>import djangoprint(django.get_version())</code></pre><blockquote><p>以上两者均会输出下载的<em>Django</em>版本号。</p></blockquote><h2 id="测试Django运行"><a href="#测试Django运行" class="headerlink" title="测试Django运行"></a>测试Django运行</h2><h3 id="项目建立"><a href="#项目建立" class="headerlink" title="项目建立"></a>项目建立</h3><p><code>cd</code> 至编译器或者是IDE的开发环境的目录下，使用创建项目命令：<code>django-admin startproject mysite</code><strong>（其中的mysite是项目名称）</strong>：</p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-19%20%E4%B8%8B%E5%8D%887.33.13.png" alt=""></p><p>创建项目成功之后刷新在编译器的目录，我的是<em>eclipse</em>，可看到项目目录出来了：</p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-19%20%E4%B8%8B%E5%8D%887.30.32.png" alt=""></p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>在上面的基础下<code>cd</code>至新建的项目之下，启动主文件：<code>python manage.py runserver</code>，打开链接<a href="http://127.0.0.1:8000/" target="_blank" rel="external">http://127.0.0.1:8000/</a></p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-19%20%E4%B8%8B%E5%8D%887.30.55.png" alt=""></p><p>出现了Django成功运行的网页：</p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-19%20%E4%B8%8B%E5%8D%887.31.09.png" alt=""></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><ul><li><p>在<em>eclipse</em>中的导入<em>Django</em>提示错误，实际上运行无障碍。</p></li><li><p>详细可参考：</p></li></ul><p><strong><a href="https://docs.djangoproject.com/en/2.0/intro/tutorial01/" target="_blank" rel="external">https://docs.djangoproject.com/en/2.0/intro/tutorial01/</a></strong></p><p><strong><a href="https://www.w3cschool.cn/django/dl5b8ozt.html" target="_blank" rel="external">https://www.w3cschool.cn/django/dl5b8ozt.html</a></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;老早就想将一些数据库里的数据来进行交互式的实现了，之前看了有主要的两种方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;一是&lt;em&gt;pyQt5&lt;/em&gt;这个库，结合&lt;em&gt;Qt creator&lt;/em&gt;来进行完成。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;另外就是通过网页形式来进行交互式的
      
    
    </summary>
    
      <category term="Django" scheme="https://liujunjie11.github.io/categories/Django/"/>
    
    
      <category term="Django" scheme="https://liujunjie11.github.io/tags/Django/"/>
    
  </entry>
  
  <entry>
    <title>关于Parallels Desktop13的简单使用</title>
    <link href="https://liujunjie11.github.io/2018/04/17/%E5%85%B3%E4%BA%8EParallels-Desktop13%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <id>https://liujunjie11.github.io/2018/04/17/关于Parallels-Desktop13的简单使用/</id>
    <published>2018-04-17T01:44:20.000Z</published>
    <updated>2018-04-17T02:03:53.583Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>Parallels Desktop13破解版的下载以及简单的操作可见：<a href="https://blog.csdn.net/weixin_41000111/article/details/79428402" target="_blank" rel="external">https://blog.csdn.net/weixin_41000111/article/details/79428402</a></strong></p></blockquote><p>本文仅仅是做一些补充。</p><h2 id="关于新建一个虚拟机"><a href="#关于新建一个虚拟机" class="headerlink" title="关于新建一个虚拟机"></a>关于新建一个虚拟机</h2><p>比如已经有了一个<em>win</em>系统的虚拟机，想建一个<em>Linux</em>的虚拟机。如下图所示，打开在右上角的<em>Parallels Desktop</em>的小图标，点击<code>新建..</code>即可。</p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-17%20%E4%B8%8A%E5%8D%889.42.25.png" alt=""></p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-17%20%E4%B8%8A%E5%8D%889.42.37.png" alt=""></p><blockquote><p>之后的安装步骤会有点不一致，不过容易上手。</p></blockquote><h2 id="关于Parallels-Desktop13的扩展功能"><a href="#关于Parallels-Desktop13的扩展功能" class="headerlink" title="关于Parallels Desktop13的扩展功能"></a>关于<em>Parallels Desktop13</em>的扩展功能</h2><p>打开在右上角的<em>Parallels Desktop</em>的小图标中的<em>偏好设置</em>，如下图所示下载<em>Toolbox</em>。打开之后发现会有许多的小工具，比如下方的视频下载工具可下载<em>YouTube</em>上的视频文件。更多的新功能可见官网：<strong><a href="https://www.parallels.com/products/desktop/" target="_blank" rel="external">https://www.parallels.com/products/desktop/</a></strong></p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-17%20%E4%B8%8A%E5%8D%889.50.08.png" alt=""></p><p><img src="http://owudg3xs2.bkt.clouddn.com/4%E6%9C%88-17-2018%2010-01-17.gif" alt=""></p><blockquote><p>官网的介绍视频中有相关的详细介绍。</p></blockquote><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>说说体验吧。与我之前用过的虚拟机软件<em>VirtualBox</em>相较，<em>Parallels Desktop</em>明显的运行起来比前者更为流畅，更为人性化一些，并且功能更为强大。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Parallels Desktop13破解版的下载以及简单的操作可见：&lt;a href=&quot;https://blog.csdn.net/weixin_41000111/article/details/79428402&quot; target=&quot;
      
    
    </summary>
    
      <category term="Parallels Desktop" scheme="https://liujunjie11.github.io/categories/Parallels-Desktop/"/>
    
    
      <category term="Parallels Desktop" scheme="https://liujunjie11.github.io/tags/Parallels-Desktop/"/>
    
  </entry>
  
  <entry>
    <title>关于在eclipse中运行scrapy项目</title>
    <link href="https://liujunjie11.github.io/2018/04/13/%E5%85%B3%E4%BA%8E%E5%9C%A8eclipse%E4%B8%AD%E8%BF%90%E8%A1%8Cscrapy%E9%A1%B9%E7%9B%AE/"/>
    <id>https://liujunjie11.github.io/2018/04/13/关于在eclipse中运行scrapy项目/</id>
    <published>2018-04-13T11:23:05.000Z</published>
    <updated>2018-04-13T12:00:46.995Z</updated>
    
    <content type="html"><![CDATA[<p>关于在<em>eclipse</em>中运行爬虫<em>scrapy</em>框架的项目介绍如下。</p><blockquote><p><strong>scrapy官方文档：<a href="http://scrapy-chs.readthedocs.io/zh_CN/0.24/topics/shell.html" target="_blank" rel="external">http://scrapy-chs.readthedocs.io/zh_CN/0.24/topics/shell.html</a></strong></p></blockquote><p>首先打开终端将<code>cd</code>至<em>eclipse</em>目录下的（即<em>eclipse-workspace</em>），使用命令行<code>scrapy startproject tutorial</code>（其中的<em>tutorial</em>是自由选择的），之后会生成一个目录，将其目录移至一个<em>python工程</em>下。</p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-13%20%E4%B8%8B%E5%8D%887.49.25.png" alt=""></p><blockquote><p>如上图。</p></blockquote><p>在<em>spider</em>包下建立一个脚本文件（如上图我的那个<em>first</em>文件，名字随意），是用来写爬虫程序用的。之后在<em>tutorial</em>包下建立一个名为<em>cmdline</em>的脚本文件（名字随意）。</p><p>下面为了直接达到运行成功的目的，贴上测试用的代码。</p><p><strong>first.py中的代码：</strong></p><pre><code>import scrapyclass DmozSpider(scrapy.Spider):    name = &quot;first&quot; #此处很重要    allowed_domains = [&quot;dmoz.org&quot;]    start_urls = [        &quot;http://www.dmoz.org/Computers/Programming/Languages/Python/Books/&quot;,        &quot;http://www.dmoz.org/Computers/Programming/Languages/Python/Resources/&quot;    ]    def parse(self, response):        filename = response.url.split(&quot;/&quot;)[-2]        with open(filename, &apos;wb&apos;) as f:            f.write(response.body)</code></pre><p><strong>cmdline.py中的代码：</strong></p><pre><code>from scrapy.cmdline import executeif __name__ == &apos;__main__&apos;:    #第三个参数就是上方的first文件名！其他两个参数如下正常    execute(argv=[&apos;scrapy&apos;, &apos;crawl&apos;, &apos;first&apos;])</code></pre><p><strong>items.py中的代码：</strong></p><pre><code>import scrapyclass TutorialItem(scrapy.Item):    # define the fields for your item here like:    # name = scrapy.Field()    title = scrapy.Field()    link = scrapy.Field()    desc = scrapy.Field()</code></pre><blockquote><p>这个文件是与<em>first</em>文件有直接联系的。可参考官方文档介绍。</p></blockquote><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>接下来直接运行<em>cmdline.py</em>可得出结果：</p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-13%20%E4%B8%8B%E5%8D%887.50.00.png" alt=""></p><hr><h2 id="配置调试"><a href="#配置调试" class="headerlink" title="配置调试"></a>配置调试</h2><p>直接看下面的图上解说吧。</p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-13%20%E4%B8%8B%E5%8D%887.46.09.png" alt=""></p><hr><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-13%20%E4%B8%8B%E5%8D%887.46.17.png" alt=""></p><blockquote><p>接下来点击debug。</p></blockquote><hr><p><strong>最终两者均可达到输出的效果！</strong></p><p>参考：</p><p><a href="https://blog.csdn.net/otengyue/article/details/48065841" target="_blank" rel="external">https://blog.csdn.net/otengyue/article/details/48065841</a></p><p><a href="http://www.cnblogs.com/v-BigdoG-v/p/7393601.html" target="_blank" rel="external">http://www.cnblogs.com/v-BigdoG-v/p/7393601.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;关于在&lt;em&gt;eclipse&lt;/em&gt;中运行爬虫&lt;em&gt;scrapy&lt;/em&gt;框架的项目介绍如下。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;scrapy官方文档：&lt;a href=&quot;http://scrapy-chs.readthedocs.io/zh_CN/
      
    
    </summary>
    
      <category term="eclispe scrapy" scheme="https://liujunjie11.github.io/categories/eclispe-scrapy/"/>
    
    
      <category term="eclispe scrapy" scheme="https://liujunjie11.github.io/tags/eclispe-scrapy/"/>
    
  </entry>
  
  <entry>
    <title>关于eclipse的风格与主题</title>
    <link href="https://liujunjie11.github.io/2018/04/13/%E5%85%B3%E4%BA%8Eeclipse%E7%9A%84%E9%A3%8E%E6%A0%BC%E4%B8%8E%E4%B8%BB%E9%A2%98/"/>
    <id>https://liujunjie11.github.io/2018/04/13/关于eclipse的风格与主题/</id>
    <published>2018-04-13T04:56:03.000Z</published>
    <updated>2018-04-13T05:21:26.770Z</updated>
    
    <content type="html"><![CDATA[<h2 id="eclipse的界面主题更换"><a href="#eclipse的界面主题更换" class="headerlink" title="eclipse的界面主题更换"></a><em>eclipse</em>的界面主题更换</h2><p>关于我的<em>eclipse</em>的界面主题更换（目前为<em>eclipse Oxygen</em>版本），在内置中已经可以作为一种选择了。</p><p>具体看图所示即可：</p><p><img src="http://owudg3xs2.bkt.clouddn.com/4%E6%9C%88-13-2018%2013-07-55.gif" alt=""></p><blockquote><p>可供的选择有三种，其中的<em>dark</em>类型是比较护眼的，均可试试。</p></blockquote><p>实际的<em>dark</em>展示：</p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-13%20%E4%B8%8B%E5%8D%881.08.27.png" alt=""></p><hr><h2 id="eclipse代码风格更换"><a href="#eclipse代码风格更换" class="headerlink" title="eclipse代码风格更换"></a><em>eclipse</em>代码风格更换</h2><p>可参考此处：<a href="https://blog.csdn.net/zhouchangshi/article/details/37901519" target="_blank" rel="external">https://blog.csdn.net/zhouchangshi/article/details/37901519</a></p><blockquote><p>其中已经有了许多的并且详细的介绍了。</p></blockquote><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li>关于更换编译处的字体大小以及字体选择（如图）:</li></ul><p><img src="http://owudg3xs2.bkt.clouddn.com/4%E6%9C%88-13-2018%2013-11-02.gif" alt=""></p><ul><li>关于控制台的字体更改以及选择（如图）:</li></ul><p><img src="http://owudg3xs2.bkt.clouddn.com/4%E6%9C%88-13-2018%2013-10-41.gif" alt=""></p><hr><p><strong>参考：</strong></p><p><a href="https://jingyan.baidu.com/article/f96699bb9442f3894e3c1b15.html" target="_blank" rel="external">https://jingyan.baidu.com/article/f96699bb9442f3894e3c1b15.html</a></p><p><a href="https://blog.csdn.net/zhouchangshi/article/details/37901519" target="_blank" rel="external">https://blog.csdn.net/zhouchangshi/article/details/37901519</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;eclipse的界面主题更换&quot;&gt;&lt;a href=&quot;#eclipse的界面主题更换&quot; class=&quot;headerlink&quot; title=&quot;eclipse的界面主题更换&quot;&gt;&lt;/a&gt;&lt;em&gt;eclipse&lt;/em&gt;的界面主题更换&lt;/h2&gt;&lt;p&gt;关于我的&lt;em&gt;eclip
      
    
    </summary>
    
      <category term="eclipse" scheme="https://liujunjie11.github.io/categories/eclipse/"/>
    
    
      <category term="eclipse" scheme="https://liujunjie11.github.io/tags/eclipse/"/>
    
  </entry>
  
  <entry>
    <title>python3爬虫：爬取淘宝商品信息的两种方法</title>
    <link href="https://liujunjie11.github.io/2018/04/08/python3%E7%88%AC%E8%99%AB%EF%BC%9A%E7%88%AC%E5%8F%96%E6%B7%98%E5%AE%9D%E5%95%86%E5%93%81%E4%BF%A1%E6%81%AF%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
    <id>https://liujunjie11.github.io/2018/04/08/python3爬虫：爬取淘宝商品信息的两种方法/</id>
    <published>2018-04-08T10:58:00.000Z</published>
    <updated>2018-04-09T03:59:21.431Z</updated>
    
    <content type="html"><![CDATA[<p>爬取淘宝信息：</p><blockquote><p>1，可用<em>selenium</em>模块与<em>driver Chrome</em>插件自动化模拟爬取。</p><p>2， 进行抓包爬取。</p></blockquote><p><strong>下面一一进行介绍并且贴出实现代码。但是在此必须说明一下，因为时间有限，相关模块不懂的还需要自行搜索，在此不做教程解说，只提供分析思路与代码实现过程。</strong></p><blockquote><p>学习博客推荐：<a href="https://cuiqingcai.com，" target="_blank" rel="external">https://cuiqingcai.com，</a><br>实际上我也是根据此博客学习到了一些知识，也是我参考学习的唯一博客。</p></blockquote><h2 id="自动化模拟爬取"><a href="#自动化模拟爬取" class="headerlink" title="自动化模拟爬取"></a>自动化模拟爬取</h2><p>python爬虫的<em>selenium</em>模块是一个可以实现模拟浏览器相关动作，并且可跳过<em>JavaScript动态渲染</em>直接返回其网页源代码的一个自动化测试工具。如下我们需要爬取关键词为<em>MacBook Pro</em>的商品信息，可用它来实现自动翻页并且返回每一页的源代码直接进行相关信息的爬取。</p><h3 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h3><p>下面直接进行分析过程。</p><p>首先打开淘宝主页：<a href="https://www.taobao.com" target="_blank" rel="external">https://www.taobao.com</a> ，进入其中输入关键词观察一下页面，可以看到下面翻页的一些跳转功能。（以下使用的都是<em>Chrome</em>自带的<em>开发者工具</em>）</p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-08%20%E4%B8%8B%E5%8D%888.10.59.png" alt=""></p><p>因为要实现自动翻页的过程，则我们需要查看有关翻页这个功能按钮的源代码是什么样子。其中涉及到了输入框，然后点击旁边的确定按钮。</p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-08%20%E4%B8%8B%E5%8D%888.15.27.png" alt=""></p><blockquote><p>输入框对应的源代码。</p></blockquote><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-08%20%E4%B8%8B%E5%8D%888.18.39.png" alt=""></p><blockquote><p>确定按钮对应的源代码。</p></blockquote><p>在知道了以上的一些按钮信息之后我们还需要知道翻页之后目前对应的页数在哪，以便在对应的页数正确之后，可以得到对应页面的源代码，这样可直接运用一些相关的模块进行节点锁定爬取即可。</p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-08%20%E4%B8%8B%E5%8D%888.19.13.png" alt=""></p><blockquote><p>确定页数码的源代码。</p></blockquote><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-08%20%E4%B8%8B%E5%8D%887.32.20.png" alt=""></p><blockquote><p>页面上商品信息的html源代码。</p></blockquote><p>为什么要这样分析每一个相关功能的源代码？<strong>因为在selenium模块中可以实现自动化的过程，但是需要指定页面上相关的源代码才行，对于selenium来说等于开放了这个功能的接口一样。</strong></p><p><strong>思路分析：将要用相关模块挖掘源代码信息做为一个函数，将要爬取的页面源代码做为一个函数，其中实现自动翻页功能，即若是大于1，自动跳到其页面并且返回其页源代码，否则返回第一页页面的源代码。最后代入前者挖掘的函数。</strong></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code>&apos;&apos;&apos;    函数目标：    利用selenium的自动翻页进行爬去相关的内容    编写时间：    2018-04-07&apos;&apos;&apos;from selenium import webdriverfrom selenium.webdriver.common.by import Byfrom selenium.webdriver.support import expected_conditions as ECfrom selenium.webdriver.support.wait import WebDriverWaitfrom urllib.parse import quotefrom pyquery import PyQuery as pqbrowser = webdriver.Chrome(&apos;/Users/junjieliu/Downloads/小插件/chromedriver&apos;)wait = WebDriverWait(browser, 10)keys = &apos;macbookpro&apos;&apos;&apos;&apos;    函数说明：实现自动化翻页。    仅仅当需要时进行翻页的选项    &apos;&apos;&apos;def index_source(page):    print(&apos;正在爬取第&apos; + str(page) + &apos;页内容..&apos; + &apos;\n&apos; + &apos;.&apos; * 15)    url = &apos;https://s.taobao.com/search?q=&apos; + quote(keys)    browser.get(url)    # 果然页数大于1则自动翻页功能启动    if page &gt; 1:        # 输入框定位        input = wait.until(            EC.presence_of_element_located((By.CSS_SELECTOR, &apos;#mainsrp-pager div.form &gt; input.input.J_Input&apos;)))        # 确定按钮定位        button = wait.until(            EC.element_to_be_clickable((By.CSS_SELECTOR, &apos;#mainsrp-pager div.form &gt; span.btn.J_Submit&apos;)))        # 清理，输入，点击一体化        input.clear()        input.send_keys(page)        button.click()    &apos;&apos;&apos;    获取源代码，传入爬取数据的函数    获取源代码过程：    第一步确定为在那一页    第二步确定爬取内容    &apos;&apos;&apos;    wait.until(        EC.text_to_be_present_in_element((By.CSS_SELECTOR, &apos;#mainsrp-pager li.item.active &gt; span.num&apos;), str(page)))    wait.until(        EC.presence_of_element_located((By.CSS_SELECTOR, &apos;.m-itemlist .items .item&apos;)))    print(&apos;获取本页源码成功，以下为相关的信息：&apos; + &apos;\n&apos;)    get_product()&apos;&apos;&apos;    函数说明：    用pyquery爬取其中的商品内容    &apos;&apos;&apos;def get_product():    html_source = browser.page_source    doc = pq(html_source)    items = doc(&apos;#mainsrp-itemlist .items .item&apos;).items()    &apos;&apos;&apos;        以下匹配内容可查看网页源代码可知        &apos;&apos;&apos;    for item in items:        product_infos = {            &apos;img_url&apos;:&apos;https:&apos; + item.find(&apos;.pic .img&apos;).attr(&apos;data-src&apos;),  # 店铺主图片地址            &apos;product_desc&apos;:item.find(&apos;.pic .img&apos;).attr(&apos;alt&apos;),  # 商品描述            &apos;price&apos;:item.find(&apos;.price&apos;).text().replace(&apos;\n&apos;, &apos;&apos;),  # 价格            &apos;people&apos;:item.find(&apos;.deal-cnt&apos;).text(),  # 购买人数            &apos;shop_url&apos;:&apos;https:&apos; + item.find(&apos;.shop .shopname&apos;).attr(&apos;href&apos;),  # 店铺信息            &apos;shop_name&apos;:item.find(&apos;.shop&apos;).text(),  # 店铺名称            &apos;shop_location&apos;:item.find(&apos;.location&apos;).text()  # 店铺所在地            }        print(product_infos)if __name__ == &apos;__main__&apos;:    pages = 100  # 根据页面分析可知总共有100页的信息    for num in range(1, pages + 1):        index_source(num)     </code></pre><blockquote><p>当然还可以进行正则表达式的匹配来完成爬取，因为需要时间来测试相关的表达式，所以推荐用<em>pyquery</em>这个库来完成爬取工作，相比于使用过的<em>beautiful</em>模块以及正则表达式，我感觉轻松了不少。</p></blockquote><h2 id="抓包爬取"><a href="#抓包爬取" class="headerlink" title="抓包爬取"></a>抓包爬取</h2><p>以下的抓包是利用的<em>Chrome</em>浏览器完成的，在这之前说了，因为时间关系，关于抓包是什么就不在此做详细介绍了…相信你看了我下面的分析过程会隐约明白一点。</p><h3 id="分析过程-1"><a href="#分析过程-1" class="headerlink" title="分析过程"></a>分析过程</h3><p>打开淘宝主页，输入关键词，在第一页上打开<em>Chrome</em>自带的<em>开发者工具</em>，这样就可以看到第一页的源代码信息了。以下图过程可以看到我们在第一页抓到的相关的<em>淘宝API</em>的数据包。里面有相关的商品信息，均为<em>json</em>格式。</p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-08%20%E4%B8%8B%E5%8D%887.55.32.png" alt=""></p><hr><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-08%20%E4%B8%8B%E5%8D%887.56.39.png" alt=""></p><blockquote><p>其中的<em>XHR格式</em>不懂可参考此篇文章：<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest" target="_blank" rel="external">https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest</a></p></blockquote><p>浏览器新建一个标签页，打开上面的那个地址看看有什么。</p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-08%20%E4%B8%8B%E5%8D%888.24.11.png" alt=""></p><p><strong>经过一系列的测试发现了其中的那个参数<em>bcoffset=</em>是跳转的决定点，更改其值可得到不同的信息。</strong>这样我们进行思路分析就一目了然了。</p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-08%20%E4%B8%8B%E5%8D%888.21.47.png" alt=""></p><p><strong>思路分析：传入上面的说的API的URL，根据上面的那个参数的值更改，返回其中的文档信息，即可爬取到商品信息。</strong></p><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code>&apos;&apos;&apos;    函数说明：    利用抓包返回的信息直接爬取商品信息    编写时间：    2018-04-08&apos;&apos;&apos;import requestsimport reif __name__ == &apos;__main__&apos;:    # 设定爬取100页，实际上还要多...    pages = 100    for num in range(1, pages + 1):        print(&apos;开始爬取第&apos; + str(num) + &apos;页内容...&apos; + &apos;\n&apos; + &apos;.&apos; * 10)        url = &apos;https://s.taobao.com/api?_ksTS=1523191565870_226&amp;callback=jsonp227&amp;ajax=true&amp;m=customized&amp;stats_click=search_radio_all:1&amp;q=macbookpro&amp;p4ppushleft=1,48&amp;ntoffset=4&amp;s=36&amp;imgfile=&amp;initiative_id=staobaoz_20180408&amp;bcoffset=&apos; + str(num) + &apos;&amp;js=1&amp;ie=utf8&amp;rn=5bd3f39c2ca57f21abe4db8ca60ee49f&apos;        # 代理信息        header = {                &apos;cookie&apos;: &apos;t=da97f7b09403e3340cd6d50780a9385e; cna=PoshExqPgw0CAQG9KdLV29qM; hng=CN%7Czh-CN%7CCNY%7C156; thw=cn; enc=MuF%2FWOzFnau5EcbgcPck31M%2FMhER8txA4ZnjdZI2Dt8xzHdAr%2FN4f0OsOD%2FUcrNpOZWIfEG0GSbPQ8C4U%2BU70A%3D%3D; mt=ci%3D-1_1; cookie2=1f17bf1dfa8b6cf01c17d0fe7306c672; v=0; _tb_token_=eaefe3a15f0bf; JSESSIONID=0BC0D7637EFFD50CA56F8A8F4E451813; isg=BD09zFTCO5bo0p_z6P-VaFHGTJ_3cnEiA2cTwf-D2RRsNl5oySop_Xqg5Wpwlonk&apos;,                &apos;referer&apos;: &apos;https://s.taobao.com/search?q=macbookpro&amp;imgfile=&amp;js=1&amp;stats_click=search_radio_all%3A1&amp;initiative_id=staobaoz_20180408&amp;ie=utf8&amp;bcoffset=4&amp;p4ppushleft=1%2C48&amp;ntoffset=4&amp;s=0&apos;,                &apos;user-agent&apos;: &apos;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.181 Safari/537.36&apos;,                &apos;x-requested-with&apos;: &apos;XMLHttpRequest&apos;}        responed = requests.get(url=url, headers=header)        # 指定编码格式        responed.encoding = &apos;utf-8&apos;        re_text = responed.text        &apos;&apos;&apos;            进入数据清洗与筛选阶段            因为转化json格式始终失败...所以改用正则表达式来进行匹配        &apos;&apos;&apos;        print(&apos;获取源代码成功，以下为相关商品的信息：&apos;)        target = re.findall(r&apos;&quot;raw_title&quot;:&quot;(.*?)&quot;.*?&quot;pic_url&quot;:&quot;(.*?)&quot;.*?&quot;view_price&quot;:&quot;(.*?)&quot;.*?&quot;item_loc&quot;:&quot;(.*?)&quot;.*?&quot;view_sales&quot;:&quot;(.*?)&quot;.*?&quot;user_id&quot;:&quot;(.*?)&quot;.*?&quot;nick&quot;:&quot;(.*?)&quot;&apos;, re_text, re.S)  # @UndefinedVariable        for each in target:            product = {                &apos;shop_title&apos;:each[0],  # 店铺主题                &apos;pic_url&apos;:&apos;https:&apos; + each[1],  # 店铺图片地址                &apos;price&apos;:each[2],  # 价格                &apos;sales_people&apos;:each[4],  # 购买人数                &apos;shop_name&apos;:each[6],  # 店铺名称                &apos;loc&apos;:each[3],  # 店铺所在地                &apos;shop_url&apos;:&apos;https://store.taobao.com/shop/view_shop.htm?user_number_id=&apos; + each[5]  # 店铺URL地址                    }            print(product)</code></pre><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>第二种方法期间原本以为可以先转化为<em>json格式</em>来进行处理，没想到发生了<strong>json.decoder.JSONDecodeError:</strong>的错误，结果改用正则表达式进行文本的挖掘，效率也是无形中得到了提升…在此我推荐用正则表达式来处理<em>json格式</em>的文档，这样在绝大多数情况下可能会有更高的效率！</p><p>爬取到的数据可用来进行一些数据分析等等。有时想尝试用各种方法去爬取，但是因为学的东西真的多，所以就不一一尝试了，尽量使用简便的方法…不懂的朋友还需要多多学习，利用好搜索引擎！当然看书也是必须的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;爬取淘宝信息：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1，可用&lt;em&gt;selenium&lt;/em&gt;模块与&lt;em&gt;driver Chrome&lt;/em&gt;插件自动化模拟爬取。&lt;/p&gt;
&lt;p&gt;2， 进行抓包爬取。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;下面一一进
      
    
    </summary>
    
      <category term="python爬虫" scheme="https://liujunjie11.github.io/categories/python%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="python爬虫" scheme="https://liujunjie11.github.io/tags/python%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>关于记录Chromedriver的selenium.common.exceptions.WebDriverException: Message: &#39;chromedriver &#39; executable needs to be in PATH. Please see https://sites.google.com/a/chromium.org/chromedriver/home</title>
    <link href="https://liujunjie11.github.io/2018/04/05/%E5%85%B3%E4%BA%8E%E8%AE%B0%E5%BD%95Chromedriver%E7%9A%84selenium-common-exceptions-WebDriverException-Message-chromedriver-executable-needs-to-be-in-PATH-Please-see-https-sites-google-com-a-chromium-org-chromedriver-home/"/>
    <id>https://liujunjie11.github.io/2018/04/05/关于记录Chromedriver的selenium-common-exceptions-WebDriverException-Message-chromedriver-executable-needs-to-be-in-PATH-Please-see-https-sites-google-com-a-chromium-org-chromedriver-home/</id>
    <published>2018-04-05T11:46:15.000Z</published>
    <updated>2018-04-05T12:01:34.821Z</updated>
    
    <content type="html"><![CDATA[<p>最近学习一些<em>python</em>爬虫的框架，用<em>selenium</em>与<em>Chromedriver</em>插件结合<em>Chrome浏览器</em>来爬去网页源数据。</p><p>发现了如题的错误信息：</p><blockquote><p>selenium.common.exceptions.WebDriverException: Message:<br>  ‘chromedriver ‘ executable needs to be in PATH. Please see<br>  <a href="https://sites.google.com/a/chromium.org/chromedriver/home" target="_blank" rel="external">https://sites.google.com/a/chromium.org/chromedriver/home</a></p></blockquote><p>在已配置好系统环境的前提下，用如下代码指定位置，或者是将<em>Chromedriver</em>插件放在工程文件下，均得到了如上的错误信息。</p><pre><code>from selenium import webdriverbrowser = webdriver.Chrome(&apos;/Users/junjieliu/Downloads/小插件/chromedriver&apos;)</code></pre><hr><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>如下操作，先将插件打开（即表示打开运行了，<strong>在需要使用时应当一直开着</strong>），跳出来了其所在位置，将其位置复制再运行上面的代码，发现跳出来了一个<em>Chrome浏览器</em>的空白页面，这表示已经成功了！</p><p><img src="http://owudg3xs2.bkt.clouddn.com/4%E6%9C%88-05-2018%2019-56-36.gif" alt=""></p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-05%20%E4%B8%8B%E5%8D%888.00.03.png" alt=""></p><blockquote><p>成功的页面。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近学习一些&lt;em&gt;python&lt;/em&gt;爬虫的框架，用&lt;em&gt;selenium&lt;/em&gt;与&lt;em&gt;Chromedriver&lt;/em&gt;插件结合&lt;em&gt;Chrome浏览器&lt;/em&gt;来爬去网页源数据。&lt;/p&gt;
&lt;p&gt;发现了如题的错误信息：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p
      
    
    </summary>
    
      <category term="爬虫" scheme="https://liujunjie11.github.io/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="爬虫" scheme="https://liujunjie11.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>python3爬取豆瓣Top250电影信息</title>
    <link href="https://liujunjie11.github.io/2018/04/03/python3%E7%88%AC%E5%8F%96%E8%B1%86%E7%93%A3Top250%E7%94%B5%E5%BD%B1%E4%BF%A1%E6%81%AF/"/>
    <id>https://liujunjie11.github.io/2018/04/03/python3爬取豆瓣Top250电影信息/</id>
    <published>2018-04-03T14:09:36.000Z</published>
    <updated>2018-04-04T02:29:05.477Z</updated>
    
    <content type="html"><![CDATA[<p>以下是通过正则表达式爬取的<em>猫眼电影</em>以及<em>豆瓣电影</em>的相关的电影信息的代码过程。</p><hr><h2 id="爬取猫眼电影"><a href="#爬取猫眼电影" class="headerlink" title="爬取猫眼电影"></a>爬取猫眼电影</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>打开<em>Chrome</em>的调试工具，可发现相关的信息都在，并且以翻页的形式来得到更多的电影信息。</p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-04%20%E4%B8%8A%E5%8D%8810.17.59.png" alt=""></p><blockquote><p>我们可通过其爬取需要的信息，利用正则表达式来进行文本的挖掘。</p></blockquote><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code>&apos;&apos;&apos;    函数目标：    爬取猫眼电影的top100信息    编写时间：    2018-03-28&apos;&apos;&apos;&apos;&apos;&apos;import requestsimport reimport jsonif __name__ == &apos;__main__&apos;:print(&apos;猫眼电影Top100信息如下：&apos;)#循环10次，得出页面上的Top100的电影信息for i in range(0, 10):    url = &quot;http://maoyan.com/board/4?&quot;    header = {            &apos;Host&apos;:&apos;maoyan.com&apos;,            &apos;Referer&apos;:&apos;http://maoyan.com/board/4?offset=20&apos;,            &apos;User-Agent&apos;:&apos;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.181 Safari/537.36&apos;}    paramters = {            &apos;offset&apos;: i * 10}    request_tasget = requests.get(url=url, headers=header, params=paramters)    request_tasget.encoding = &apos;utf-8&apos;    # 实际上应该考虑考虑网的问题...连不上就一般没有数据返回了，找一个字符作为接口之后利用万能表达式即可    infos_list = re.findall(    r&apos;&lt;dd&gt;.*?board-index.*?&gt;(.*?)&lt;/i&gt;.*?alt.*?src=&quot;(.*?)&quot;.*?&lt;a.*?&gt;(.*?)&lt;/a&gt;.*?&quot;star&quot;&gt;(.*?)&lt;/p&gt;.*?&quot;releasetime&quot;&gt;(.*?)&lt;/p&gt;.*?&quot;integer&quot;&gt;(.*?)&lt;/i&gt;.*?&quot;fraction&quot;&gt;(.*?)&lt;/i&gt;&apos;,    request_tasget.text, re.S)  # @UndefinedVariable    #建立存储信息的字典    for each in infos_list:        yields = {                &apos;index&apos;:each[0],                &apos;image_info&apos;:each[1],                &apos;name&apos;:each[2],                &apos;actor&apos;:each[3].strip(),                &apos;time&apos;:each[4],                &apos;score&apos;:each[5] + each[6]                }        print(yields)</code></pre><h2 id="爬取豆瓣电影"><a href="#爬取豆瓣电影" class="headerlink" title="爬取豆瓣电影"></a>爬取豆瓣电影</h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>与爬取猫眼电影信息一样，都是一样的，具体的差距还是在豆瓣上爬取信息需要<em>cookie</em>，具体可参考下面的代码。</p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-04%20%E4%B8%8A%E5%8D%8810.18.27.png" alt=""></p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><pre><code>&apos;&apos;&apos;    函数目标：    爬取豆瓣Top250的电影信息    编写时间：    2018-04-01&apos;&apos;&apos;import requestsimport re if __name__ == &apos;__main__&apos;:print(&apos;以下为豆瓣Top250的电影信息：&apos;)# 从页面可看到一共有十页，每页上有25个电影的信息for i in range(0, 10):    url = &quot;https://movie.douban.com/top250?&quot;    header = {            &apos;Connection&apos;: &apos;keep-alive&apos;,            &apos;Cookie&apos;: &apos;bid=x9ipkoKiQgw; _pk_ses.100001.4cf6=*; __utma=30149280.2001666009.1522587991.1522587991.1522587991.1; __utmb=30149280.0.10.1522587991; __utmc=30149280; __utmz=30149280.1522587991.1.1.utmcsr=(direct)|utmccn=(direct)|utmcmd=(none); __utma=223695111.1530785565.1522587991.1522587991.1522587991.1; __utmb=223695111.0.10.1522587991; __utmc=223695111; __utmz=223695111.1522587991.1.1.utmcsr=(direct)|utmccn=(direct)|utmcmd=(none); ll=&quot;118146&quot;; _vwo_uuid_v2=D575771A914BC38B3B7D081C0A0296FDC|939d8f7fdff1f383a97d572dab39fa1a; _pk_id.100001.4cf6=1de732c7ac4dc22b.1522587990.1.1522588516.1522587990.; ct=y&apos;,            &apos;Host&apos;: &apos;movie.douban.com&apos;,            &apos;Referer&apos;: &apos;https://movie.douban.com/top250?start=25&amp;filter=&apos;,            &apos;Upgrade-Insecure-Requests&apos;: &apos;1&apos;,            &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.181 Safari/537.36}&apos;             }    paramters = {             &apos;start&apos;: i * 25,             &apos;filter&apos;:&apos;&apos;              }    tasget = requests.get(url=url, headers=header, params=paramters)    tasget.encoding = &apos;utf-8&apos;    # 匹配正则表达式    infos = re.findall(r&apos;&lt;li&gt;.*?&lt;em class=&quot;&quot;&gt;(.*?)&lt;/em&gt;.*?alt=.*?src=&quot;(.*?)&quot;.*?&quot;title&quot;&gt;(.*?)&lt;/span&gt;.*?class=&quot;title&quot;&gt;&amp;nbsp;/&amp;nbsp;(.*?)&lt;/span&gt;.*?&quot;other&quot;&gt;&amp;nbsp;/&amp;nbsp;(.*?)&lt;/span&gt;.*?&lt;p class=&quot;&quot;&gt;(.*?)&amp;nbsp;&amp;nbsp;&amp;nbsp;(.*?)&lt;br&gt;(.*?)&amp;nbsp;/&amp;nbsp(.*?)&amp;nbsp;/&amp;nbsp(.*?)&lt;/p&gt;.*?average&quot;&gt;(.*?)&lt;/span&gt;&apos;, tasget.text, re.S)  # @UndefinedVariable    # 建立一个空字典用于存储相关的信息    for each in infos:        yields = {            &apos;index&apos;:each[0],  # 排名            &apos;img_info&apos;:each[1],  # 照片地址            &apos;name&apos;:each[2].strip() + &quot;/&quot; + each[3].strip() + &quot;/&quot; + each[4].strip(),  # 影片名称            &apos;director&apos;:each[5].strip(),  # 导演            &apos;actor&apos;:each[6],  # 演员            &apos;time_cy&apos;:each[7].strip() + each[8],  # 上演时间及地区            &apos;type&apos;:each[9].strip(),  # 影片类型            &apos;score&apos;:each[10]  # 评分            }        print(yields)</code></pre><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>简单说说其中的含义，表达式<code>.*?</code>是一个万能的匹配式，<code>(.*?)</code>是匹配想要爬取的内容，并且每一次伴随着一个索引号，每一个索引号对应着的信息不同。利用正则表达式可方便的进行文本与代码的分开挖掘，一般在写正则表达式时用<em>html</em>代码中的一些词来进行过渡就可以方便的写出来了。</p><blockquote><p>多说无益，还是需要自己来进行代码的测试了解的。</p></blockquote><ul><li>参考的博客：<a href="https://cuiqingcai.com" target="_blank" rel="external">https://cuiqingcai.com</a></li></ul><blockquote><p>可根据此博客来学习更多的爬虫知识。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;以下是通过正则表达式爬取的&lt;em&gt;猫眼电影&lt;/em&gt;以及&lt;em&gt;豆瓣电影&lt;/em&gt;的相关的电影信息的代码过程。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;爬取猫眼电影&quot;&gt;&lt;a href=&quot;#爬取猫眼电影&quot; class=&quot;headerlink&quot; title=&quot;爬取猫眼电影&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
      <category term="python爬虫" scheme="https://liujunjie11.github.io/categories/python%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="python3爬虫" scheme="https://liujunjie11.github.io/tags/python3%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>Mac下的mysql安装以及相关的问题解决</title>
    <link href="https://liujunjie11.github.io/2018/04/03/Mac%E4%B8%8B%E7%9A%84mysql%E5%AE%89%E8%A3%85%E4%BB%A5%E5%8F%8A%E7%9B%B8%E5%85%B3%E7%9A%84%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
    <id>https://liujunjie11.github.io/2018/04/03/Mac下的mysql安装以及相关的问题解决/</id>
    <published>2018-04-03T11:48:48.000Z</published>
    <updated>2018-04-03T12:58:55.064Z</updated>
    
    <content type="html"><![CDATA[<p>最近因为学习到了爬虫的原因，存储数据需要<em>mysql</em>了，因为以前学习过其命令行，所以在之前安装过了，太久没用了，怎么开都不懂了，搞了几十分钟不想搞了，重新安装。下面记录下遇到的一些问题。</p><hr><h2 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h2><h3 id="第一种方法"><a href="#第一种方法" class="headerlink" title="第一种方法"></a>第一种方法</h3><p>进入官网下载对应<em>Mac</em>的<em>mysql</em>。</p><blockquote><p><a href="https://dev.mysql.com/downloads/mysql/" target="_blank" rel="external">官网地址</a></p></blockquote><h3 id="第二种方法"><a href="#第二种方法" class="headerlink" title="第二种方法"></a>第二种方法</h3><p>直接用命令行<code>brew Install mysql</code>。</p><blockquote><p>前提是必须安装了<em>homebrew</em>。</p></blockquote><h2 id="配置以及开启过程"><a href="#配置以及开启过程" class="headerlink" title="配置以及开启过程"></a>配置以及开启过程</h2><h3 id="配置过程"><a href="#配置过程" class="headerlink" title="配置过程"></a>配置过程</h3><p>在手动安装正后一步记下默认的密码（如下图）。</p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-03%20%E4%B8%8B%E5%8D%888.34.15.png" alt=""></p><blockquote><p>即<strong>QeV.a&gt;zGa1m3</strong>为默认密码。</p></blockquote><p>在<em>偏好系统</em>中手动打开<em>mysql</em>应用。</p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-03%20%E4%B8%8B%E5%8D%888.34.36.png" alt=""></p><p>之后打开终端，为其配置。（命令行如下依次）</p><p><code>vi ~/bash_profile</code></p><p>进入按字母<em>i</em>进入编辑模式，输入：</p><p><code>export PATH=&quot;$PATH:/usr/local/mysql/bin&quot;</code></p><blockquote><p>在此可能有疑惑，为什么可以直接<code>mysql/bin</code>？因为在我们手动下载<br><em>mysql</em>之后系统已经自动的复制了一遍，并且将其名为<em>mysql</em>，如图在<em>/usr/local/</em>可找到。</p></blockquote><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-03%20%E4%B8%8B%E5%8D%888.18.02.png" alt=""></p><hr><p>接着输入相关的命令…这时已经配置好了，按下<em>esc</em>健进入命令行模式，输入<code>：wq</code>,推出。之后为了快速见效输入<code>source ~/bash_profile</code></p><h3 id="启动过程"><a href="#启动过程" class="headerlink" title="启动过程"></a>启动过程</h3><p>输入命令行<code>mysql -uroot -p</code>,提示输入刚刚的默认密码，进入到了<em>mysql</em>的编译界面之后，我们修改默认密码，输入代码<code>set PASSWORD =PASSWORD(&#39;123456&#39;);</code></p><blockquote><p><strong>其中的<em>123456</em>为新的密码。</strong></p></blockquote><p>之后为测试是否已经修改成功，输入<code>exit();</code>推出界面，输入命令行<code>mysql -uroot -p</code>,提示输入刚刚的新密码，成功进入编译界面。</p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-03%20%E4%B8%8B%E5%8D%888.32.00.png" alt=""></p><h2 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h2><p>可参考：<a href="https://www.jianshu.com/p/b02be6026a2a" target="_blank" rel="external">https://www.jianshu.com/p/b02be6026a2a</a></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p><strong>解决问题：ERROR 1045 (28000): Access denied for user ‘root’@’localhost’ (using password: YES)</strong></p><p>可参考：<a href="https://www.digitalocean.com/community/questions/setup-mysql-on-ubuntu-droplet-getting-error-error-1045-28000-access-denied-for-user-root-localhost-using-password-yes" target="_blank" rel="external">https://www.digitalocean.com/community/questions/setup-mysql-on-ubuntu-droplet-getting-error-error-1045-28000-access-denied-for-user-root-localhost-using-password-yes</a></p><p><strong>解决进程问题</strong></p><p>可参考：<a href="https://blog.csdn.net/liumaolincycle/article/details/51896592" target="_blank" rel="external">https://blog.csdn.net/liumaolincycle/article/details/51896592</a></p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>有时下载完之后也会出现上面的那个问题，我是通过重新启动电脑之后获得了解决。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近因为学习到了爬虫的原因，存储数据需要&lt;em&gt;mysql&lt;/em&gt;了，因为以前学习过其命令行，所以在之前安装过了，太久没用了，怎么开都不懂了，搞了几十分钟不想搞了，重新安装。下面记录下遇到的一些问题。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;安装过程&quot;&gt;&lt;a href=&quot;#安装
      
    
    </summary>
    
      <category term="mysql" scheme="https://liujunjie11.github.io/categories/mysql/"/>
    
    
      <category term="mysql" scheme="https://liujunjie11.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>关于解决python中UnicodeDecodeError: &#39;ascii&#39; codec can&#39;t decode byte 0xe8 in position 67986: ordinal not in range(128)的问题</title>
    <link href="https://liujunjie11.github.io/2018/03/28/%E5%85%B3%E4%BA%8E%E8%A7%A3%E5%86%B3python%E4%B8%ADUnicodeDecodeError-ascii-codec-can-t-decode-byte-0xe8-in-position-67986-ordinal-not-in-range-128-%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://liujunjie11.github.io/2018/03/28/关于解决python中UnicodeDecodeError-ascii-codec-can-t-decode-byte-0xe8-in-position-67986-ordinal-not-in-range-128-的问题/</id>
    <published>2018-03-28T10:18:54.000Z</published>
    <updated>2018-03-28T10:26:59.245Z</updated>
    
    <content type="html"><![CDATA[<p>在学习爬虫的过程中，在运行编者的代码时出现了<em>UnicodeDecodeError: ‘ascii’ codec can’t decode byte 0xe8 in position 67986: ordinal not in range(128)</em>的编码问题。</p><p>具体原因是因为程序默认的解析编码格式发生了冲突造成的，简单来说就是需要解析的内容与<em>API</em>程序默认的解析编码格式不同，所以才会出现如上的错误。</p><p>因为是打算用<em>python</em>解析<em>JS</em>文件，所以我就贴上我的解决方案了：</p><pre><code>ctx = node.compile(open(file, encoding=&apos;utf-8&apos;).read())</code></pre><blockquote><p>加上自行规定的解码格式即可。</p></blockquote><p><strong>解决来源于GitHub论坛…</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在学习爬虫的过程中，在运行编者的代码时出现了&lt;em&gt;UnicodeDecodeError: ‘ascii’ codec can’t decode byte 0xe8 in position 67986: ordinal not in range(128)&lt;/em&gt;的编码问题
      
    
    </summary>
    
      <category term="学习笔记" scheme="https://liujunjie11.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="学习笔记" scheme="https://liujunjie11.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>关于homebrew下载出现&quot;Error/go/version missing for  gotools resource!&quot;错误的解决方案</title>
    <link href="https://liujunjie11.github.io/2018/03/28/%E5%85%B3%E4%BA%8Ehomebrew%E4%B8%8B%E8%BD%BD%E5%87%BA%E7%8E%B0Error:go:version%20missing%20for%20%20gotools%20resource!%E9%94%99%E8%AF%AF%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>https://liujunjie11.github.io/2018/03/28/关于homebrew下载出现Error:go:version missing for  gotools resource!错误的解决方案/</id>
    <published>2018-03-28T02:47:34.000Z</published>
    <updated>2018-03-28T02:48:35.030Z</updated>
    
    <content type="html"><![CDATA[<p>最近用<em>homebrew</em>下载<em>mongodb</em>，发现出现了<em>Error: go: version missing for “gotools” resource!</em>的错误，试了几次都不行，最后在谷歌用英文搜索关键词在<em>GitHub</em>的一个论坛用相关的解决方案。</p><p><strong>使用命令行</strong></p><blockquote><p><strong>git -C “$(brew –repo)” fetch –tags</strong></p></blockquote><p>之后再次输入：</p><blockquote><p><strong>brew update –force</strong></p></blockquote><p>最后再次用命令行<em>brew install mongodb</em>，发现已经能够正确成功下载了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近用&lt;em&gt;homebrew&lt;/em&gt;下载&lt;em&gt;mongodb&lt;/em&gt;，发现出现了&lt;em&gt;Error: go: version missing for “gotools” resource!&lt;/em&gt;的错误，试了几次都不行，最后在谷歌用英文搜索关键词在&lt;em&gt;GitH
      
    
    </summary>
    
      <category term="学习笔记" scheme="https://liujunjie11.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="学习笔记" scheme="https://liujunjie11.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法：线性表</title>
    <link href="https://liujunjie11.github.io/2018/03/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%9A%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    <id>https://liujunjie11.github.io/2018/03/26/数据结构与算法：线性表/</id>
    <published>2018-03-26T10:56:19.000Z</published>
    <updated>2018-04-03T12:29:47.274Z</updated>
    
    <content type="html"><![CDATA[<p>打算重新好好系统的学习数据结构了。这是开始。</p><p>因为概念已经是烂大街了，在此只记录下我用<em>java</em>或者是<em>python</em>实现相关功能的代码。</p><hr><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><h3 id="java实现"><a href="#java实现" class="headerlink" title="java实现"></a>java实现</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;打算重新好好系统的学习数据结构了。这是开始。&lt;/p&gt;
&lt;p&gt;因为概念已经是烂大街了，在此只记录下我用&lt;em&gt;java&lt;/em&gt;或者是&lt;em&gt;python&lt;/em&gt;实现相关功能的代码。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;查找&quot;&gt;&lt;a href=&quot;#查找&quot; class=&quot;hea
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://liujunjie11.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="https://liujunjie11.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>计算机基础知识：认识计算机</title>
    <link href="https://liujunjie11.github.io/2018/03/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%9A%E8%AE%A4%E8%AF%86%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    <id>https://liujunjie11.github.io/2018/03/26/计算机基础知识：认识计算机/</id>
    <published>2018-03-26T03:44:12.000Z</published>
    <updated>2018-03-26T05:12:33.821Z</updated>
    
    <content type="html"><![CDATA[<p>计算机发展到了如今这样的一个地步实在让人感兴趣…</p><p>于是看了一些书和文章，想了解了解一个计算机是如何跑起来的。</p><hr><h2 id="机器本质"><a href="#机器本质" class="headerlink" title="机器本质"></a>机器本质</h2><blockquote><p><strong>计算机的本质</strong></p></blockquote><ul><li>计算机的本质<strong>：（电脑）计算机 = 计算机器</strong></li></ul><p>没错，如今<strong>我们使用的计算机就是和我们小学时按的那个只会加减乘除计算器的本质毫无区别</strong>。使用计算机时，我们会先通过键盘或者是语音输入想要了解的信息，之后计算机会通过内部一系列的运算之后，输出相关的界面信息到我们的屏幕上。那我们可理解计算机就是一通过我们输入，然后自己默默运算完输出结果的机器。电脑电脑，正所谓脑子就是人类的<strong>计算机器</strong>，电脑不过是插上电源才能运行的计算机器。</p><p><img src="" alt=""></p><p>什么图画啊，文档内容等等均是先转化为相关的数字信息（如我们学过的二进制，十六进制等）后才在显示器上呈现出来的，所以在此可理解为什么还会有那么多各式各样的字符编码了吧。如中文编码常见的<em>GB2312</em>等。</p><blockquote><p><strong>计算机上的1与0</strong></p></blockquote><ul><li><strong>计算机是电子产品，其构造是由一些硬件组成。</strong></li></ul><p>再继续说说烂大街的绝大部分地球人都知道的事实：<strong>计算机只认识1和0</strong>。因为计算机是集成电路（IC）组成,运行起来接上电源之后需要传输数据了（即属于电子数字电路），而在数字电路中，二进制（binary）数是指用二进制记数系统，即以2为基数的记数系统表示的数字。这一系统中，通常用两个不同的符号0（代表零）和1（代表一）来表示。以2为基数代表系统是二进位制的。数字电子电路中，逻辑门的实现直接应用了二进制，因此现代的计算机和依赖计算机的设备里都用到二进制。每个数字称为一个位元（二进制位）或比特（Bit，Binary digit的缩写）。补充：<strong>比特是信息的最小单位， 字节是信息的基本单位。</strong></p><p>结合上面的说明，可知道数据都是在计算机中以1和0组成的，一是因为计算机本身的结构所致，二是因为这样可方便的转化为其他的数字类型（包括十进制之类的）。<strong>对于计算机来说，什么都是数字。只是数字的组成不同而已。</strong></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p>维基百科：<a href="https://zh.wikipedia.org/wiki/二进制" target="_blank" rel="external">https://zh.wikipedia.org/wiki/二进制</a></p></li><li><p>书籍：《计算机是怎么跑起来的》 矢泽久雄 著</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;计算机发展到了如今这样的一个地步实在让人感兴趣…&lt;/p&gt;
&lt;p&gt;于是看了一些书和文章，想了解了解一个计算机是如何跑起来的。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;机器本质&quot;&gt;&lt;a href=&quot;#机器本质&quot; class=&quot;headerlink&quot; title=&quot;机器本质&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
      <category term="计算机基础知识" scheme="https://liujunjie11.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="计算机基础知识" scheme="https://liujunjie11.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>Mac下安装Redis以及其可视化客户端</title>
    <link href="https://liujunjie11.github.io/2018/03/22/Mac%E4%B8%8B%E5%AE%89%E8%A3%85Redis%E4%BB%A5%E5%8F%8A%E5%85%B6%E5%8F%AF%E8%A7%86%E5%8C%96%E5%AE%A2%E6%88%B7%E7%AB%AF/"/>
    <id>https://liujunjie11.github.io/2018/03/22/Mac下安装Redis以及其可视化客户端/</id>
    <published>2018-03-22T13:17:30.000Z</published>
    <updated>2018-03-22T13:40:22.174Z</updated>
    
    <content type="html"><![CDATA[<p>最近想要用<em>Nosql</em>结合做一些小项目，用的是<em>Mac</em>，看到网上的教程有点乱七八糟的了，就打算记录下来了。</p><p>关于这个数据库就不在此介绍了。</p><h2 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h2><blockquote><p>来到官网页面下载：<a href="https://redis.io/download" target="_blank" rel="external">https://redis.io/download</a></p></blockquote><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-03-22%20%E4%B8%8B%E5%8D%889.35.10.png" alt=""></p><hr><p>下载好之后解压，并且要知道目录文件在哪。现在打开终端，用命令 <code>cd 文件目录地址</code>，如我的是 <code>cd /Users/junjieliu/Documents/编程文件/redis-4.0.8</code>，之后使用命令 <code>sudo make</code> 成功之后出现如下图1所示，之后再使用命令 <code>make test</code>,成功之后出现如图2所示。</p><ul><li>图1:</li></ul><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-03-22%20%E4%B8%8B%E5%8D%888.53.59.png" alt=""></p><ul><li>图2:</li></ul><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-03-22%20%E4%B8%8B%E5%8D%888.57.13.png" alt=""></p><p>之后，编译安装：在终端中输入命令：<code>sudo make install</code></p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-03-22%20%E4%B8%8B%E5%8D%888.57.56.png" alt=""></p><p>启动Redis,输入命令<code>redis-server</code></p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-03-22%20%E4%B8%8B%E5%8D%888.58.33.png" alt=""></p><blockquote><p>至此就安装成功了，以上命令有时可能会有出现错误的结果，多试试。</p></blockquote><h2 id="安装Redis-Desktop-Manager"><a href="#安装Redis-Desktop-Manager" class="headerlink" title="安装Redis Desktop Manager"></a>安装Redis Desktop Manager</h2><p>到此网站下载即可：<a href="https://sourceforge.net/projects/redis-desktop-manager.mirror/" target="_blank" rel="external">https://sourceforge.net/projects/redis-desktop-manager.mirror/</a></p><blockquote><p>当然可见我的云盘分享：<a href="https://pan.baidu.com/s/1Bvc7_tZ5yUnnwfnH2bDocg" target="_blank" rel="external">https://pan.baidu.com/s/1Bvc7_tZ5yUnnwfnH2bDocg</a></p></blockquote><p>下载完之后将软件移植系统<em>应用程序</em>一栏，打开：</p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-03-22%20%E4%B8%8B%E5%8D%889.10.11.png" alt=""></p><hr><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>介绍好评高的一本电子书《Redis实战》：</p><p><a href="http://www.java1234.com/a/javabook/database/2017/0625/8356.html" target="_blank" rel="external">http://www.java1234.com/a/javabook/database/2017/0625/8356.html</a></p><blockquote><p>进入网站即有相关的资源。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近想要用&lt;em&gt;Nosql&lt;/em&gt;结合做一些小项目，用的是&lt;em&gt;Mac&lt;/em&gt;，看到网上的教程有点乱七八糟的了，就打算记录下来了。&lt;/p&gt;
&lt;p&gt;关于这个数据库就不在此介绍了。&lt;/p&gt;
&lt;h2 id=&quot;安装过程&quot;&gt;&lt;a href=&quot;#安装过程&quot; class=&quot;hea
      
    
    </summary>
    
      <category term="教程" scheme="https://liujunjie11.github.io/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="教程" scheme="https://liujunjie11.github.io/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>用python/R数据分析可视化汽车使用燃料情况</title>
    <link href="https://liujunjie11.github.io/2018/03/21/%E7%94%A8python:R%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%8F%AF%E8%A7%86%E5%8C%96%E6%B1%BD%E8%BD%A6%E4%BD%BF%E7%94%A8%E7%87%83%E6%96%99%E6%83%85%E5%86%B5/"/>
    <id>https://liujunjie11.github.io/2018/03/21/用python:R数据分析可视化汽车使用燃料情况/</id>
    <published>2018-03-21T12:40:06.000Z</published>
    <updated>2018-03-22T07:26:01.239Z</updated>
    
    <content type="html"><![CDATA[<p>分析的是美国一个网站统计的多年汽车使用燃料情况的数据，需要从网上下载，在此利用好<em>python爬虫</em>大有裨益，可作为实战运行分析。</p><blockquote><p>此篇文章案例来源于：<img src="" alt=""></p><p>本书文章中用<em>R语言</em>实现的数据可视化，是从网上直接下的文件然后分析，我打算在此用<em>python</em>实现爬取相关文件，并且运用<em>python</em>进行可视化分析。</p></blockquote><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>进入主页，得到了下载文件的主链接：</p><p><img src="" alt=""></p><p>在此可见资源的下载地址：</p><p><img src="" alt=""></p><hr><blockquote><p>接下来就是运用爬虫知识实现此文件的下载了。</p></blockquote><h2 id="爬虫代码"><a href="#爬虫代码" class="headerlink" title="爬虫代码"></a>爬虫代码</h2><p>我们可有这样的思路：<strong>从主页出发 –&gt; 爬取到下载文件页面的链接 –&gt; 再从此爬取到下载地址链接 –&gt; 之后运用相关的函数下载至本目录即可。</strong>以下是实现过程。</p><pre><code>&apos;&apos;&apos;    函数目标：    用python爬取相关的下载文件    编写时间：    2018-03-21&apos;&apos;&apos;import requestsimport refrom bs4 import BeautifulSoupfrom urllib.request import urlretrieve&apos;&apos;&apos;    first_url方法获取进入下载页面的地址    运用了正则表达式的匹配方法                                        &apos;&apos;&apos;def first_url():    url = &apos;https://www.fueleconomy.gov/&apos;    # 添加代理    header = {&apos;Accept&apos;: &apos;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8&apos;,            &apos;Accept-Encoding&apos;: &apos;gzip, deflate, br&apos;,            &apos;Accept-Language&apos;: &apos;zh-CN,zh&apos;,            &apos;Cache-Control&apos;: &apos;max-age=0&apos;,            &apos;Connection&apos;: &apos;keep-alive&apos;,            &apos;Host&apos;: &apos;www.fueleconomy.gov&apos;,            &apos;Upgrade-Insecure-Requests&apos;: &apos;1&apos;,            &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.162 Safari/537.36}&apos;            }    request = requests.get(url=url, headers=header)    # 指定编码格式    request.encoding = &apos;utf-8&apos;    &apos;&apos;&apos;        发现不用指定re.S亦可以完成匹配，用了反而会报错...        注意每次匹配到的数据之后还有索引要记得标明    &apos;&apos;&apos;    link = re.findall(r&apos;&lt;a href=&quot;(.*?)&quot;&gt;Developer Tools&lt;/a&gt;&apos;, request.text)[0]    return link&apos;&apos;&apos;    second_url方法是用来获取下载文件的地址    方法也是运用了正则表达式                                            &apos;&apos;&apos;def second_url():    # 进入下载资源的页面    se_url = &apos;https://www.fueleconomy.gov&apos; + first_url()    # 添加代理,基本上的代理信息没什么变化    header_2 = {            &apos;Accept&apos;: &apos;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8&apos;,            &apos;Accept-Encoding&apos;: &apos;gzip, deflate, br&apos;,            &apos;Accept-Language&apos;: &apos;zh-CN,zh&apos;,            &apos;Cache-Control&apos;: &apos;max-age=0&apos;,            &apos;Connection&apos;: &apos;keep-alive&apos;,            &apos;Host&apos;: &apos;www.fueleconomy.gov&apos;,            &apos;Upgrade-Insecure-Requests&apos;: &apos;1&apos;,            &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.162 Safari/537.36}&apos;            }    request_2 = requests.get(url=se_url, headers=header_2)    request_2.encoding = &apos;utf-8&apos;    # 匹配正则表达式    link_2 = re.findall(r&apos;&lt;a href=&quot;(.*?)&quot;&gt;CSV&lt;/a&gt;&apos;, request_2.text)[0]    return link_2&apos;&apos;&apos;    已经得到了资源下载地址，在主函数中进行下载并且进行解压                                                    &apos;&apos;&apos;if __name__ == &apos;__main__&apos;:    # 获取下载文件的资源地址    down_url = &apos;https://www.fueleconomy.gov&apos; + second_url()    print(&apos;数据采集完成...&apos;)    print(&apos;开始下载文件...&apos;)    # 文件名称是：vehicles.csv.zip，格式也是非常的重要！    urlretrieve(url=down_url, filename=&apos;vehicles.csv.zip&apos;)    print(&apos;下载完成！可在本工程目录查收！&apos;)</code></pre><p>至此可在本目录下查看到下载好的压缩文件：</p><p><img src="" alt=""></p><blockquote><p>当然也可加上运用<em>python</em>解压这一部分的模块，有兴趣的朋友可自行学习运用。</p></blockquote><h2 id="代码可视化分析阶段"><a href="#代码可视化分析阶段" class="headerlink" title="代码可视化分析阶段"></a>代码可视化分析阶段</h2><p>在解压之后可先用<em>excel</em>打开来看看（会发现有<strong>39000+行</strong>数据），在此只需要知道其中的参数<code>year</code>与<code>com08</code>，前者为年份，后者为燃料的使用情况相关的数值。</p><p>可视化实现代码在下：</p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>这是一个平时做的小项目，适合新手入门。</p><blockquote><p>另外，以上代码中不懂的模块知识，我建议你利用好搜索引擎，查看相关的文档或者是找本书看看。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;分析的是美国一个网站统计的多年汽车使用燃料情况的数据，需要从网上下载，在此利用好&lt;em&gt;python爬虫&lt;/em&gt;大有裨益，可作为实战运行分析。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;此篇文章案例来源于：&lt;img src=&quot;&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;本书文章中用&lt;
      
    
    </summary>
    
      <category term="可视化 爬虫" scheme="https://liujunjie11.github.io/categories/%E5%8F%AF%E8%A7%86%E5%8C%96-%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="可视化 爬虫" scheme="https://liujunjie11.github.io/tags/%E5%8F%AF%E8%A7%86%E5%8C%96-%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
</feed>
