<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LXiHa`Notes</title>
  
  <subtitle>The House Belong to Love and Freedom.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://liujunjie11.github.io/"/>
  <updated>2018-08-16T11:18:25.080Z</updated>
  <id>https://liujunjie11.github.io/</id>
  
  <author>
    <name>刘俊</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>关于python函数式编程以及相关调用方法的简单思考</title>
    <link href="https://liujunjie11.github.io/2018/08/16/%E5%85%B3%E4%BA%8Epython%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E4%BB%A5%E5%8F%8A%E7%9B%B8%E5%85%B3%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95%E7%9A%84%E7%AE%80%E5%8D%95%E6%80%9D%E8%80%83/"/>
    <id>https://liujunjie11.github.io/2018/08/16/关于python函数式编程以及相关调用方法的简单思考/</id>
    <published>2018-08-16T11:16:27.000Z</published>
    <updated>2018-08-16T11:18:25.080Z</updated>
    
    <content type="html"><![CDATA[<p>最近在参加<em>kaggle</em>上的一个入门级的比赛，在参考他人的代码时学习到了应用一些东西，在这里说的<em>python函数式编程</em>实际上在看书时看到了好几遍了，但是在真正的应用时是有一股“意想不到的”欣喜感的，哈哈..</p><p>在此简单记录一下，以便以后参考用。</p><p>在所谓的<em>函数式编程</em>中，若是简单的直接调用出结果那真的是大材小用了..实际上只是我认知较浅..哈哈~</p><p>在使用这些<em>函数</em>时，我发现会有惊人的效果，而且可以达到理想的效果，就如在处理一些数据中结合本身的<em>变量</em>时真的有一股得心应手的感觉～～</p><blockquote><p>这里的变量一般为<em>DataFrame</em>的数据类型，也可称为一个特征向量，维度。</p></blockquote><p>再者，如是需要以自定义的函数结合变量达到理想的效果，不妨可以试试<code>appley</code>这个方法，大胆的调用起来！真的是挺好的一个工具，哈哈。</p><p>学到了不少实用的东西～</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在参加&lt;em&gt;kaggle&lt;/em&gt;上的一个入门级的比赛，在参考他人的代码时学习到了应用一些东西，在这里说的&lt;em&gt;python函数式编程&lt;/em&gt;实际上在看书时看到了好几遍了，但是在真正的应用时是有一股“意想不到的”欣喜感的，哈哈..&lt;/p&gt;
&lt;p&gt;在此简单记录一下，
      
    
    </summary>
    
      <category term="python编程" scheme="https://liujunjie11.github.io/categories/python%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="python编程" scheme="https://liujunjie11.github.io/tags/python%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>为Hexo博客(next主题)加上评论功能</title>
    <link href="https://liujunjie11.github.io/2018/08/15/%E4%B8%BAHexo%E5%8D%9A%E5%AE%A2-next%E4%B8%BB%E9%A2%98-%E5%8A%A0%E4%B8%8A%E8%AF%84%E8%AE%BA%E5%8A%9F%E8%83%BD/"/>
    <id>https://liujunjie11.github.io/2018/08/15/为Hexo博客-next主题-加上评论功能/</id>
    <published>2018-08-15T13:51:57.000Z</published>
    <updated>2018-08-16T04:31:37.419Z</updated>
    
    <content type="html"><![CDATA[<p>一直想加一个评论的功能，现在有时间了。</p><p>下面来说说简单的过程。</p><p>用的是<a href="https://livere.com" target="_blank" rel="external">来必力</a>这个评论系统。</p><p>首先需要进入其中进行注册。</p><blockquote><p>前面的注册过程具体参考下面这篇文章吧，但是后面的过程回来参考我的即可。</p><p>文章地址：<a href="https://segmentfault.com/a/1190000012918417" target="_blank" rel="external">https://segmentfault.com/a/1190000012918417</a></p></blockquote><p>如上面的文章可知，每个人注册成功之后会有一个独立的<code>uid</code>。</p><p>接下来打开目录位置目标<code>/Users/XX/XXXX/themes/next/_config.yml</code>，搜索关键词<code>liver</code>，将此位置改成</p><pre><code>livere:    on: true #控制开关    livere_uid: 你的uid</code></pre><p>如下图所示：</p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-15%20%E4%B8%8B%E5%8D%8810.02.45.png" alt=""></p><p><strong>接下来进行最重要的一步，打开目录位置目标<code>/Users/XX/XXXX/themes/next/layout/_partials/comments.swig</code></strong>，将其中的改成如下图所示：</p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-15%20%E4%B8%8B%E5%8D%889.35.56.png" alt=""></p><p>保存之后再有顺序的使用命令：</p><p><code>hexo s -debug</code> #调试并且展示</p><p><code>hexo g -d</code> #完成文件上传生成</p><p>另外可在自己的<em>来必力</em>设置界面设置成自己想要的样子：</p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-15%20%E4%B8%8B%E5%8D%8810.14.05.png" alt=""></p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-15%20%E4%B8%8B%E5%8D%8810.14.11.png" alt=""></p><p>之后打开自己的网站就可以看到效果如何啦：</p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-15%20%E4%B8%8B%E5%8D%8810.14.40.png" alt=""></p><h1 id="参考-amp-最后"><a href="#参考-amp-最后" class="headerlink" title="参考&amp;最后"></a>参考&amp;最后</h1><p>参考：<a href="https://www.jianshu.com/p/f5c184047e72" target="_blank" rel="external">https://www.jianshu.com/p/f5c184047e72</a></p><blockquote><p>实话说，加上评论功能之后网站加载时间多了那么几毫秒…总体来说还不错。另外我用的<em>Mac</em>，其他系统也无大碍，看目录位置即可。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一直想加一个评论的功能，现在有时间了。&lt;/p&gt;
&lt;p&gt;下面来说说简单的过程。&lt;/p&gt;
&lt;p&gt;用的是&lt;a href=&quot;https://livere.com&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;来必力&lt;/a&gt;这个评论系统。&lt;/p&gt;
&lt;p&gt;首先需要进入
      
    
    </summary>
    
      <category term="Hexo博客教程" scheme="https://liujunjie11.github.io/categories/Hexo%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="Hexo博客教程" scheme="https://liujunjie11.github.io/tags/Hexo%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>pandas.Dataframe.plot()及数值切片的一些记录</title>
    <link href="https://liujunjie11.github.io/2018/08/13/pandas-Dataframe-plot-%E5%8F%8A%E6%95%B0%E5%80%BC%E5%88%87%E7%89%87%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AE%B0%E5%BD%95/"/>
    <id>https://liujunjie11.github.io/2018/08/13/pandas-Dataframe-plot-及数值切片的一些记录/</id>
    <published>2018-08-13T05:04:02.000Z</published>
    <updated>2018-08-13T05:13:03.201Z</updated>
    
    <content type="html"><![CDATA[<p>在学习其相关的一些库时有一些自己的理解，简单记录记录，方便以后理解。</p><p><code>pandas.Dataframe.plot()</code>此函数而言：</p><blockquote><p><code>x轴线</code>对应着第一列值，<code>y轴线</code>对应着第二列值or后面的列，而其中的属性对应着将要标记在上方的标签展示使用。</p></blockquote><p>在切片的理解中：</p><blockquote><p><code>[:]</code>为全体；</p><p><code>[1:]</code> or <code>[1]</code>需要考虑从0开始的顺序；</p><p><code>[:1]</code>即直接从1开始，无需从0开始；</p><p><code>[:,:]</code>表示行与列。</p></blockquote><p>That’s all！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在学习其相关的一些库时有一些自己的理解，简单记录记录，方便以后理解。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;pandas.Dataframe.plot()&lt;/code&gt;此函数而言：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;x轴线&lt;/code&gt;对应着第一列值，&lt;code&gt;y轴
      
    
    </summary>
    
      <category term="python数据分析/挖掘" scheme="https://liujunjie11.github.io/categories/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-%E6%8C%96%E6%8E%98/"/>
    
    
      <category term="python数据分析/挖掘" scheme="https://liujunjie11.github.io/tags/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-%E6%8C%96%E6%8E%98/"/>
    
  </entry>
  
  <entry>
    <title>Mac下的matploylib绘图中文乱码问题</title>
    <link href="https://liujunjie11.github.io/2018/08/08/Mac%E4%B8%8B%E7%9A%84matploylib%E7%BB%98%E5%9B%BE%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/"/>
    <id>https://liujunjie11.github.io/2018/08/08/Mac下的matploylib绘图中文乱码问题/</id>
    <published>2018-08-08T05:55:24.000Z</published>
    <updated>2018-08-08T06:11:46.689Z</updated>
    
    <content type="html"><![CDATA[<p>最近在接触一些在notebook上用<em>matploylib</em>这个库绘图时出现了中文乱码的问题，就是常见的那种小方块式的中文乱码问题。</p><p>下面简单说说解决方法。</p><h2 id="Mac本机上的字体册利用"><a href="#Mac本机上的字体册利用" class="headerlink" title="Mac本机上的字体册利用"></a>Mac本机上的字体册利用</h2><p>在打开<em>Mac</em>自带的字体册，可发现有许多的中文字体供我们选择使用，在此就能帮忙我们解决中文乱码的问题。</p><p>选择一个字体，找到他的文件位置在何处。之后需要添加的代码要用到。</p><p><img src="http://owudg3xs2.bkt.clouddn.com/8%E6%9C%88-08-2018%2014-10-08.gif" alt=""></p><blockquote><p>这样就知道了位置的所在。</p></blockquote><h2 id="需要添加的代码"><a href="#需要添加的代码" class="headerlink" title="需要添加的代码"></a>需要添加的代码</h2><p>如下添加代码，加上上面说的中文字体的所在位置，<strong>然后在每一次需要中文显示时，均要加上<code>fontproperties=font</code>（font即指下方的变量）。</strong></p><pre><code>from matplotlib.font_manager import FontPropertiesfont = FontProperties(fname=&apos;/Library/Fonts/Songti.ttc&apos;)&gt; 如：plt.subplot2grid((2,3),(1,0),colspan=2) #在此即为多行的占用data_train.Age[data_train.Pclass == 1].plot(kind=&apos;kde&apos;) #两者的结合绘图data_train.Age[data_train.Pclass == 2].plot(kind=&apos;kde&apos;)data_train.Age[data_train.Pclass == 3].plot(kind=&apos;kde&apos;)plt.xlabel(&apos;年龄&apos;,fontproperties=font)plt.ylabel(&apos;密度&apos;,fontproperties=font)plt.title(&apos;各等级的乘客年龄分布&apos;,fontproperties=font)plt.legend((&apos;Pclass1&apos;,&apos;Pclass2&apos;,&apos;Pclass3&apos;),loc=&apos;best&apos;) #多个说明，自动排好说明位置</code></pre><p>这样中文乱码的问题就能得到完美的解决了…唉，网上的一些方案根本没有用啊，折腾了几个小时，心累..</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在接触一些在notebook上用&lt;em&gt;matploylib&lt;/em&gt;这个库绘图时出现了中文乱码的问题，就是常见的那种小方块式的中文乱码问题。&lt;/p&gt;
&lt;p&gt;下面简单说说解决方法。&lt;/p&gt;
&lt;h2 id=&quot;Mac本机上的字体册利用&quot;&gt;&lt;a href=&quot;#Mac本机上的字
      
    
    </summary>
    
      <category term="python matploylib" scheme="https://liujunjie11.github.io/categories/python-matploylib/"/>
    
    
      <category term="python matploylib" scheme="https://liujunjie11.github.io/tags/python-matploylib/"/>
    
  </entry>
  
  <entry>
    <title>python3爬虫与GUI:爬取腾讯视频</title>
    <link href="https://liujunjie11.github.io/2018/07/24/python3%E7%88%AC%E8%99%AB%E4%B8%8EGUI:%E7%88%AC%E5%8F%96%E8%85%BE%E8%AE%AF%E8%A7%86%E9%A2%91/"/>
    <id>https://liujunjie11.github.io/2018/07/24/python3爬虫与GUI:爬取腾讯视频/</id>
    <published>2018-07-24T11:21:27.000Z</published>
    <updated>2018-07-25T13:16:25.339Z</updated>
    
    <content type="html"><![CDATA[<p>最近想研究一下用<em>python爬虫</em>爬一些经常看的视频网站，其中包括有<em>腾讯视频、YouTube、Twitter</em>。本文从腾讯开始，之后会慢慢的更新其他两个的。</p><p>腾讯视频我之前就有过尝试，结果都失败了(我的目标是直接爬取完整视频！实际上这视频分析来分析去都是分段来的..)花了不少时间，结果还是停留在了只能爬取分段视频的阶段..下面也来简单说说如何爬取一些分段片段！</p><h1 id="爬取视频片段分析"><a href="#爬取视频片段分析" class="headerlink" title="爬取视频片段分析"></a>爬取视频片段分析</h1><p>在我们经过抓包的过程中可发现一些有用的信息，比如<code>getinfo</code>、<code>getkey</code>的数据包。下面简单分析一下，实际上只用到<code>getinfo</code>数据包的内容即可！</p><p>为了简便直接放出相关的链接：</p><blockquote><p><strong>getinfo:</strong><a href="http://vv.video.qq.com/getinfo?vids={}&amp;platform=101001&amp;charge=0&amp;otype=xml" target="_blank" rel="external">http://vv.video.qq.com/getinfo?vids={}&amp;platform=101001&amp;charge=0&amp;otype=xml</a></p><p><strong>getkey:</strong><a href="http://vv.video.qq.com/getkey?otype=json&amp;platform=11&amp;format={}&amp;vid={}&amp;filename={}&amp;appver=3.2.19.333" target="_blank" rel="external">http://vv.video.qq.com/getkey?otype=json&amp;platform=11&amp;format={}&amp;vid={}&amp;filename={}&amp;appver=3.2.19.333</a></p></blockquote><p><strong>再强调一下，实际上仅仅分析<code>getinfo</code>的相关的内容即可得出片段视频！</strong></p><p>随便以一个腾讯视频的<a href="https://v.qq.com/x/cover/fzfi0p4etjrckhh/a00260ipkjg.html" target="_blank" rel="external">链接</a>来进行以下图片的简单说明，针对以上的相关的参数：</p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-24%20%E4%B8%8B%E5%8D%887.36.23.png" alt=""></p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-24%20%E4%B8%8B%E5%8D%887.38.43.png" alt=""></p><blockquote><p>即：<br><a href="http://vv.video.qq.com/getinfo?vids=a00260ipkjg&amp;platform=101001&amp;charge=0&amp;otype=xml" target="_blank" rel="external">http://vv.video.qq.com/getinfo?vids=a00260ipkjg&amp;platform=101001&amp;charge=0&amp;otype=xml</a></p></blockquote><p>视频的真实地址仅仅需要<code>fn(filename)</code>、<code>fvkey(key)</code>、<code>URL(ui~url)</code>这些参数即可。以下图将一一进行标出！</p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-24%20%E4%B8%8B%E5%8D%887.40.07.png" alt=""></p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-24%20%E4%B8%8B%E5%8D%887.40.36.png" alt=""></p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-24%20%E4%B8%8B%E5%8D%887.42.42.png" alt=""></p><blockquote><p>之后将得出一片段的真实地址：<br><a href="http://218.8.55.13/vlive.qqvideo.tc.qq.com/AU8SqeoXTl1JLXdNhOFSXiMVi2va5Pws1sz4YXZ7sAxo/d002684wnon.m1.mp4?vkey=BCCD552375F7D76708838E84668FDE0E15051F1BE9FF349A31FE6CA14BDC8EAE35FEF2322A8FAEA590EB2FCB129B0C96595BB896DBB756581A9F307ADA7D259AD4371F820D6C25194FD296D3570997912221A33D6678597050700BA156442AB5CB137D70537A706F" target="_blank" rel="external">http://218.8.55.13/vlive.qqvideo.tc.qq.com/AU8SqeoXTl1JLXdNhOFSXiMVi2va5Pws1sz4YXZ7sAxo/d002684wnon.m1.mp4?vkey=BCCD552375F7D76708838E84668FDE0E15051F1BE9FF349A31FE6CA14BDC8EAE35FEF2322A8FAEA590EB2FCB129B0C96595BB896DBB756581A9F307ADA7D259AD4371F820D6C25194FD296D3570997912221A33D6678597050700BA156442AB5CB137D70537A706F</a></p></blockquote><p>只有几分钟..</p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-07-24%20%E4%B8%8B%E5%8D%887.46.32.png" alt=""></p><blockquote><p>如上..</p></blockquote><p>研究来研究去，花费了不少的时间了，再研究下去也感觉没有多大的收获了..加上感觉也难以进行下去了，所以我决定：<strong>先暂停研究，用已有的工具来满足一下～</strong>。当然也离不开用<em>python</em>来模拟爬取了，哈哈～</p><h1 id="分析模拟结合网站工具来下载完整视频"><a href="#分析模拟结合网站工具来下载完整视频" class="headerlink" title="分析模拟结合网站工具来下载完整视频"></a>分析模拟结合网站工具来下载完整视频</h1><p>经过我的研究，腾讯视频那都是一个一个片段的来进行“输出”的，所以一个一个进行爬取之后(利用网站工具)，再利用<em>python</em>的一些模块进行合并，即可获得视频的完整版。当然这些过程均将用<em>python</em>来进行模拟！</p><ul><li>使用的网站工具：<a href="http://www.weibodang.cn/dang.php" target="_blank" rel="external">http://www.weibodang.cn/dang.php</a></li></ul><p>打开此网站，输入刚刚的要下载的视频链接，点击<code>获取视频</code>之后会跳到另一个页面，会发现完整版的视频就是用几个片段分成的：</p><p><img src="http://owudg3xs2.bkt.clouddn.com/7%E6%9C%88-24-2018%2020-00-51.gif" alt=""></p><blockquote><p>腾讯这个老狗..</p></blockquote><p>如上我们已得知所有相关的片段的真实地址了，接下来将它们都下载下来后合并即可得到一个完整的视频了，网速快的话实际上跟直接下载一个完整版的视频没什么两样，可能还要快，哈哈～</p><p><strong>至此，就都已经分析完了，只剩下代码的事了。</strong></p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p><strong>先说一下，这样的代码我写过太多次了..有点腻了…写不下去了，感觉总是在做一些重复的事，我就不打算写太多了，大概说一下思路吧，将各个片段下载来之后，再利用一个<em>python</em>处理视频的模块库将择好几个片段一同进行连接即可完成了。但是，貌似今天我看到好像没有分片段了？好像直接可以爬到完整版了？难道是错觉？算了，反正我也不怎么下载腾讯视频..哈哈～</strong></p><p>核心代码，剩下的代码可参考我的其他博文，自己写吧，腻死了..这段代码已经达到能够爬取到所有分片段了..</p><pre><code>`&apos;&apos;&apos;Created on 2018年7月24日@author: junjieliu&apos;&apos;&apos;&quot;&quot;&quot;函数目标：结合pyQT5界面化爬取腾讯视频编写时间：2018-7.24&quot;&quot;&quot;import time import requestsimport sysimport re from PyQt5.QtCore import QCoreApplicationfrom PyQt5.QtWidgets import (QPushButton, QWidget, QLineEdit, QTextEdit, QGridLayout, QApplication, QComboBox)from selenium import webdriverfrom selenium.webdriver.common.by import Byfrom selenium.webdriver.support import expected_conditions as ECfrom selenium.webdriver.support.wait import WebDriverWaitfrom urllib.parse import quotefrom pyquery import PyQuery as pqbrowser = webdriver.Chrome(&apos;/Users/junjieliu/Documents/webdirver小插件/chromedriver&apos;)# 设置显示等待，超过时间返回失败，否则就地正法！wait = WebDriverWait(browser, 40)input_url = &apos;https://v.qq.com/x/cover/fzfi0p4etjrckhh/a00260ipkjg.html&apos;url = &apos;http://www.weibodang.cn/dang.php&apos;browser.get(url)input = wait.until(    EC.presence_of_element_located((By.CSS_SELECTOR, &apos;#aform &gt; div &gt; div &gt; div &gt; input&apos;)))button = wait.until(    EC.element_to_be_clickable((By.CSS_SELECTOR, &apos;#aform &gt; div &gt; div &gt; div &gt; span &gt; input&apos;)))# button = browser.find_element_by_name(&apos;check&apos;)input.clear()input.send_keys(input_url)button.click()html = browser.page_source# 直接爬取相关的内容，即播放地址，再进行一番清洗得到正确的地址referer = re.findall(r&apos;&lt;video src=&quot;(.*?)&quot;&apos;, html, re.S)for_name = re.match(r&apos;视频如下可直接播放，.*?：&quot;(.*?)&quot;&apos;, html, re.S)print(for_name)for each in referer:    results = each.replace(&apos;;&apos;, &apos;&amp;&apos;)     print(results)</code></pre><p>`</p><blockquote><p><strong>对了，GUI用的<em>pyQT5在我之前的博文也有介绍了，不说了..我承认我有点懶～</em></strong></p></blockquote><h1 id="参考-amp-最后"><a href="#参考-amp-最后" class="headerlink" title="参考&amp;最后"></a>参考&amp;最后</h1><p>一些在学习过程中用处较大的放上来了，比较懶..当然也感谢其他那些无私奉献的人们，我也从中学习到了不少的东西，谢谢～</p><p><em>1、</em><a href="https://blog.csdn.net/cplvfx/article/details/80080761" target="_blank" rel="external">https://blog.csdn.net/cplvfx/article/details/80080761</a></p><p>其中用到的一些模块不懂的还需自行去了解以及查找！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近想研究一下用&lt;em&gt;python爬虫&lt;/em&gt;爬一些经常看的视频网站，其中包括有&lt;em&gt;腾讯视频、YouTube、Twitter&lt;/em&gt;。本文从腾讯开始，之后会慢慢的更新其他两个的。&lt;/p&gt;
&lt;p&gt;腾讯视频我之前就有过尝试，结果都失败了(我的目标是直接爬取完整视频！实
      
    
    </summary>
    
      <category term="python3爬虫" scheme="https://liujunjie11.github.io/categories/python3%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="python3爬虫" scheme="https://liujunjie11.github.io/tags/python3%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>心声</title>
    <link href="https://liujunjie11.github.io/2018/07/18/%E5%BF%83%E5%A3%B0/"/>
    <id>https://liujunjie11.github.io/2018/07/18/心声/</id>
    <published>2018-07-18T13:35:08.000Z</published>
    <updated>2018-07-20T03:31:22.401Z</updated>
    
    <content type="html"><![CDATA[<p>我已沉默了许久了。</p><p>直到今日我看到了一个<a href="https://www.youtube.com/watch?v=1yY0U801tUs&amp;feature=youtu.be" target="_blank" rel="external">视频链接</a>，看到了下方的一个同胞说到“我一直在流泪，孩子。”。我的心顿时在流血一般的，泪水一度忍不住的留..</p><p>现在中国的年轻一代们，你们为何不去了解政治？你们有什么理由不去了解自己国家的政治？看到身边的行尸走肉们，我有时感到一股孤独感由然而生。幸好，我并不是一个人坚持着，在世界的各个角落都有我的同胞都有人在关心着这个国家与这里的人民生活的怎么样，想到这里，我总是有一股欣慰感。</p><p>我不是什么象牙塔里的花朵，我也不想为谁辩论什么。我只是想关心我的国家，在这里，我出生在这里，在出生之后我知道我是一个中国人，我的一个“大家”叫中国，这里有我的许许多多的兄弟姐妹，大家相依为命，情同手足…这曾经是在我的梦里时常出现的幻梦，如今依旧不变着。</p><p>这里的土地应当由这里的人民来当家作主，不是从什么地方过来的二流子政权来把这里搞得民不聊生，人人自危，看看吧，如今的这片土地上，什么荒谬的事情每天都在发生，一次又一次的冲击着无数人的底线。没有最荒谬的事在这里，只有更为荒谬的。虽然主体都是人，难道就与政治没有关系？政治关系着社会人民生活的方方面面，有什么理由不关心自己国家的政治？作为一个中国人。</p><p>如今的这个国家有着一部分的人利用着这个体制获取着从多数人民身上得来的不义之财，打着各种为这个国家为人民着想的口号，吃着人血馒头，过着丝毫没有悔改，为所欲为的生活。这些人只要有存在的一天，就是这个国家最大的心患，是不必要的，需清除的寄生虫！他们带坏了整个国家社会的风气，导致一些臭味相投的人跟着这歪风，一起欺压压榨着我们的人民，有点少人因为被逼的放弃自己的底线、良知与善良？只有大家一同关注起来，一同团结起来才能将这些人绳之于法，用我们自己的真正的“法”！</p><p>作为这个国家的一份子，在有些时候就不应该继续沉默着，勇敢的发出自己的声音，与更多的那些勇敢的人民一起前进！人们也不应太过于冷漠，这个国家社会终究是我们一个个组成，大家都心怀热情，保持善良的人格，理智的并且去热衷于帮助身边需要的每一个人！当身边越来越好一些了之后，整体才会慢慢的变好。</p><p>大家一起加油！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我已沉默了许久了。&lt;/p&gt;
&lt;p&gt;直到今日我看到了一个&lt;a href=&quot;https://www.youtube.com/watch?v=1yY0U801tUs&amp;amp;feature=youtu.be&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;视频链接
      
    
    </summary>
    
      <category term="成长" scheme="https://liujunjie11.github.io/categories/%E6%88%90%E9%95%BF/"/>
    
    
      <category term="成长" scheme="https://liujunjie11.github.io/tags/%E6%88%90%E9%95%BF/"/>
    
  </entry>
  
  <entry>
    <title>使用PS软件的记录</title>
    <link href="https://liujunjie11.github.io/2018/07/18/%E4%BD%BF%E7%94%A8PS%E8%BD%AF%E4%BB%B6%E7%9A%84%E8%AE%B0%E5%BD%95/"/>
    <id>https://liujunjie11.github.io/2018/07/18/使用PS软件的记录/</id>
    <published>2018-07-18T12:45:33.000Z</published>
    <updated>2018-07-18T12:56:33.215Z</updated>
    
    <content type="html"><![CDATA[<p>此文是关于<em>PS软件</em>的使用记录，因为使用的不多，但是是经常需要用到的一些小技巧，记录在此，以便日后查看。不定时更新。</p><h1 id="图片合并"><a href="#图片合并" class="headerlink" title="图片合并"></a>图片合并</h1><p><em>1，</em>在软件中新建一个默认的空白层，将需要合并的图片一并拖入其中，排版调整好，保存退出，即可完成合并任务。</p><h1 id="去水印"><a href="#去水印" class="headerlink" title="去水印"></a>去水印</h1><blockquote><p><strong>大小水印均可去除使用。</strong></p></blockquote><p><em>1，</em><a href="https://jingyan.baidu.com/article/4ae03de3e41dd33eff9e6bb9.html" target="_blank" rel="external">https://jingyan.baidu.com/article/4ae03de3e41dd33eff9e6bb9.html</a></p><blockquote><p>看其中教程视频的第一个方法即可完成任务。</p></blockquote><p><em>2，</em><a href="https://jingyan.baidu.com/article/a24b33cd2361e819fe002bed.html" target="_blank" rel="external">https://jingyan.baidu.com/article/a24b33cd2361e819fe002bed.html</a></p><blockquote><p>不稳定方法。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;此文是关于&lt;em&gt;PS软件&lt;/em&gt;的使用记录，因为使用的不多，但是是经常需要用到的一些小技巧，记录在此，以便日后查看。不定时更新。&lt;/p&gt;
&lt;h1 id=&quot;图片合并&quot;&gt;&lt;a href=&quot;#图片合并&quot; class=&quot;headerlink&quot; title=&quot;图片合并&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
      <category term="软件使用" scheme="https://liujunjie11.github.io/categories/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/"/>
    
    
      <category term="软件使用" scheme="https://liujunjie11.github.io/tags/%E8%BD%AF%E4%BB%B6%E4%BD%BF%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>反思记录</title>
    <link href="https://liujunjie11.github.io/2018/06/29/%E5%8F%8D%E6%80%9D%E8%AE%B0%E5%BD%95/"/>
    <id>https://liujunjie11.github.io/2018/06/29/反思记录/</id>
    <published>2018-06-29T06:45:18.000Z</published>
    <updated>2018-06-29T07:01:01.044Z</updated>
    
    <content type="html"><![CDATA[<p>不知不觉又已经到了期末了，现在的我在花时间应付考试。</p><p>这个学期我学了一些什么，我细细的回想一看，发现真的是太少了，最大的收获即是学习了一些<em>python爬虫</em>，但是不得不说也其实就是一半吊子罢了。所以这一切的一切真的需要我去好好的反思一下了，当中有太多的<em>三分钟热度</em>了，我的懒惰也是一大通病。我花了不少的时间去学习，到现在来看，不过也就是昙花一现，真的是太少了，学的太少了，我的学习状态出现了问题，这一点倒是无可争议的。我如今真的发现了，我的问题就是太过于“顺其自然”了，我曾经的规划计划都被我放在脑后，这真的是错误到家了…真的是让我付出了沉重的代价–太多有限的时间！</p><p><strong>更为重要的是我的自律习惯也没有曾经的那一番更加坚决了，这都是我变得懒惰的真实写照，我开始变得安于现状了，这恰恰是致命的毛病，如果不改变，我想我真的会付出更多的代价！</strong></p><p><strong>是的，我一度要求自己追求“自由”的方式去对待每一件事，但是如今的我好像真的是过度了，过度的安抚自己要“顺其自然”了…</strong></p><p>我强调并且追寻“自由”，但现在的我好像不具备太多这样的选择，我想我需要做出改变。不能太安逸去选择，更不能太安逸的去做事。</p><p>我的问题就是：<strong>太过于放纵自己了，以致于真的浪费了不少的时间！</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;不知不觉又已经到了期末了，现在的我在花时间应付考试。&lt;/p&gt;
&lt;p&gt;这个学期我学了一些什么，我细细的回想一看，发现真的是太少了，最大的收获即是学习了一些&lt;em&gt;python爬虫&lt;/em&gt;，但是不得不说也其实就是一半吊子罢了。所以这一切的一切真的需要我去好好的反思一下了，当中
      
    
    </summary>
    
      <category term="成长" scheme="https://liujunjie11.github.io/categories/%E6%88%90%E9%95%BF/"/>
    
    
      <category term="成长" scheme="https://liujunjie11.github.io/tags/%E6%88%90%E9%95%BF/"/>
    
  </entry>
  
  <entry>
    <title>Excel使用记录</title>
    <link href="https://liujunjie11.github.io/2018/06/27/Excel%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/"/>
    <id>https://liujunjie11.github.io/2018/06/27/Excel使用记录/</id>
    <published>2018-06-27T13:16:51.000Z</published>
    <updated>2018-06-27T13:24:42.656Z</updated>
    
    <content type="html"><![CDATA[<p>以下是我在学习<em>Excel</em>这个软件时的学习记录，以便以后方便查找，随便也希望可以帮助需要的人。不定时更新。</p><blockquote><p>所有的学习来源均来自网络。</p></blockquote><h1 id="excel整列求和的两种方法"><a href="#excel整列求和的两种方法" class="headerlink" title="excel整列求和的两种方法"></a>excel整列求和的两种方法</h1><blockquote><p><a href="http://www.ittribalwo.com/article/1324.html" target="_blank" rel="external">http://www.ittribalwo.com/article/1324.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;以下是我在学习&lt;em&gt;Excel&lt;/em&gt;这个软件时的学习记录，以便以后方便查找，随便也希望可以帮助需要的人。不定时更新。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;所有的学习来源均来自网络。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;excel整列求和的两种方法&quot;
      
    
    </summary>
    
      <category term="Excel" scheme="https://liujunjie11.github.io/categories/Excel/"/>
    
    
      <category term="Excel" scheme="https://liujunjie11.github.io/tags/Excel/"/>
    
  </entry>
  
  <entry>
    <title>结合Chrome插件快速下载百度云文件</title>
    <link href="https://liujunjie11.github.io/2018/06/25/%E7%BB%93%E5%90%88Chrome%E6%8F%92%E4%BB%B6%E5%BF%AB%E9%80%9F%E4%B8%8B%E8%BD%BD%E7%99%BE%E5%BA%A6%E4%BA%91%E6%96%87%E4%BB%B6/"/>
    <id>https://liujunjie11.github.io/2018/06/25/结合Chrome插件快速下载百度云文件/</id>
    <published>2018-06-25T06:47:46.000Z</published>
    <updated>2018-06-25T07:10:00.844Z</updated>
    
    <content type="html"><![CDATA[<p>最近下载一个文件，需要用到百度云网盘，不耐烦啊，它不耐烦我肯定很烦了…</p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-06-25%20%E4%B8%8B%E5%8D%882.49.37.png" alt=""></p><blockquote><p>唉，坑爹的百度！</p></blockquote><p>不废话了，以下是结合<em>Chrome</em>下载的教程。</p><p><strong>具体的前面步骤看这个(懒得写重复的文字了..)：<a href="https://blog.csdn.net/fkq_2016/article/details/78759244" target="_blank" rel="external">https://blog.csdn.net/fkq_2016/article/details/78759244</a></strong></p><p>需要补充的是，其实下载这个修改版的也不错，我用的就是这个修改版的。</p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-06-25%20%E4%B8%8B%E5%8D%883.00.25.png" alt=""></p><p>在获取到了真实的地址之后我又结合经过破解之后的迅雷，哈哈哈，速度还是可以的！</p><p>关于如何复制完全真实地址，可在<em>Chrome商店</em>中下载<em>Chrome下载管理器</em>，就像下面操作图一样！</p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-06-25%20%E4%B8%8B%E5%8D%883.05.18.png" alt=""></p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-06-25%20%E4%B8%8B%E5%8D%883.05.36.png" alt=""></p><blockquote><p>不过重中之重的问题在于，你要先能学会翻墙…</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近下载一个文件，需要用到百度云网盘，不耐烦啊，它不耐烦我肯定很烦了…&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-06-25%2
      
    
    </summary>
    
      <category term="教程" scheme="https://liujunjie11.github.io/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="教程" scheme="https://liujunjie11.github.io/tags/%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>在Jupyter Notebook中安装多种语言内核</title>
    <link href="https://liujunjie11.github.io/2018/06/04/%E5%9C%A8Jupyter-Notebook%E4%B8%AD%E5%AE%89%E8%A3%85%E5%A4%9A%E7%A7%8D%E8%AF%AD%E8%A8%80%E5%86%85%E6%A0%B8/"/>
    <id>https://liujunjie11.github.io/2018/06/04/在Jupyter-Notebook中安装多种语言内核/</id>
    <published>2018-06-04T12:33:26.000Z</published>
    <updated>2018-06-23T12:25:08.209Z</updated>
    
    <content type="html"><![CDATA[<p><em>Jupyter Notrbook</em>有一个好的编译界面，输出内容也一目了然，让人感觉像是发现了一个新大陆..</p><p>下面来说说如何在其中安装多种语言内核。</p><blockquote><p>支持的语言内核可查：<a href="https://github.com/jupyter/jupyter/wiki/Jupyter-kernels" target="_blank" rel="external">https://github.com/jupyter/jupyter/wiki/Jupyter-kernels</a></p></blockquote><h1 id="安装python2内核"><a href="#安装python2内核" class="headerlink" title="安装python2内核"></a>安装<em>python2</em>内核</h1><p>因为我的默认已经安装了<em>python3</em>，所以就在此讲解一下如何安装<em>python2</em>内核。</p><ul><li>在<em>notebook</em>为开启情况下，依次输入命令：</li></ul><p><code>pip install ipykernel</code></p><p><code>python2 -m ipykernel install</code></p><blockquote><p>参考：<a href="https://www.jianshu.com/p/8b90c2f12856" target="_blank" rel="external">https://www.jianshu.com/p/8b90c2f12856</a></p></blockquote><h1 id="安装R内核"><a href="#安装R内核" class="headerlink" title="安装R内核"></a>安装<em>R</em>内核</h1><p>上面的文章也有相关的介绍了。</p><p>但是在<em>anaconda</em>中一行命令即可完成下载：</p><p><code>conda install r-essential</code></p><p>或者是</p><p><code>conda  install -c r r-essentials</code></p><blockquote><p>参考：<a href="https://kangliping.wordpress.com/2017/09/15/anaconda_r/" target="_blank" rel="external">https://kangliping.wordpress.com/2017/09/15/anaconda_r/</a></p></blockquote><p><strong>下载第一次可能有几个包不成功，我经过重新输入命令行之后再次下载得到了解决。</strong></p><h1 id="安装bash内核"><a href="#安装bash内核" class="headerlink" title="安装bash内核"></a>安装<em>bash</em>内核</h1><p>新开一个终端，依次使用命令行：</p><p><code>pip install bash_kernel</code></p><p><code>python -m bash_kernel.install</code></p><blockquote><p>参考：<a href="https://blog.csdn.net/SA14023053/article/details/52053649" target="_blank" rel="external">https://blog.csdn.net/SA14023053/article/details/52053649</a></p></blockquote><h1 id="安装基于Scala的spark应用"><a href="#安装基于Scala的spark应用" class="headerlink" title="安装基于Scala的spark应用"></a>安装基于<em>Scala</em>的<em>spark</em>应用</h1><blockquote><p>具体移步：<a href="https://blog.csdn.net/Xmo_jiao/article/details/72674687" target="_blank" rel="external">https://blog.csdn.net/Xmo_jiao/article/details/72674687</a></p></blockquote><p>其中需要的内容在<em>spark</em>启动页面中都能找到。没办法，内容太多，又懒得写..</p><p><strong>但是需要注意的每次均要启动spark再进行进一步的编程操作。在已经安装<em>spark</em>的前提下输入命令行：<code>spark-shell</code>启动spark。</strong></p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>输入以下命令行查看已安装的内核列表：</p><p><code>jupyter kernelspec list</code></p><p>先写这么多，以后有需要再进行补充。</p><p><strong>关于在下载完之后发现启动内核失败(dead kernel的情况)</strong></p><p>可参考以下链接：</p><ol><li><p><a href="https://blog.csdn.net/liangdagongjue/article/details/79533538" target="_blank" rel="external">https://blog.csdn.net/liangdagongjue/article/details/79533538</a></p></li><li><p><a href="https://blog.csdn.net/wobeatit/article/details/78885339" target="_blank" rel="external">https://blog.csdn.net/wobeatit/article/details/78885339</a></p></li></ol><blockquote><p>即实际上就是我将<em>Anaconda</em>升级之后出现了以上的<code>dead kernel</code>的情况，后来发现真的是软件更新没有跟上的问题，将<em>notebook</em>之类的一并更新一遍即可解决。</p></blockquote><p>实际使用命令行如下：</p><p><code>conda upgrade notebook</code></p><p><code>conda upgrade jupyter</code></p><p><code>conda update mkl</code></p><p>一并更新之后重新打开会发现一切都可以正常使用了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;Jupyter Notrbook&lt;/em&gt;有一个好的编译界面，输出内容也一目了然，让人感觉像是发现了一个新大陆..&lt;/p&gt;
&lt;p&gt;下面来说说如何在其中安装多种语言内核。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;支持的语言内核可查：&lt;a href=&quot;https://g
      
    
    </summary>
    
      <category term="Notebook" scheme="https://liujunjie11.github.io/categories/Notebook/"/>
    
    
      <category term="Notebook" scheme="https://liujunjie11.github.io/tags/Notebook/"/>
    
  </entry>
  
  <entry>
    <title>Mac下载2018CAD破解</title>
    <link href="https://liujunjie11.github.io/2018/05/29/Mac%E4%B8%8B%E8%BD%BD2018CAD%E7%A0%B4%E8%A7%A3/"/>
    <id>https://liujunjie11.github.io/2018/05/29/Mac下载2018CAD破解/</id>
    <published>2018-05-29T11:25:20.000Z</published>
    <updated>2018-05-29T11:30:49.404Z</updated>
    
    <content type="html"><![CDATA[<p>最近因为选修课要用到<em>CAD</em>，用的恰好是<em>Mac book</em>，就在此记录</p><h1 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h1><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>先去官网下载好2018的试用版：<a href="https://www.autodesk.com.cn/products/autocad/free-trial#0" target="_blank" rel="external">https://www.autodesk.com.cn/products/autocad/free-trial#0</a></p><blockquote><p><strong>需要注意的是：选择企业注册就好，不然很麻烦…</strong></p></blockquote><h1 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h1><h2 id="参考以下文章即可"><a href="#参考以下文章即可" class="headerlink" title="参考以下文章即可.."></a>参考以下文章即可..</h2><ul><li>参考：<a href="http://www.anyxz.com/index.php/2902.html" target="_blank" rel="external">http://www.anyxz.com/index.php/2902.html</a></li></ul><blockquote><p>因为我只是完成作业就卸载了..所以一个试用版就足够..</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近因为选修课要用到&lt;em&gt;CAD&lt;/em&gt;，用的恰好是&lt;em&gt;Mac book&lt;/em&gt;，就在此记录&lt;/p&gt;
&lt;h1 id=&quot;第一步&quot;&gt;&lt;a href=&quot;#第一步&quot; class=&quot;headerlink&quot; title=&quot;第一步&quot;&gt;&lt;/a&gt;第一步&lt;/h1&gt;&lt;h2 id=&quot;下载
      
    
    </summary>
    
      <category term="Mac软件教程" scheme="https://liujunjie11.github.io/categories/Mac%E8%BD%AF%E4%BB%B6%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="Mac软件教程" scheme="https://liujunjie11.github.io/tags/Mac%E8%BD%AF%E4%BB%B6%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>理解常用传统算法的合集资源总结</title>
    <link href="https://liujunjie11.github.io/2018/05/10/%E7%90%86%E8%A7%A3%E5%B8%B8%E7%94%A8%E4%BC%A0%E7%BB%9F%E7%AE%97%E6%B3%95%E7%9A%84%E5%90%88%E9%9B%86%E8%B5%84%E6%BA%90%E6%80%BB%E7%BB%93/"/>
    <id>https://liujunjie11.github.io/2018/05/10/理解常用传统算法的合集资源总结/</id>
    <published>2018-05-10T13:13:35.000Z</published>
    <updated>2018-05-14T09:22:26.636Z</updated>
    
    <content type="html"><![CDATA[<p>平时学习算法是为了理解其中的原理以及思想，另外还有各种算法之间的比较以及应用场景。下面是一些常用常见的传统算法，我在<em>YouTube</em>上找了一些可简单理解其原理思想的视频，真正的做到通俗易懂！</p><p>另外关于算法的各种时间复杂度以及空间复杂度均在此小列出来。关于以下各种算法的应用场景实际上还是需要自己去结合这些算法的思想去选择的，就不在此多说了。</p><blockquote><p>参考了许多的网页，包括<em>YouTube</em>，<em>维基百科</em>等灯，也从中学习到了许多，就是在此汇总一下。<strong>另外参考的网页就不一一列出来了，感谢他们/她们的付出与分享。</strong></p></blockquote><p><strong>主要参考：</strong></p><ul><li><p><a href="http://wiki.jikexueyuan.com/project/data-structure-sorting/insertion-sort.html" target="_blank" rel="external">http://wiki.jikexueyuan.com/project/data-structure-sorting/insertion-sort.html</a></p></li><li><p><a href="https://github.com/francistao/LearningNotes/blob/master/Part3/Algorithm/Sort/面试中的%2010%20大排序算法总结.md" target="_blank" rel="external">https://github.com/francistao/LearningNotes/blob/master/Part3/Algorithm/Sort/面试中的%2010%20大排序算法总结.md</a></p></li><li><p>常用排序算法总结(一):<a href="http://www.cnblogs.com/eniac12/p/5329396.html" target="_blank" rel="external">http://www.cnblogs.com/eniac12/p/5329396.html</a></p></li><li><p>常用排序算法总结(二):<a href="http://www.cnblogs.com/eniac12/p/5332117.html" target="_blank" rel="external">http://www.cnblogs.com/eniac12/p/5332117.html</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;平时学习算法是为了理解其中的原理以及思想，另外还有各种算法之间的比较以及应用场景。下面是一些常用常见的传统算法，我在&lt;em&gt;YouTube&lt;/em&gt;上找了一些可简单理解其原理思想的视频，真正的做到通俗易懂！&lt;/p&gt;
&lt;p&gt;另外关于算法的各种时间复杂度以及空间复杂度均在此小列
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://liujunjie11.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="https://liujunjie11.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>python3爬虫与GUI:基于有道词典的词典小工具</title>
    <link href="https://liujunjie11.github.io/2018/05/07/python3%E7%88%AC%E8%99%AB%E4%B8%8EGUI-%E5%9F%BA%E4%BA%8E%E6%9C%89%E9%81%93%E8%AF%8D%E5%85%B8%E7%9A%84%E8%AF%8D%E5%85%B8%E5%B0%8F%E5%B7%A5%E5%85%B7/"/>
    <id>https://liujunjie11.github.io/2018/05/07/python3爬虫与GUI-基于有道词典的词典小工具/</id>
    <published>2018-05-07T10:48:58.000Z</published>
    <updated>2018-07-15T06:18:02.349Z</updated>
    
    <content type="html"><![CDATA[<p>最近看到了一篇文章，一个基于<em>有道</em>的词典小工具，心血来潮，想着自己来写一个试试看。</p><blockquote><p>下面我将用<em>python</em>完成接口的对接(即进行抓包)，并且用<em>pyQT5</em>实现对应的GUI界面。接下来就是事件机制的编写了，这样任务就完成了。</p></blockquote><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>在分析的过程中需要分析网页中的<em>JS</em>代码，因为有道现在使用加密算法来进行翻译结果的加密了。下面一一进行简单的说明。</p><p>首先用<em>Chrome浏览器</em>打开<a href="http://fanyi.youdao.com/" target="_blank" rel="external">有道在线翻译页面</a>，随便输入一个中文，会自动检测翻译成英文。(在我们已经都知道有道现在是加密的情况下我就不废话太多了，下面直接挑重点的说。)打开其自带的开发者工具查看到相关的包信息：</p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-05-08%20%E4%B8%8B%E5%8D%884.17.22.png" alt=""></p><blockquote><p>如果多翻译试几次翻译会发现上图所指的两个参数是持续变化的，还有一个<code>i</code>是输入的词，这个是在正常不过的，没什么疑义。</p></blockquote><h2 id="找到相应的JS整体代码"><a href="#找到相应的JS整体代码" class="headerlink" title="找到相应的JS整体代码"></a>找到相应的JS整体代码</h2><p>为了知道加密算法的过程以及整个流程是怎么一回事，找到网页的整体<em>JS</em>代码是唯一的选择。</p><p>先借助<em>火狐浏览器</em>分析翻译的接口，可快速的发现<em>JS</em>代码的所在处：</p><p><img src="http://owudg3xs2.bkt.clouddn.com/5%E6%9C%88-08-2018%2016-32-38.gif" alt=""></p><p>知道了<em>JS</em>文件的所在处，我们可在<em>Chrome浏览器</em>下找到这个地址：</p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-05-08%20%E4%B8%8B%E5%8D%884.20.45.png" alt=""></p><p>新建标签页打开：</p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-05-08%20%E4%B8%8B%E5%8D%884.21.11.png" alt=""></p><blockquote><p>发现这是一个混淆的<em>JS</em>代码，需要进行格式化才可知道其庐山真面目！<br>推荐两个反混淆的网站：<br><a href="http://tool.oschina.net/codeformat/js" target="_blank" rel="external">http://tool.oschina.net/codeformat/js</a> ，<a href="http://www.bm8.com.cn/jsConfusion/" target="_blank" rel="external">http://www.bm8.com.cn/jsConfusion/</a></p></blockquote><p>将混淆的代码复制粘贴在以上任意的一个网站，选择点击格式化之后即可得最终正解代码，之后为了查找关键词，我将这些代码编入一个文件中(<em>Mac</em>直接用文本编辑创建新文件即可。)：</p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-05-08%20%E4%B8%8B%E5%8D%884.22.49.png" alt=""></p><blockquote><p>格式化之后的JS代码一览。</p></blockquote><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-05-08%20%E4%B8%8B%E5%8D%884.23.13.png" alt=""></p><blockquote><p>之后查找关键词<code>salt</code>，找到对应上方的所指的参数位置。其中的乱码不用管，对分析代码没什么影响。</p></blockquote><h2 id="分析内容过程"><a href="#分析内容过程" class="headerlink" title="分析内容过程"></a>分析内容过程</h2><p>分析了一下之后，在<em>Chrome浏览器</em>中运行一下相关的代码，然后进入<a href="http://tool.chinaz.com/Tools/unixtime.aspx" target="_blank" rel="external">关于时间戳转换的网站</a>进行简单的转换，会发现这是一个有关时间戳的随机生成的一串数字：</p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-05-08%20%E4%B8%8B%E5%8D%884.23.13.png" alt=""></p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-05-08%20%E4%B8%8B%E5%8D%884.23.42.png" alt=""></p><blockquote><p>结合上下文(即<code>salt</code>关键词的上下一点范围即可)，发现有<em>md5</em>算法的字样出现了。</p></blockquote><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-05-08%20%E4%B8%8B%E5%8D%884.27.05.png" alt=""></p><blockquote><p>代码中关键的相关的内容。之后我们会用<em>python</em>来模拟这些代码来进行相关参数的输出。</p></blockquote><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-05-08%20%E4%B8%8B%E5%8D%884.29.07.png" alt=""></p><blockquote><p>用<em>Chrome</em>试着运行一下。</p></blockquote><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-05-08%20%E4%B8%8B%E5%8D%884.30.43.png" alt=""></p><blockquote><p>将运行之后的数字填入转换得出结果。</p></blockquote><p>在得知了两个随着翻译变化的关键词之一<code>salt</code>的生成原理之后，再来看看最后一个突破点，即找到关键词<code>sign</code>的生成原理，在这之后利用<em>python</em>模仿运行生成再代人相关的参数即可完成需要的翻译结果的输出。</p><p>其实往上看一点点就能发现诀窍了：</p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-05-08%20%E4%B8%8B%E5%8D%884.23.42.png" alt=""></p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-05-08%20%E4%B8%8B%E5%8D%884.31.13.png" alt=""></p><blockquote><p>结合<em>md5算法</em>以及必要的几个参数即可得出<code>sign</code>的生成值。</p></blockquote><p>这样一来思路就都清晰明了了，仅仅需要代码的实现了。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>以下代码已经套上了结合<em>pyQt5</em>开发出来了GUI的整体代码。</p><blockquote><p>关于<em>pyQt5</em>不清楚可参考我之前的相关博文，或者是利用好搜索引擎。</p></blockquote><pre><code>&quot;&quot;&quot;函数目标：基于有道的GUI搜索小工具编写时间：2018-5-08&quot;&quot;&quot;import time import requestsimport hashlibimport randomimport jsonimport sysfrom PyQt5.QtCore import QCoreApplicationfrom PyQt5.QtWidgets import (QPushButton, QWidget, QLabel, QLineEdit, QTextEdit, QGridLayout, QApplication,    QComboBox)class Example(QWidget):    def __init__(self):        super().__init__()        self.initUI()    def save_translateResult(self, word):        &quot;&quot;&quot;        本函数用于翻译结果的返回。        &quot;&quot;&quot;        r = str(int(time.time() * 1000 + random.randint(1, 10)))  # 模仿JS代码的仿写        S = &apos;fanyideskweb&apos;        n = word        D = &quot;ebSeFb%=XZ%T[KZ)c(sy!&quot;  # 在完整的JS代码中可找到        o = hashlib.md5((S + n + str(r) + D).encode(&apos;utf-8&apos;)).hexdigest()        data = {            &apos;i&apos;: word,            &apos;from&apos;: &apos;AUTO&apos;,            &apos;to&apos;: &apos;AUTO&apos;,            &apos;smartresult&apos;: &apos;dict&apos;,            &apos;client&apos;: S,            &apos;salt&apos;: r,            &apos;sign&apos;: o,            &apos;doctype&apos;: &apos;json&apos;,            &apos;version&apos;: &apos;2.1&apos;,            &apos;keyfrom&apos;: &apos;fanyi.web&apos;,            &apos;action&apos;: &apos;FY_BY_REALTIME&apos;,            &apos;typoResult&apos;: &apos;false&apos;        }        url = &apos;http://fanyi.youdao.com/translate_o?smartresult=dict&amp;smartresult=rule&apos;        # 在代理中需要加入cookies信息，否则会出现代码错误信息的返回        header = {            &apos;Cookie&apos;: XXXXXXXXXXXXXXXXXXXntes_nnid=25aff2b1480f17471ca1585f6f2f4293,15120241366&apos;,            &apos;Referer&apos;: &apos;http://fanyi.youdao.com/&apos;,            &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.139 Safari/537.36&apos;        }        response = requests.post(url=url, headers=header, data=data)        response.encoding = &apos;utf-8&apos;        translateResult = json.loads(response.text)[&quot;translateResult&quot;][0][0][&apos;tgt&apos;]        return translateResult    def take_test(self, word):        &quot;&quot;&quot;        本函数用于输出测试。        &quot;&quot;&quot;        try:            return self.save_translateResult(word)        except AttributeError:            return &quot;输入点有误/输出出现问题！！&quot;    def initUI(self):        # 组件添加        combo = QComboBox(self)        combo.addItem(&apos;有道词典&apos;)        label = QLabel(&quot;请输入:&quot;)        line = QLineEdit()        button_1 = QPushButton(&apos;开始翻译&apos;, self)        button_2 = QPushButton(&apos;退出&apos;, self)        button_3 = QPushButton(&apos;清空&apos;, self)        result = QTextEdit()        # 布局设置        grip = QGridLayout()        grip.setSpacing(4)        grip.addWidget(label, 1, 0)        grip.addWidget(line, 2, 0)        grip.addWidget(button_3, 2, 1)        grip.addWidget(button_1, 3, 0)        grip.addWidget(button_2, 3, 1)        grip.addWidget(result, 4, 0)        self.setLayout(grip)        combo.move(500, 0)        # 基于Macbook设置基本的快捷键以及推出程序的信号槽        button_1.setShortcut(&apos;return&apos;)        button_2.setShortcut(&apos;command+q&apos;)        button_2.clicked.connect(QCoreApplication.instance().quit)        button_3.setShortcut(&apos;esc&apos;)        def translate():            &quot;&quot;&quot;            本函数用于返回翻译按钮之后的结果输出！            &quot;&quot;&quot;            result.setText(self.take_test(line.text()))        button_1.clicked.connect(translate)        def clear():            &quot;&quot;&quot;            本函数用于输入输出框的清空！            &quot;&quot;&quot;            line.setText(&quot;&quot;)            result.setText(&quot;&quot;)        button_3.clicked.connect(clear)        # 设置窗口大小        self.setGeometry(500, 150, 600, 500)        self.setWindowTitle(&quot;有道翻译小工具&quot;)        self.show()if __name__ == &quot;__main__&quot;:    app = QApplication(sys.argv)    ex = Example()    sys.exit(app.exec_())</code></pre><blockquote><p><strong>上面的<em>cookies</em>值是必须要的！否则会出现错误，当然，在上面的代码我的<em>cookies</em>数值我进行了隐藏更改，如果需要测试运行，可加上自己浏览器上有道在线翻译的<em>cookies</em>。</strong></p></blockquote><p>运行演示：</p><p><img src="http://owudg3xs2.bkt.clouddn.com/5%E6%9C%88-08-2018%2016-32-56.gif" alt=""></p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><ul><li>代码中的模块可参考：</li></ul><p><em>1.</em> JavaScript parseInt() 函数：<a href="http://www.w3school.com.cn/js/jsref_parseInt.asp" target="_blank" rel="external">http://www.w3school.com.cn/js/jsref_parseInt.asp</a></p><p><em>2.</em> time.time()：返回当前时间的时间戳。：<a href="http://qinxuye.me/article/details-about-time-module-in-python/" target="_blank" rel="external">http://qinxuye.me/article/details-about-time-module-in-python/</a></p><p><em>3.</em> random.randint：<a href="https://www.cnblogs.com/yd1227/archive/2011/03/18/1988015.html" target="_blank" rel="external">https://www.cnblogs.com/yd1227/archive/2011/03/18/1988015.html</a></p><p><em>4.</em> hashlib:<a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014319556588648dd1fb0047a34d0c945ee33e8f4c90cc000" target="_blank" rel="external">https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014319556588648dd1fb0047a34d0c945ee33e8f4c90cc000</a></p><blockquote><p>其他的自行查找。特别是<em>pyQt5</em>这个库，可查看我之前写的文章作为参考：<a href="https://liujunjie11.github.io/2018/04/28/python3爬虫与GUI：一个简易的搜索实用小工具/#more">https://liujunjie11.github.io/2018/04/28/python3爬虫与GUI：一个简易的搜索实用小工具/#more</a></p></blockquote><ul><li>参考：</li></ul><p><em>1.</em>  <a href="http://study.163.com/course/courseLearn.htm?courseId=1004108008#/learn/video?lessonId=1047998193&amp;courseId=1004108008" target="_blank" rel="external">http://study.163.com/course/courseLearn.htm?courseId=1004108008#/learn/video?lessonId=1047998193&amp;courseId=1004108008</a></p><p><em>2.</em>  <a href="https://cuiqingcai.com/5024.html" target="_blank" rel="external">https://cuiqingcai.com/5024.html</a></p><p><em>3.</em>  <a href="https://blog.csdn.net/karmacode/article/details/79145728" target="_blank" rel="external">https://blog.csdn.net/karmacode/article/details/79145728</a></p><p><em>4.</em>  <a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014319556588648dd1fb0047a34d0c945ee33e8f4c90cc000" target="_blank" rel="external">https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014319556588648dd1fb0047a34d0c945ee33e8f4c90cc000</a></p><p><em>5.</em>  <a href="http://qinxuye.me/article/details-about-time-module-in-python/" target="_blank" rel="external">http://qinxuye.me/article/details-about-time-module-in-python/</a></p><p><em>6.</em>  <a href="https://www.cnblogs.com/yd1227/archive/2011/03/18/1988015.html" target="_blank" rel="external">https://www.cnblogs.com/yd1227/archive/2011/03/18/1988015.html</a></p><p>关于<em>python</em>的加密算法以及加密原理：</p><p><em>1.</em>  <a href="https://www.oudahe.com/p/python/z545/" target="_blank" rel="external">https://www.oudahe.com/p/python/z545/</a></p><p><em>2.</em>  <a href="https://www.oudahe.com/p/python/z545/" target="_blank" rel="external">https://www.oudahe.com/p/python/z545/</a></p><blockquote><p>最后不懂的模块知识可利用好搜索引擎。</p></blockquote><p>实际上也参考了我自己的文章：</p><blockquote><p><a href="https://liujunjie11.github.io/2018/04/28/python3爬虫与GUI：一个简易的搜索实用小工具/#more">https://liujunjie11.github.io/2018/04/28/python3爬虫与GUI：一个简易的搜索实用小工具/#more</a></p></blockquote><p>以及<em>pyqt5</em>的官网教程：</p><blockquote><p><a href="https://maicss.gitbooks.io/pyqt5/content/事件和信号.html" target="_blank" rel="external">https://maicss.gitbooks.io/pyqt5/content/事件和信号.html</a></p></blockquote><ul><li>关于将python文件打包生成app的工具库：</li></ul><blockquote><p><strong>py2app:.py –&gt; .dmg</strong></p><p><strong>py2exe:.py –&gt; .exe</strong></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近看到了一篇文章，一个基于&lt;em&gt;有道&lt;/em&gt;的词典小工具，心血来潮，想着自己来写一个试试看。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;下面我将用&lt;em&gt;python&lt;/em&gt;完成接口的对接(即进行抓包)，并且用&lt;em&gt;pyQT5&lt;/em&gt;实现对应的GUI界面。接下来就
      
    
    </summary>
    
      <category term="python爬虫与GUI" scheme="https://liujunjie11.github.io/categories/python%E7%88%AC%E8%99%AB%E4%B8%8EGUI/"/>
    
    
      <category term="python爬虫与GUI" scheme="https://liujunjie11.github.io/tags/python%E7%88%AC%E8%99%AB%E4%B8%8EGUI/"/>
    
  </entry>
  
  <entry>
    <title>(转)五大常用算法总结</title>
    <link href="https://liujunjie11.github.io/2018/05/07/%E8%BD%AC-%E4%BA%94%E5%A4%A7%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>https://liujunjie11.github.io/2018/05/07/转-五大常用算法总结/</id>
    <published>2018-05-07T04:22:27.000Z</published>
    <updated>2018-05-07T07:30:31.485Z</updated>
    
    <content type="html"><![CDATA[<p>本文转自：</p><blockquote><p><strong>博客园：<a href="http://www.cnblogs.com/steven_oyj/archive/2010/05/22/1741370.html" target="_blank" rel="external">http://www.cnblogs.com/steven_oyj/archive/2010/05/22/1741370.html</a></strong><br><strong>作者：红脸书生</strong></p></blockquote><hr><h1 id="分治算法"><a href="#分治算法" class="headerlink" title="分治算法"></a>分治算法</h1><h2 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><p>   在计算机科学中，分治法是一种很重要的算法。字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。这个技巧是很多高效算法的基础，如排序算法(快速排序，归并排序)，傅立叶变换(快速傅立叶变换)……</p><p>   任何一个可以用计算机求解的问题所需的计算时间都与其规模有关。问题的规模越小，越容易直接求解，解题所需的计算时间也越少。例如，对于n个元素的排序问题，当n=1时，不需任何计算。n=2时，只要作一次比较即可排好序。n=3时只要作3次比较即可，…。而当n较大时，问题就不那么容易处理了。要想直接解决一个规模较大的问题，有时是相当困难的。</p><h2 id="二、基本思想及策略"><a href="#二、基本思想及策略" class="headerlink" title="二、基本思想及策略"></a>二、基本思想及策略</h2><p>   <strong>分治法的设计思想是：</strong>将一个难以直接解决的大问题，分割成一些规模较小的相同问题，以便各个击破，分而治之。</p><p>   <strong>分治策略是：</strong>对于一个规模为n的问题，若该问题可以容易地解决（比如说规模n较小）则直接解决，否则将其分解为k个规模较小的子问题，这些子问题互相独立且与原问题形式相同，递归地解这些子问题，然后将各子问题的解合并得到原问题的解。这种算法设计策略叫做分治法。</p><p>   如果原问题可分割成k个子问题，1&lt;k≤n，且这些子问题都可解并可利用这些子问题的解求出原问题的解，那么这种分治法就是可行的。由分治法产生的子问题往往是原问题的较小模式，这就为使用递归技术提供了方便。在这种情况下，反复应用分治手段，可以使子问题与原问题类型一致而其规模却不断缩小，最终使子问题缩小到很容易直接求出其解。这自然导致递归过程的产生。分治与递归像一对孪生兄弟，经常同时应用在算法设计之中，并由此产生许多高效算法。</p><h2 id="三、分治法适用的情况"><a href="#三、分治法适用的情况" class="headerlink" title="三、分治法适用的情况"></a>三、分治法适用的情况</h2><ul><li><p>分治法所能解决的问题一般具有以下几个特征：</p><p>（1) 该问题的规模缩小到一定的程度就可以容易地解决</p><p>（2) 该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质。</p><p>（3) 利用该问题分解出的子问题的解可以合并为该问题的解；</p><p>（4) 该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子子问题。</p></li></ul><blockquote><p>第一条特征是绝大多数问题都可以满足的，因为问题的计算复杂性一般是随着问题规模的增加而增加；</p><p>第二条特征是应用分治法的前提它也是大多数问题可以满足的，此特征反映了递归思想的应用；、</p><p>第三条特征是关键，能否利用分治法完全取决于问题是否具有第三条特征，如果具备了第一条和第二条特征，而不具备第三条特征，则可以考虑用贪心法或动态规划法。</p><p>第四条特征涉及到分治法的效率，如果各子问题是不独立的则分治法要做许多不必要的工作，重复地解公共的子问题，此时虽然可用分治法，但一般用动态规划法较好。</p></blockquote><h2 id="四、分治法的基本步骤"><a href="#四、分治法的基本步骤" class="headerlink" title="四、分治法的基本步骤"></a>四、分治法的基本步骤</h2><p>分治法在每一层递归上都有三个步骤：</p><ul><li><p>step1 分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题；</p></li><li><p>step2 解决：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题</p></li><li><p>step3 合并：将各个子问题的解合并为原问题的解。</p></li></ul><p>它的一般的算法设计模式如下：</p><pre><code>Divide-and-Conquer(P)1. if |P|≤n02. then return(ADHOC(P))3. 将P分解为较小的子问题 P1 ,P2 ,...,Pk4. for i←1 to k5. do yi ← Divide-and-Conquer(Pi) △ 递归解决Pi6. T ← MERGE(y1,y2,...,yk) △ 合并子问题7. return(T)</code></pre><blockquote><p>   其中|P|表示问题P的规模；n0为一阈值，表示当问题P的规模不超过n0时，问题已容易直接解出，不必再继续分解。ADHOC(P)是该分治法中的基本子算法，用于直接解小规模的问题P。因此，当P的规模不超过n0时直接用算法ADHOC(P)求解。算法MERGE(y1,y2,…,yk)是该分治法中的合并子算法，用于将P的子问题P1 ,P2 ,…,Pk的相应的解y1,y2,…,yk合并为P的解。</p></blockquote><h2 id="五、分治法的复杂性分析"><a href="#五、分治法的复杂性分析" class="headerlink" title="五、分治法的复杂性分析"></a>五、分治法的复杂性分析</h2><p>   一个分治法将规模为n的问题分成k个规模为n／m的子问题去解。设分解阀值n0=1，且adhoc解规模为1的问题耗费1个单位时间。再设将原问题分解为k个子问题以及用merge将k个子问题的解合并为原问题的解需用f(n)个单位时间。用T(n)表示该分治法解规模为|P|=n的问题所需的计算时间，则有：</p><p> T（n）= k T(n/m)+f(n)</p><p>  通过迭代法求得方程的解：</p><p>  递归方程及其解只给出n等于m的方幂时T(n)的值，但是如果认为T(n)足够平滑，那么由n等于m的方幂时T(n)的值可以估计T(n)的增长速度。通常假定T(n)是单调上升的，从而当mi≤n&lt;mi+1时，T(mi)≤T(n)&lt;T(mi+1)。 </p><h2 id="六、可使用分治法求解的一些经典问题"><a href="#六、可使用分治法求解的一些经典问题" class="headerlink" title="六、可使用分治法求解的一些经典问题"></a>六、可使用分治法求解的一些经典问题</h2><p> （1）二分搜索<br> （2）大整数乘法<br> （3）Strassen矩阵乘法<br> （4）棋盘覆盖<br> （5）合并排序<br> （6）快速排序<br> （7）线性时间选择</p><p> （8）最接近点对问题<br> （9）循环赛日程表<br> （10）汉诺塔</p><h2 id="七、依据分治法设计程序时的思维过程"><a href="#七、依据分治法设计程序时的思维过程" class="headerlink" title="七、依据分治法设计程序时的思维过程"></a>七、依据分治法设计程序时的思维过程</h2><blockquote><p>   实际上就是类似于数学归纳法，找到解决本问题的求解方程公式，然后根据方程公式设计递归程序。</p></blockquote><p>1、一定是先找到最小问题规模时的求解方法</p><p>2、然后考虑随着问题规模增大时的求解方法</p><p>3、找到求解的递归函数式后（各种规模或因子），设计递归程序即可。</p><h1 id="动态规划算法"><a href="#动态规划算法" class="headerlink" title="动态规划算法"></a>动态规划算法</h1><h2 id="一、基本概念-1"><a href="#一、基本概念-1" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><p>   动态规划过程是：每次决策依赖于当前状态，又随即引起状态的转移。一个决策序列就是在变化的状态中产生出来的，所以，这种多阶段最优化决策解决问题的过程就称为动态规划。</p><h2 id="二、基本思想与策略"><a href="#二、基本思想与策略" class="headerlink" title="二、基本思想与策略"></a>二、基本思想与策略</h2><p>   基本思想与分治法类似，也是将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，前一子问题的解，为后一子问题的求解提供了有用的信息。在求解任一子问题时，列出各种可能的局部解，通过决策保留那些有可能达到最优的局部解，丢弃其他局部解。依次解决各子问题，最后一个子问题就是初始问题的解。</p><p>   由于动态规划解决的问题多数有重叠子问题这个特点，为减少重复计算，对每一个子问题只解一次，将其不同阶段的不同状态保存在一个二维数组中。</p><blockquote><p> 与分治法最大的差别是：适合于用动态规划法求解的问题，经分解后得到的子问题往往不是互相独立的（即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解）。</p></blockquote><h2 id="三、适用的情况"><a href="#三、适用的情况" class="headerlink" title="三、适用的情况"></a>三、适用的情况</h2><p>能采用动态规划求解的问题的一般要具有3个性质：</p><ul><li><p>最优化原理：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。</p></li><li><p>无后效性：即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关。</p></li><li><p>有重叠子问题：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势）</p></li></ul><h2 id="四、求解的基本步骤"><a href="#四、求解的基本步骤" class="headerlink" title="四、求解的基本步骤"></a>四、求解的基本步骤</h2><p>   动态规划所处理的问题是一个多阶段决策问题，一般由初始状态开始，通过对中间阶段决策的选择，达到结束状态。这些决策形成了一个决策序列，同时确定了完成整个过程的一条活动路线(通常是求最优的活动路线)。如图所示。动态规划的设计都有着一定的模式，一般要经历以下几个步骤。</p><blockquote><p>   初始状态→│决策１│→│决策２│→…→│决策ｎ│→结束状态<br>                      图1 动态规划决策过程示意图</p></blockquote><p>   (1)划分阶段：按照问题的时间或空间特征，把问题分为若干个阶段。在划分阶段时，注意划分后的阶段一定要是有序的或者是可排序的，否则问题就无法求解。</p><p>   (2)确定状态和状态变量：将问题发展到各个阶段时所处于的各种客观情况用不同的状态表示出来。当然，状态的选择要满足无后效性。</p><p>   (3)确定决策并写出状态转移方程：因为决策和状态转移有着天然的联系，状态转移就是根据上一阶段的状态和决策来导出本阶段的状态。所以如果确定了决策，状态转移方程也就可写出。但事实上常常是反过来做，根据相邻两个阶段的状态之间的关系来确定决策方法和状态转移方程。</p><p>   (4)寻找边界条件：给出的状态转移方程是一个递推式，需要一个递推的终止条件或边界条件。一般，只要解决问题的阶段、状态和状态转移决策确定了，就可以写出状态转移方程（包括边界条件）。</p><p>实际应用中可以按以下几个简化的步骤进行设计：</p><pre><code>（1）分析最优解的性质，并刻画其结构特征。（2）递归的定义最优解。（3）以自底向上或自顶向下的记忆化方式（备忘录法）计算出最优值（4）根据计算最优值时得到的信息，构造问题的最优解</code></pre><h2 id="五、算法实现的说明"><a href="#五、算法实现的说明" class="headerlink" title="五、算法实现的说明"></a>五、算法实现的说明</h2><p>   动态规划的主要难点在于理论上的设计，也就是上面4个步骤的确定，一旦设计完成，实现部分就会非常简单。使用动态规划求解问题，最重要的就是确定动态规划三要素：</p><p>（1）问题的阶段 </p><p>（2）每个阶段的状态</p><p>（3）从前一个阶段转化到后一个阶段之间的递推关系。</p><p>   递推关系必须是从次小的问题开始到较大的问题之间的转化，从这个角度来说，动态规划往往可以用递归程序来实现，不过因为递推可以充分利用前面保存的子问题的解来减少重复计算，所以对于大规模问题来说，有递归不可比拟的优势，这也是动态规划算法的核心之处。</p><p>   确定了动态规划的这三要素，整个求解过程就可以用一个最优决策表来描述，最优决策表是一个二维表，其中行表示决策的阶段，列表示问题状态，表格需要填写的数据一般对应此问题的在某个阶段某个状态下的最优值（如最短路径，最长公共子序列，最大价值等），填表的过程就是根据递推关系，从1行1列开始，以行或者列优先的顺序，依次填写表格，最后根据整个表格的数据通过简单的取舍或者运算求得问题的最优解。</p><pre><code>f(n,m)=max{f(n-1,m), f(n-1,m-w[n])+P(n,m)}</code></pre><h2 id="六、动态规划算法基本框架"><a href="#六、动态规划算法基本框架" class="headerlink" title="六、动态规划算法基本框架"></a>六、动态规划算法基本框架</h2><p>代码：</p><pre><code>for(j=1; j&lt;=m; j=j+1) // 第一个阶段   xn[j] = 初始值; for(i=n-1; i&gt;=1; i=i-1)// 其他n-1个阶段   for(j=1; j&gt;=f(i); j=j+1)//f(i)与i有关的表达式     xi[j]=j=max（或min）{g(xi-1[j1:j2]), ......, g(xi-1[jk:jk+1])};t = g(x1[j1:j2]); // 由子问题的最优解求解整个问题的最优解的方案print(x1[j1]);for(i=2; i&lt;=n-1; i=i+1）{       t = t-xi-1[ji];     for(j=1; j&gt;=f(i); j=j+1)        if(t=xi[ji])             break;}</code></pre><h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><h2 id="一、基本概念："><a href="#一、基本概念：" class="headerlink" title="一、基本概念："></a>一、基本概念：</h2><p>   所谓贪心算法是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的仅是在某种意义上的局部最优解。</p><p>   贪心算法没有固定的算法框架，算法设计的关键是贪心策略的选择。必须注意的是，贪心算法不是对所有问题都能得到整体最优解，选择的贪心策略必须具备无后效性，即某个状态以后的过程不会影响以前的状态，只与当前状态有关。</p><p>   所以对所采用的贪心策略一定要仔细分析其是否满足无后效性。</p><h2 id="二、贪心算法的基本思路："><a href="#二、贪心算法的基本思路：" class="headerlink" title="二、贪心算法的基本思路："></a>二、贪心算法的基本思路：</h2><p>1.建立数学模型来描述问题。</p><p>2.把求解的问题分成若干个子问题。</p><p>3.对每一子问题求解，得到子问题的局部最优解。</p><p>4.把子问题的解局部最优解合成原来解问题的一个解。</p><h2 id="三、贪心算法适用的问题"><a href="#三、贪心算法适用的问题" class="headerlink" title="三、贪心算法适用的问题"></a>三、贪心算法适用的问题</h2><p>   贪心策略适用的前提是：局部最优策略能导致产生全局最优解。实际上，贪心算法适用的情况很少。一般，对一个问题分析是否适用于贪心算法，可以先选择该问题下的几个实际数据进行分析，就可做出判断。</p><h2 id="四、贪心算法的实现框架"><a href="#四、贪心算法的实现框架" class="headerlink" title="四、贪心算法的实现框架"></a>四、贪心算法的实现框架</h2><pre><code>从问题的某一初始解出发；while （能朝给定总目标前进一步）{       利用可行的决策，求出可行解的一个解元素；}由所有解元素组合成问题的一个可行解；</code></pre><h2 id="五、贪心策略的选择"><a href="#五、贪心策略的选择" class="headerlink" title="五、贪心策略的选择"></a>五、贪心策略的选择</h2><p>   因为用贪心算法只能通过解局部最优解的策略来达到全局最优解，因此，一定要注意判断问题是否适合采用贪心算法策略，找到的解是否一定是问题的最优解。</p><h2 id="六、例题分析"><a href="#六、例题分析" class="headerlink" title="六、例题分析"></a>六、例题分析</h2><pre><code>下面是一个可以试用贪心算法解的题目，贪心解的确不错，可惜不是最优解。[背包问题]有一个背包，背包容量是M=150。有7个物品，物品可以分割成任意大小。要求尽可能让装入背包中的物品总价值最大，但不能超过总容量。物品 A B C D E F G重量 35 30 60 50 40 10 25价值 10 40 30 50 35 40 30分析：目标函数： ∑pi最大约束条件是装入的物品总重量不超过背包容量：∑wi&lt;=M( M=150)（1）根据贪心的策略，每次挑选价值最大的物品装入背包，得到的结果是否最优？（2）每次挑选所占重量最小的物品装入是否能得到最优解？（3）每次选取单位重量价值最大的物品，成为解本题的策略。值得注意的是，贪心算法并不是完全不可以使用，贪心策略一旦经过证明成立后，它就是一种高效的算法。贪心算法还是很常见的算法之一，这是由于它简单易行，构造贪心策略不是很困难。可惜的是，它需要证明后才能真正运用到题目的算法中。一般来说，贪心算法的证明围绕着：整个问题的最优解一定由在贪心策略中存在的子问题的最优解得来的。对于例题中的3种贪心策略，都是无法成立（无法被证明）的，解释如下：（1）贪心策略：选取价值最大者。反例：W=30物品：A B C重量：28 12 12价值：30 20 20根据策略，首先选取物品A，接下来就无法再选取了，可是，选取B、C则更好。（2）贪心策略：选取重量最小。它的反例与第一种策略的反例差不多。（3）贪心策略：选取单位重量价值最大的物品。反例：W=30物品：A B C重量：28 20 10价值：28 20 10根据策略，三种物品单位重量价值一样，程序无法依据现有策略作出判断，如果选择A，则答案错误。</code></pre><h1 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h1><h2 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h2><p>   回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。</p><p>   回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。</p><p>   许多复杂的，规模较大的问题都可以使用回溯法，有“通用解题方法”的美称。</p><h2 id="2、基本思想"><a href="#2、基本思想" class="headerlink" title="2、基本思想"></a>2、基本思想</h2><p>   在包含问题的所有解的解空间树中，按照深度优先搜索的策略，从根结点出发深度探索解空间树。当探索到某一结点时，要先判断该结点是否包含问题的解，如果包含，就从该结点出发继续探索下去，如果该结点不包含问题的解，则逐层向其祖先结点回溯。（其实回溯法就是对隐式图的深度优先搜索算法）。</p><p>   若用回溯法求问题的所有解时，要回溯到根，且根结点的所有可行的子树都要已被搜索遍才结束。</p><p>   而若使用回溯法求任一个解时，只要搜索到问题的一个解就可以结束。</p><p>3、<strong>用回溯法解题的一般步骤：</strong></p><p>（1）针对所给问题，确定问题的解空间：首先应明确定义问题的解空间，问题的解空间应至少包含问题的一个（最优）解。</p><p>（2）确定结点的扩展搜索规则</p><p>（3）以深度优先方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索。</p><h2 id="4、算法框架"><a href="#4、算法框架" class="headerlink" title="4、算法框架"></a>4、算法框架</h2><h3 id="（1）问题框架"><a href="#（1）问题框架" class="headerlink" title="（1）问题框架"></a>（1）问题框架</h3><pre><code>设问题的解是一个n维向量(a1,a2,………,an),约束条件是ai(i=1,2,3,…..,n)之间满足某种条件，记为f(ai)。</code></pre><h3 id="（2）非递归回溯框架"><a href="#（2）非递归回溯框架" class="headerlink" title="（2）非递归回溯框架"></a>（2）非递归回溯框架</h3><pre><code> 1: int a[n],i; 2: 初始化数组a[]; 3: i = 1; 4: while (i&gt;0(有路可走)   and  (未达到目标))  // 还未回溯到头 5: { 6:     if(i &gt; n)                                              // 搜索到叶结点 7:     {    8:           搜索到一个解，输出； 9:     }10:     else                                                   // 处理第i个元素11:     { 12:           a[i]第一个可能的值；13:           while(a[i]在不满足约束条件且在搜索空间内)</code></pre><h3 id="3）递归的算法框架"><a href="#3）递归的算法框架" class="headerlink" title="3）递归的算法框架"></a>3）递归的算法框架</h3><blockquote><p>回溯法是对解空间的深度优先搜索，在一般情况下使用递归函数来实现回溯法比较简单，其中i为搜索的深度，框架如下：</p></blockquote><pre><code> 1: int a[n]; 2: try(int i) 3: { 4:     if(i&gt;n) 5:        输出结果; 6:      else 7:     { 8:        for(j = 下界; j &lt;= 上界; j=j+1)  // 枚举i所有可能的路径 9:        {10:            if(fun(j))                 // 满足限界函数和约束条件11:              {12:                 a[i] = j;13:               ...                         // 其他操作</code></pre><h1 id="分支限界法"><a href="#分支限界法" class="headerlink" title="分支限界法"></a>分支限界法</h1><h2 id="一、基本描述"><a href="#一、基本描述" class="headerlink" title="一、基本描述"></a>一、基本描述</h2><p>   类似于回溯法，也是一种在问题的解空间树T上搜索问题解的算法。但在一般情况下，分支限界法与回溯法的求解目标不同。回溯法的求解目标是找出T中满足约束条件的所有解，而分支限界法的求解目标则是找出满足约束条件的一个解，或是在满足约束条件的解中找出使某一目标函数值达到极大或极小的解，即在某种意义下的最优解。</p><h3 id="（1）分支搜索算法"><a href="#（1）分支搜索算法" class="headerlink" title="（1）分支搜索算法"></a>（1）分支搜索算法</h3><blockquote><p>所谓“分支”就是采用广度优先的策略，依次搜索E-结点的所有分支，也就是所有相邻结点，抛弃不满足约束条件的结点，其余结点加入活结点表。然后从表中选择一个结点作为下一个E-结点，继续搜索。</p></blockquote><p>选择下一个E-结点的方式不同，则会有几种不同的分支搜索方式。</p><ul><li><p>FIFO搜索</p></li><li><p>LIFO搜索</p></li><li><p>优先队列式搜索</p></li></ul><h3 id="（2）分支限界搜索算法"><a href="#（2）分支限界搜索算法" class="headerlink" title="（2）分支限界搜索算法"></a>（2）分支限界搜索算法</h3><h2 id="二、分支限界法的一般过程"><a href="#二、分支限界法的一般过程" class="headerlink" title="二、分支限界法的一般过程"></a>二、分支限界法的一般过程</h2><blockquote><p>由于求解目标不同，导致分支限界法与回溯法在解空间树T上的搜索方式也不相同。回溯法以深度优先的方式搜索解空间树T，而分支限界法则以广度优先或以最小耗费优先的方式搜索解空间树T。</p></blockquote><p><strong>分支限界法的搜索策略是：</strong></p><p>在扩展结点处，先生成其所有的儿子结点（分支），然后再从当前的活结点表中选择下一个扩展对点。为了有效地选择下一扩展结点，以加速搜索的进程，在每一活结点处，计算一个函数值（限界），并根据这些已计算出的函数值，从当前活结点表中选择一个最有利的结点作为扩展结点，使搜索朝着解空间树上有最优解的分支推进，以便尽快地找出一个最优解。</p><p>分支限界法常以广度优先或以最小耗费（最大效益）优先的方式搜索问题的解空间树。问题的解空间树是表示问题解空间的一棵有序树，常见的有子集树和排列树。在搜索问题的解空间树时，分支限界法与回溯法对当前扩展结点所使用的扩展方式不同。在分支限界法中，每一个活结点只有一次机会成为扩展结点。活结点一旦成为扩展结点，就一次性产生其所有儿子结点。在这些儿子结点中，那些导致不可行解或导致非最优解的儿子结点被舍弃，其余儿子结点被子加入活结点表中。此后，从活结点表中取下一结点成为当前扩展结点，并重复上述结点扩展过程。这个过程一直持续到找到所求的解或活结点表为空时为止。</p><h2 id="三、回溯法和分支限界法的一些区别"><a href="#三、回溯法和分支限界法的一些区别" class="headerlink" title="三、回溯法和分支限界法的一些区别"></a>三、回溯法和分支限界法的一些区别</h2><blockquote><p>有一些问题其实无论用回溯法还是分支限界法都可以得到很好的解决，但是另外一些则不然。也许我们需要具体一些的分析——到底何时使用分支限界而何时使用回溯呢？</p></blockquote><h3 id="回溯法和分支限界法的一些区别："><a href="#回溯法和分支限界法的一些区别：" class="headerlink" title="回溯法和分支限界法的一些区别："></a>回溯法和分支限界法的一些区别：</h3><ul><li><p>方法对解空间树的搜索方式       </p></li><li><p>存储结点的常用数据结构      </p></li><li><p>结点存储特性常用应用</p></li></ul><blockquote><p><strong>回溯法深度优先搜索堆栈活结点的所有可行子结点被遍历后才被从栈中弹出找出满足约束条件的所有解</strong></p><p><strong>分支限界法广度优先或最小消耗优先搜索队列、优先队列每个结点只有一次成为活结点的机会找出满足约束条件的一个解或特定意义下的最优解</strong></p></blockquote><p><strong>策略是面向问题的，算法是面向实现的。</strong></p><h1 id="一、不同算法策略特点小结"><a href="#一、不同算法策略特点小结" class="headerlink" title="一、不同算法策略特点小结"></a>一、不同算法策略特点小结</h1><h2 id="1、贪心策略"><a href="#1、贪心策略" class="headerlink" title="1、贪心策略"></a>1、贪心策略</h2><ul><li><p>贪心策略一方面是求解过程比较简单的算法，另一方面它又是对能适用问题的条件要求最严格（即适用范围很小）的算法。</p></li><li><p>贪心策略解决问题是按一定顺序，在只考虑当前局部信息的情况下，就做出一定的决策，最终得出问题的解。</p></li></ul><blockquote><p>即：通过局部最优决策能得到全局最优决策</p></blockquote><h2 id="2、递推策略"><a href="#2、递推策略" class="headerlink" title="2、递推策略"></a>2、递推策略</h2><p>   递推也是由当前问题的逐步解决从而得到整个问题的解，依赖于信息间本身的递推关系，每一步不需要决策参与到算法中，更多用于计算</p><h2 id="3、递归策略"><a href="#3、递归策略" class="headerlink" title="3、递归策略"></a>3、递归策略</h2><p>   递归常常用于分治算法、动态规划算法中。</p><p>   递归是利用大问题与其子问题间的递推关系来解决问题的。</p><p>   能采用递归策略的算法一般有以下特征：</p><p>   （1）为求解规模为N的问题，设法将它分解成规模较小的问题，然后从这些小问题的解方便地构造出大问题的解</p><p>   （2）并且这些规模较小的问题也能采用同样的分解和综合方法，分解成更小的问题，并从这些更小的问题的解构造出规模较大问题的解</p><p>   （3）特别的，当规模N = 1时，能直接得解</p><h2 id="4、枚举策略"><a href="#4、枚举策略" class="headerlink" title="4、枚举策略"></a>4、枚举策略</h2><p>   对问题所有的解逐一尝试，从而找出问题的真正解。一般用于决策类问题，很难找到大、小规模之间的关系，也不易对问题进行分解。</p><h2 id="5、递归回溯策略"><a href="#5、递归回溯策略" class="headerlink" title="5、递归回溯策略"></a>5、递归回溯策略</h2><p>   类似于枚举，通过尝试遍历问题各个可能解的通路，当发现此路不通时，回溯到上一步继续尝试别的通路。</p><h2 id="6、分治策略"><a href="#6、分治策略" class="headerlink" title="6、分治策略"></a>6、分治策略</h2><p>   分治一般用于较复杂的问题，必须可以逐步被分解为容易解决的独立的子问题，这些子问题解决后，进而将它们的解“合成”，就得到较大问题的解，最终合成为总问题的解。</p><h2 id="7、动态规划策略"><a href="#7、动态规划策略" class="headerlink" title="7、动态规划策略"></a>7、动态规划策略</h2><p>   与贪心类似，也是通过多阶段决策过程来解决问题。每个阶段决策的结果是一个决策结果序列，这个结果序列中，最终哪一个是最优的结果，取决于以后每个阶段的决策，当然每次决策结果序列都必须进行存储。因此是“高效率，高消费的算法”。</p><p>   同时，它又与递归法类似，当问题不能分解为独立的阶段，却又符合最优化原理时，就可以使用动态规划法，通过递归决策过程，逐步找出子问题的最优解，从而决策出问题的解。</p><h1 id="二、算法策略间的关系"><a href="#二、算法策略间的关系" class="headerlink" title="二、算法策略间的关系"></a>二、算法策略间的关系</h1><h2 id="1、对问题进行分解的算法策略——分治法与动态规划法"><a href="#1、对问题进行分解的算法策略——分治法与动态规划法" class="headerlink" title="1、对问题进行分解的算法策略——分治法与动态规划法"></a>1、对问题进行分解的算法策略——分治法与动态规划法</h2><ul><li><p><strong>共同点：</strong></p><p> （1）分治法与动态规划法实际上都是递归思想的运用</p><p> （2）二者的根本策略都是对问题进行分解，找到大规模与小规模的关系，然后通过解小规模的解，得出大规模的解</p></li><li><p><strong>不同点：</strong>适用于分治法的问题分解成子问题后，各子问题间无公共子子问题，而动态规划法相反。</p></li></ul><blockquote><p><strong>动态规划法 = 分治算法思想 + 解决子问题间的冗余情况</strong></p></blockquote><h2 id="2、多阶段逐步解决问题的策略——贪心算法、递推法、递归法和动态规划法"><a href="#2、多阶段逐步解决问题的策略——贪心算法、递推法、递归法和动态规划法" class="headerlink" title="2、多阶段逐步解决问题的策略——贪心算法、递推法、递归法和动态规划法"></a>2、多阶段逐步解决问题的策略——贪心算法、递推法、递归法和动态规划法</h2><p>   <strong>贪心算法</strong>：每一步都根据策略得到一个结果，并传递到下一步，自顶向下，一步一步地做出贪心决策。</p><p>   <strong>动态规划算法</strong>：每一步决策得到的不是一个唯一结果，而是一组中间结果（且这些结果在以后各步可能得到多次引用），只是每一步都使问题的规模逐步缩小，最终得到问题的一个结果。</p><p>   <strong>递推、递归法：</strong>注重每一步之间的关系，决策的因素较少。递推法是根据关系从前向后推导，从小规模问题的结论推解出大问题的解。而递归法是根据关系从后向前使大问题转化为小问题，最后同样由小规模问题的解推解出大问题的解。</p><h2 id="3、全面逐一尝试、比较——蛮力法、枚举法、递归回溯法"><a href="#3、全面逐一尝试、比较——蛮力法、枚举法、递归回溯法" class="headerlink" title="3、全面逐一尝试、比较——蛮力法、枚举法、递归回溯法"></a>3、全面逐一尝试、比较——蛮力法、枚举法、递归回溯法</h2><p>蛮力策略（即枚举和递归回溯）：</p><p>   当问题找不到信息间的相互关系、也不能将问题分解为独立的子问题，就只有把全部解都列出来之后，才能判定和推断出问题的解。</p><blockquote><p>蛮力策略适用于规模不大的问题。</p></blockquote><p>（1）枚举法：实现依赖于循环。所以一个枚举法只针对一个特定问题规模的情况，例如：八重循环嵌套解八皇后问题的算法。</p><p>（2）递归回溯法：适用于任意指定规模的情况，例如：递归回溯法解N皇后问题。</p><h2 id="4、算法策略的中心思想"><a href="#4、算法策略的中心思想" class="headerlink" title="4、算法策略的中心思想"></a>4、算法策略的中心思想</h2><p>   用算法策略将解决问题的过程归结为：用算法的基本工具“循环机制和递归机制”实现。</p><h1 id="三、算法策略侧重的问题类型"><a href="#三、算法策略侧重的问题类型" class="headerlink" title="三、算法策略侧重的问题类型"></a>三、算法策略侧重的问题类型</h1><p>一般常遇到的问题分为四类：</p><p>（1）判定性问题：可用递推法、递归法</p><p>（2）计算问题：可用递推法、递归法</p><p>（3）最优化问题：贪心算法、分治法、动态规划法、枚举法</p><p>（4）构造性问题：贪心算法、分治法、广度优先搜索、深度优先搜索</p><p>好</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文转自：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;博客园：&lt;a href=&quot;http://www.cnblogs.com/steven_oyj/archive/2010/05/22/1741370.html&quot; target=&quot;_blank&quot; rel=&quot;ex
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://liujunjie11.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="https://liujunjie11.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>python3爬取拉勾网职位信息</title>
    <link href="https://liujunjie11.github.io/2018/05/05/python3%E7%88%AC%E5%8F%96%E6%8B%89%E5%8B%BE%E7%BD%91%E8%81%8C%E4%BD%8D%E4%BF%A1%E6%81%AF/"/>
    <id>https://liujunjie11.github.io/2018/05/05/python3爬取拉勾网职位信息/</id>
    <published>2018-05-05T10:05:56.000Z</published>
    <updated>2018-05-06T14:38:37.256Z</updated>
    
    <content type="html"><![CDATA[<p>爬取拉勾网的最大障碍：<strong>普通模块难以实现翻页爬取。</strong>自己加了参数<code>page</code>，经过抓包查询之后也达不到我的理想要求。</p><p>没办法了，只好用<em>selenium</em>模块结合浏览器来实现边翻页边爬取了。</p><blockquote><p>实际上比较浪费系统资源，这种情况不得已还是尽量别用的好。</p></blockquote><p>在此记录下主要的过程，包括实现的代码。</p><p>还是要说明一下：<strong>不懂的地方还是需要自己去查询了解，代码不过就是几个模块的知识运用罢了。</strong></p><h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>启动<em>Chrome**webdriver</em>插件，之后复制其所在地址，加入代码中启动<em>selenium</em>模块程序。</p><p><img src="http://owudg3xs2.bkt.clouddn.com/5%E6%9C%88-06-2018%2022-29-25.gif" alt=""></p><blockquote><p>启动插件。</p></blockquote><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-05-06%20%E4%B8%8B%E5%8D%8810.28.45.png" alt=""></p><blockquote><p>本机此插件所在的目录位置。</p></blockquote><h2 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h2><p>经过简单的分析，发现页面的切换的同时URL没有任何的改变(这就是我为何要用<em>selenium</em>来爬取的原因！)：</p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-05-06%20%E4%B8%8B%E5%8D%8810.32.58.png" alt=""></p><p>我们的目标是，点击在此符合条件的发布公司链接，进入招聘信息详细的界面爬取详细的所有需要的信息：</p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-05-06%20%E4%B8%8B%E5%8D%8810.34.40.png" alt=""></p><blockquote><p>一一进入进行爬取。</p></blockquote><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-05-06%20%E4%B8%8B%E5%8D%8810.35.34.png" alt=""></p><blockquote><p>进入之后详细的招聘信息页面。</p></blockquote><p>那么思路一下就出来了：<strong>用selenium模块实现翻页的功能，并且返回对应页面的源代码，并且一一进行分析提取即可。</strong></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre><code>&quot;&quot;&quot;函数目标：翻页爬取拉勾网的职位信息编写时间：2018-05-05&quot;&quot;&quot;from selenium import webdriverfrom selenium.webdriver.common.by import Byfrom selenium.webdriver.support import expected_conditions as ECfrom selenium.webdriver.support.wait import WebDriverWaitfrom pyquery import PyQuery as pqfrom urllib.parse import quoteimport requestsimport reimport time# 启动对象驱动，并且设置预期的等待时间browser = webdriver.Chrome(&apos;/Users/junjieliu/Downloads/webdirver小插件/chromedriver&apos;)wait = WebDriverWait(browser, 10)def page_content(pages):    &quot;&quot;&quot;    返回每一页的页面源代码，顾名知义，从URL中可知许多的筛选信息了，可自行选择，    在此仅以职位关键词职位作为输入。    &quot;&quot;&quot;    print(&apos;-&apos; * 10 + &apos;正在爬取第&apos; + str(pages) + &apos;页的内容&apos; + &apos;.&apos; * 6)    keyword = &apos;数据分析师&apos;  # 职位关键词    url = &apos;https://www.lagou.com/jobs/list_&apos; + quote(keyword) + &apos;?&apos; + &apos;px=default&amp;gx=实习&amp;gj=&amp;xl=本科&amp;isSchoolJob=1&amp;city=全国#filterBox&apos;     browser.get(url)    if pages &gt; 1:        # 如果页面数大于1页则启用自动翻页        next_botton = wait.until(                    EC.element_to_be_clickable((By.CSS_SELECTOR, &apos;#s_position_list &gt; div.item_con_pager &gt; div &gt; span.pager_next&apos;)))        next_botton.click()    # 指定要爬取区域,非必须要写    wait.until(            EC.presence_of_element_located((By.CSS_SELECTOR, &apos;#s_position_list &gt; ul &gt; li.con_list_item&apos;)))    print(&apos;爬取此页源码成功！以下是本页一系列相关的内容：&apos;)    informations_save()def informations_save():    &quot;&quot;&quot;    一一进入内部URL，爬取详细的招聘信息！    &quot;&quot;&quot;    source_code = browser.page_source    doc = pq(source_code)    url = re.findall(r&apos;class=&quot;position_link&quot;.*?href=&quot;(.*?)&quot;&apos;, source_code, re.S)  # @UndefinedVariable      for i in range(0, len(url)):        header = {        &apos;Connection&apos;: &apos;keep-alive&apos;,        &apos;Host&apos;: &apos;www.lagou.com&apos;,        &apos;Upgrade-Insecure-Requests&apos;: &apos;1&apos;,        &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.139 Safari/537.36&apos;    }        response = requests.get(url=url[i], headers=header)        response.encoding = &apos;utf-8&apos;        doc1 = pq(response.text)        infor = {            &apos;company&apos;:doc1.find(&apos;body &gt; div.position-head &gt; div &gt; div.position-content-l &gt; div &gt; div.company&apos;).text(),  # 公司名称            &apos;infor_url&apos;:doc1.find(&apos;#job_company &gt; dt &gt; a&apos;).attr(&apos;href&apos;),  # 此公司详细介绍网站            &apos;position&apos;:doc1.find(&apos;body &gt; div.position-head &gt; div &gt; div.position-content-l &gt; div &gt; span.name&apos;).text(),  # 职位            &apos;salary&apos;:doc1.find(&apos;body &gt; div.position-head &gt; div &gt; div.position-content-l &gt; dd &gt; p:nth-child(1) &gt; span.salary&apos;).text(),  # 工资            &apos;locale&apos;:doc1.find(&apos;#job_detail &gt; dd.job-address.clearfix &gt; input[type=&quot;hidden&quot;]:nth-child(6)&apos;).text().replace(&apos;/&apos;, &apos;&apos;),  # 地点            &apos;place&apos;:doc1.find(&apos;#job_detail &gt; dd.job-address.clearfix &gt; div.work_addr&apos;).text(),  # 具体位置            &apos;required&apos;:doc1.find(&apos;div.position-content-l &gt; dd &gt; p:nth-child(1) &gt; span:nth-child(3)&apos;).text().replace(&apos;/&apos;, &apos;&apos;),  # 经验要求            &apos;education&apos;:doc1.find(&apos;div.position-content-l &gt; dd &gt; p:nth-child(1) &gt; span:nth-child(4)&apos;).text().replace(&apos;/&apos;, &apos;&apos;),  # 学历要求            &apos;job_nature&apos;:doc1.find(&apos;div.position-content-l &gt; dd &gt; p:nth-child(1) &gt; span:nth-child(5)&apos;).text().replace(&apos;/&apos;, &apos;&apos;),  # 工作性质            &apos;attract&apos;:doc1.find(&apos;#job_detail &gt; dd.job-advantage&apos;).text().replace(&apos;\n&apos;, &apos; &apos;),  # 工作诱惑            &apos;describe&apos;:doc1.find(&apos;#job_detail &gt; dd.job_bt&apos;).text().replace(&apos;\n&apos;, &apos; &apos;)  # 工作描述        }        print(infor)         if __name__ == &quot;__main__&quot;:    pages = 6  # 总的页面数，从网页第一面就可知了，6是测试用的数字页码    for i in range(1, pages + 1):        page_content(i)        time.sleep(20)</code></pre><blockquote><p>最后我选择将爬取的内容保存至一个<code>.txt</code>文件下。</p></blockquote><h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-05-06%20%E4%B8%8B%E5%8D%8810.27.19.png" alt=""></p><blockquote><p>运行之后的效果，有些爬取不了，明明源代码都没什么变化…</p></blockquote><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><ul><li><p>这个代码的模型并不能爬取页面上对应的全部内容，这个我也是有点疑惑。</p></li><li><p>有时会跳到需要登录的界面，重新来几次就行了，总有一次能爬取。</p></li></ul><p>有不懂的知识可参考：<a href="https://cuiqingcai.com/5630.html" target="_blank" rel="external">https://cuiqingcai.com/5630.html</a></p><blockquote><p>以及相关的模块的官网亦可。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;爬取拉勾网的最大障碍：&lt;strong&gt;普通模块难以实现翻页爬取。&lt;/strong&gt;自己加了参数&lt;code&gt;page&lt;/code&gt;，经过抓包查询之后也达不到我的理想要求。&lt;/p&gt;
&lt;p&gt;没办法了，只好用&lt;em&gt;selenium&lt;/em&gt;模块结合浏览器来实现边翻页边爬取了。&lt;/
      
    
    </summary>
    
      <category term="python爬虫" scheme="https://liujunjie11.github.io/categories/python%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="python爬虫" scheme="https://liujunjie11.github.io/tags/python%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法书籍资源共享</title>
    <link href="https://liujunjie11.github.io/2018/05/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%A6%E7%B1%8D%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB/"/>
    <id>https://liujunjie11.github.io/2018/05/04/数据结构与算法书籍资源共享/</id>
    <published>2018-05-04T11:15:05.000Z</published>
    <updated>2018-05-04T11:20:25.483Z</updated>
    
    <content type="html"><![CDATA[<ul><li>计算机程序设计艺术(卷1～卷四全)：</li></ul><blockquote><p><a href="https://pan.baidu.com/s/1922E16LZR0iXZHZQCgsbLg" target="_blank" rel="external">https://pan.baidu.com/s/1922E16LZR0iXZHZQCgsbLg</a></p></blockquote><ul><li>算法导论(第三版)：</li></ul><blockquote><p><a href="https://pan.baidu.com/s/1XqAeeJx803rcVCx7QMA62g" target="_blank" rel="external">https://pan.baidu.com/s/1XqAeeJx803rcVCx7QMA62g</a></p></blockquote><p>以上资源来于网络，感谢默默分享的人们！</p><p>还有一些其他的金典书籍，我都没怎么看啊..</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;计算机程序设计艺术(卷1～卷四全)：&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://pan.baidu.com/s/1922E16LZR0iXZHZQCgsbLg&quot; target=&quot;_blank&quot; rel=&quot;extern
      
    
    </summary>
    
      <category term="书籍" scheme="https://liujunjie11.github.io/categories/%E4%B9%A6%E7%B1%8D/"/>
    
    
      <category term="书籍" scheme="https://liujunjie11.github.io/tags/%E4%B9%A6%E7%B1%8D/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络知识总结</title>
    <link href="https://liujunjie11.github.io/2018/05/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    <id>https://liujunjie11.github.io/2018/05/02/计算机网络知识总结/</id>
    <published>2018-05-02T13:12:31.000Z</published>
    <updated>2018-05-07T07:34:32.090Z</updated>
    
    <content type="html"><![CDATA[<p>计算机网络也是计算机基础重要的一部分。</p><p>本来打算总结下关于计算机网络基础知识，发现下面的这些课件总结的已经非常好了，所以在此分享，我就不说多了…</p><blockquote><p>下载课件：<a href="https://pan.baidu.com/s/1uodpU6E8n050QyazgdLXVw" target="_blank" rel="external">https://pan.baidu.com/s/1uodpU6E8n050QyazgdLXVw</a></p></blockquote><ul><li>说明：</li></ul><p>课件来源：《数据通信与计算机网络》</p><p>还有以下这个：</p><blockquote><p>下载课件：<a href="https://pan.baidu.com/s/1oCHb3GkybHn7vI-cvMCJIA" target="_blank" rel="external">https://pan.baidu.com/s/1oCHb3GkybHn7vI-cvMCJIA</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;计算机网络也是计算机基础重要的一部分。&lt;/p&gt;
&lt;p&gt;本来打算总结下关于计算机网络基础知识，发现下面的这些课件总结的已经非常好了，所以在此分享，我就不说多了…&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;下载课件：&lt;a href=&quot;https://pan.baidu.com/s
      
    
    </summary>
    
      <category term="计算机网络" scheme="https://liujunjie11.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="https://liujunjie11.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>我对学习计算机基础的一些心得见解</title>
    <link href="https://liujunjie11.github.io/2018/04/29/%E6%88%91%E5%AF%B9%E5%AD%A6%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BF%83%E5%BE%97%E8%A7%81%E8%A7%A3/"/>
    <id>https://liujunjie11.github.io/2018/04/29/我对学习计算机基础的一些心得见解/</id>
    <published>2018-04-29T12:54:29.000Z</published>
    <updated>2018-04-29T13:26:28.269Z</updated>
    
    <content type="html"><![CDATA[<p>最近总是遇到了许多的瓶颈…即感觉认识的知道的太少了。</p><p>在前些天看到了一些关于<em>python</em>的优化内容之后，加上之前用<em>python</em>也有一段时间了，突然的感觉到一些基础细节才是最重要的，我意识到了<strong>这往往可能就是人与人技术之间的一个分水岭，也往往是突破瓶颈关键点，也往往能决定一个人技术的所在点。基础细节知识是能决定一个人能走多远的</strong></p><p>平时在写程序时不应满足于功能的实现，更加应当注意那些可优化的细节问题，就好比一个算法的时间复杂度与空间复杂度一样的，写的每一个程序(无论那种编程语言)均有可优化的最优解选择。在我平时因为涉及的数据规模不大，这种问题目前是看不出来的，如果运用到的是一个数据规模大的问题上，优化必然是重要的，不可或缺的。</p><p>平时想问题总是感觉能联想到的知识太少，回过头来看，发现自己对计算机的认识本来也不够全面(注意是全面！而非透彻！)。这往往也限制了我许多的想象，从而造成了我的瓶颈突出明显。</p><p>说了这么多，只是想说一个问题：<strong>计算机基础知识(包括编程基础知识)是能决定一个人技术的高度的。</strong>至少我现在就有这种感觉，写一个程序不应满足于功能的实现，更应探索最优解的选择。<strong>这往往就是技术<code>好</code>与<code>坏</code>的一个区分标准吧。</strong></p><p>关于如何学习以上说的基础知识，我有一些见解在此想要说明一下。</p><ul><li><p>知识尽量要了解全面，不能为了速度而一知半解的，那样只会浪费时间，最后还是什么都不知道。</p></li><li><p>有些知识可能会引起我们的好奇，想要进一步理解透彻(彻彻底底)，但是这其中却是有太多的知识链关联着的…这点我深有体会。如果顺着知识链步步了解，我们的确也能学习到许多的知识，但是最后会发现其实这些在我们实际需要中根本没有多大的作用，仅仅当时作为一种科普了，当然现在学习到的知识也是以后我们技术的一种铺垫，如果实在有兴趣就当我没说，兴趣是学习一种知识最好的引导。</p></li><li><p>有些是需要理解透彻的，有些(大部分)可能仅仅是需要了解一下就好的。</p></li><li><p>根据目前的需求来进行学习也是一种好的驱动力。</p></li><li><p>一些必要的基础知识是需要了解的，比如学习了计算机概论，那一般以后买电脑时就会有自己的一些见解了。学习了数据结构与算法基础之后，编程时就不会仅仅以达到目的而“不择手段”编写程序了，因为再学习了这些基础知识之后我们脑子里必然会有一些规则“约束”了。</p></li></ul><p>最后，我还是想说，对于底层的电路什么的那种我想我是不愿也是不情愿接触的…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近总是遇到了许多的瓶颈…即感觉认识的知道的太少了。&lt;/p&gt;
&lt;p&gt;在前些天看到了一些关于&lt;em&gt;python&lt;/em&gt;的优化内容之后，加上之前用&lt;em&gt;python&lt;/em&gt;也有一段时间了，突然的感觉到一些基础细节才是最重要的，我意识到了&lt;strong&gt;这往往可能就是人与
      
    
    </summary>
    
      <category term="学习笔记" scheme="https://liujunjie11.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="学习笔记" scheme="https://liujunjie11.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>python3爬虫与GUI：一个简易的搜索实用小工具</title>
    <link href="https://liujunjie11.github.io/2018/04/28/python3%E7%88%AC%E8%99%AB%E4%B8%8EGUI%EF%BC%9A%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93%E7%9A%84%E6%90%9C%E7%B4%A2%E5%AE%9E%E7%94%A8%E5%B0%8F%E5%B7%A5%E5%85%B7/"/>
    <id>https://liujunjie11.github.io/2018/04/28/python3爬虫与GUI：一个简易的搜索实用小工具/</id>
    <published>2018-04-28T02:31:30.000Z</published>
    <updated>2018-05-02T13:04:39.933Z</updated>
    
    <content type="html"><![CDATA[<p>平时在获取爬虫之后，会不满足于仅仅得到了结果，而是想经过一个交互式的界面来进一步的完善，获取更多的功能，从而可以更好的展示数据。</p><p>下面运用了<em>python</em>的<em>pyqt5</em>库来进行<em>GUI</em>的设计。</p><p>用<em>pyqt5</em>这个库实现简单的界面化有两种方法：</p><ul><li><p>编写代码(一般为几十行代码足够了)。</p></li><li><p>结合<em>QT Creator</em>来进行界面设计，加入信号与槽的机制，槽这一方面还是需要编写相应的几行代码。</p></li></ul><blockquote><p>下面一一进行简单的介绍。</p></blockquote><h2 id="代码编写方式"><a href="#代码编写方式" class="headerlink" title="代码编写方式"></a>代码编写方式</h2><p>假设我已经利用爬虫写出来了<em>百度百科</em>，<em>维基百科</em>的接口的代码程序，接下来仅仅需要设计好界面，再者之后利用好信号与槽的机制将接口代码与界面相连接即可完成一个简易的搜索实用小工具了。</p><p>在此简单理解一下信号与槽机制以及所谓的事件机制：<strong>比如我们有一个按钮，点击此按钮便弹出一个写有‘Hello’的窗口，点击到弹出新窗口的这一过程，有个响应的过程，我们可以理解为发送信号(点击按钮)，之后有弹出新窗口(响应),而这一系列过程包括弹出的内容我们可称之为事件。</strong></p><blockquote><p>关于学习<em>pyqt5</em>库的中文教程地址：<a href="https://maicss.gitbooks.io/pyqt5/content/事件和信号.html" target="_blank" rel="external">https://maicss.gitbooks.io/pyqt5/content/事件和信号.html</a></p></blockquote><p>从头开始看一下，之后再看这一篇大概就知道简单的交互式界面是如何生成的了。</p><p>简单描述一下思路：<strong>先设计布局好界面(包括定义好相关按钮的快捷键)，写入爬虫代码，信号与槽机制的连接设定，即完成了此次的任务。</strong></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code>import sysimport urllib.request  from bs4 import BeautifulSoupimport refrom urllib.parse import quote from PyQt5.QtWidgets import (QPushButton, QWidget, QLabel, QLineEdit, QTextEdit, QGridLayout, QApplication,    QComboBox)from PyQt5.QtCore import QCoreApplicationclass Example(QWidget):     def __init__(self):        &apos;&apos;&apos;        初始化        &apos;&apos;&apos;        super().__init__()        self.initUI()    def baidu_baike(self, entry):          &apos;&apos;&apos;        百度百科词条内容爬取代码        entry：词条        因为太懒了..所以爬取的代码没有自己写..        &apos;&apos;&apos;        url = &apos;https://baike.baidu.com/item/&apos; + urllib.parse.quote(entry)        html = urllib.request.urlopen(url)          content = html.read().decode(&apos;utf-8&apos;)        html.close()        # lxml器进行解析        soup = BeautifulSoup(content, &quot;lxml&quot;)          text = soup.find(&apos;div&apos;, class_=&quot;lemma-summary&quot;).children  # 簡介部分        intro_text = &apos;&apos;        # 数据爬取        for x in text:            word = re.sub(re.compile(r&quot;&lt;(.+?)&gt;&quot;), &apos;&apos;, str(x))            words = re.sub(re.compile(r&quot;\[(.+?)\]&quot;), &apos;&apos;, word)            intro_text += words        return intro_text  # 返回文本(str格式)    def intro_final(self, entry):          &apos;&apos;&apos;        异常处理        &apos;&apos;&apos;        try:            return self.baidu_baike(entry)        except AttributeError:            return &quot;词条定义不够清晰/词条目前未成立！&quot;    def initUI(self):        # GUI布局及控件放置        search_label = QLabel(&quot;请输入搜索词条：&quot;)        search_item = QLineEdit()        combo = QComboBox(self)        combo.addItem(&quot;百度百科&quot;)        combo.addItem(&quot;维基百科(不可用)&quot;)        btn1 = QPushButton(&quot;开始搜索&quot;, self)        # shortcut快捷键的设置        btn1.setShortcut(&apos;return&apos;)        btn2 = QPushButton(&quot;清空&quot;, self)        btn2.setShortcut(&apos;esc&apos;)        btn3 = QPushButton(&apos;退出&apos;, self)        btn3.setShortcut(&apos;command+q&apos;)        btn3.setShortcut(&apos;Ctrl+q&apos;)        btn3.clicked.connect(QCoreApplication.instance().quit)        search_result = QTextEdit()        grid = QGridLayout()        grid.setSpacing(5)        grid.addWidget(search_label, 1, 0)        grid.addWidget(btn3, 2, 1)        grid.addWidget(search_item, 2, 0)        grid.addWidget(btn1, 3, 0)        grid.addWidget(btn2, 3, 1)        grid.addWidget(search_result, 4, 0, 5 , 0)        self.setLayout(grid)        # 信号机制的设置，定义为一个方法作为反映的对象，这里很好理解        def search():            &apos;&apos;&apos;            搜索信号反映的响应            &apos;&apos;&apos;            search_result.setText(self.intro_final(search_item.text()))        btn1.clicked.connect(search)        def clear():            &apos;&apos;&apos;            清空信号反映的响应            &apos;&apos;&apos;            search_result.setText(&quot;&quot;)            search_item.setText(&quot;&quot;)        btn2.clicked.connect(clear)        # 设置窗口大小        self.setGeometry(500, 150, 600, 500)        self.setWindowTitle(&quot;搜索引擎GUI&quot;)        self.show()if __name__ == &quot;__main__&quot;:    app = QApplication(sys.argv)    ex = Example()    sys.exit(app.exec_())</code></pre><blockquote><p>以上有不懂的地方均可在<a href="https://maicss.gitbooks.io/pyqt5/content/hello_world.html" target="_blank" rel="external">pyqt5中文教程</a>中找到思路。</p></blockquote><h3 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h3><p><img src="http://owudg3xs2.bkt.clouddn.com/5%E6%9C%88-02-2018%2019-31-44.gif" alt=""></p><h2 id="结合QT-Creator的界面设计"><a href="#结合QT-Creator的界面设计" class="headerlink" title="结合QT Creator的界面设计"></a>结合<em>QT Creator</em>的界面设计</h2><p>结合<em>QT Creator</em>的界面，我们肯定会想到：那当我们进行界面设计完成之后，就算是转化为<code>.py</code>的<em>python</em>脚本，那我们又该如何定义信号与槽的机制以及事件的机制呢？</p><p>下面的解说就是解决这个疑惑的。</p><p>第一步当然是去官网下载好软件了。</p><blockquote><p>参考此篇文章：<a href="https://blog.csdn.net/win_turn/article/details/50465127" target="_blank" rel="external">https://blog.csdn.net/win_turn/article/details/50465127</a></p></blockquote><p><strong>话不多说了，下载的时候其实有一个坑，即要记得下载有调试的那个版本，否则在设计界面时无法得到运行。</strong></p><h3 id="创建文件并且设计"><a href="#创建文件并且设计" class="headerlink" title="创建文件并且设计"></a>创建文件并且设计</h3><p>在这里仅仅是为了达到解说的目的所以简单设计一下就好，说说设计下面的思路：<strong>定义一个按钮(名为确定)，一个输入框，一个输出框，达到的目的是从输入框输入文字，按下确定按钮，输出框中输出与输入框一致的内容。</strong></p><p>创建新的文件过程如图所示：</p><p><img src="http://owudg3xs2.bkt.clouddn.com/5%E6%9C%88-02-2018%2019-42-52.gif" alt=""></p><blockquote><p>总之就是如上图一路点击下去即可。</p></blockquote><p>之后会发现有这样的界面出现：</p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-05-02%20%E4%B8%8B%E5%8D%887.43.59.png" alt=""></p><p>这个<em>mainwindow.ui</em>不说就能轻易知道就是用它来进行界面设计的。双击它即可进入设计界面(如图1)，当然可选择<em>Qt Designer</em>进行设计(对其右键可弹出选项，如图2)。</p><ul><li>图1</li></ul><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-05-02%20%E4%B8%8B%E5%8D%887.49.34.png" alt=""></p><ul><li>图2</li></ul><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-05-02%20%E4%B8%8B%E5%8D%887.47.52.png" alt=""></p><p>为了尽快达到写完的目的，我简单的来进行一下示范…</p><p>先在界面中，设计一个按钮：</p><p><img src="http://owudg3xs2.bkt.clouddn.com/5%E6%9C%88-02-2018%2020-15-04.gif" alt=""></p><p>然后添加下面两种组件：</p><p><img src="http://owudg3xs2.bkt.clouddn.com/5%E6%9C%88-02-2018%2020-15-15.gif" alt=""></p><p><img src="http://owudg3xs2.bkt.clouddn.com/5%E6%9C%88-02-2018%2020-15-38.gif" alt=""></p><h3 id="定义信号与槽"><a href="#定义信号与槽" class="headerlink" title="定义信号与槽"></a>定义信号与槽</h3><p>在这之前先将设计好的转为<code>.py</code><em>python</em>脚本文件。<code>cd</code>到相应的文件的目录下(即上面的<em>mainwindow.ui</em>所在的目录。注意，此步非常重要！)利用命令行：<code>pyuic5 -o  mainwindow.py mainwindow.ui</code></p><blockquote><p>关于此命令行具体可参考：<a href="https://blog.csdn.net/yingmutongxue/article/details/8487348" target="_blank" rel="external">https://blog.csdn.net/yingmutongxue/article/details/8487348</a><br><strong>(在此需要注意的是，我使用的是<em>pyqt5</em>，所以对应的命令行应当是pyuic5开头，若是<em>pyqt4</em>，则为pyuic4开头了。)</strong></p></blockquote><p>这样在本目录下即可找到转为后的<em>python</em>文件了。</p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-05-02%20%E4%B8%8B%E5%8D%889.04.04.png" alt=""></p><p>再者，我们需要在这个文件实现上面说的思路，即相应的信号与槽机制的代码。因为时间问题，就不在此实现了(是真的写不下去了…)。</p><p>在完成之后，我们直接将此调入<em>eclipse</em>的工程目录下(我用的是<em>eclipse</em>)，之后我们直接调用此文件即可。</p><pre><code>import sysfrom PyQt5.QtWidgets import QApplication , QMainWindowfrom mainwindow import *if __name__ == &apos;__main__&apos;:#     主函数    app = QtWidgets.QApplication(sys.argv)    MainWindow = QtWidgets.QMainWindow()    ui = Ui_MainWindow()    ui.setupUi(MainWindow)    MainWindow.show()    sys.exit(app.exec_())</code></pre><blockquote><p>这样即可完成结合软件设计界面，并在<em>python</em>中运行的一条龙服务了…</p><p>其实在<em>Qt creator</em>中就有信号与槽机制以及快捷键的设置了，这个可参考：<a href="https://wizardforcel.gitbooks.io/qt-beginning/content/60.html" target="_blank" rel="external">https://wizardforcel.gitbooks.io/qt-beginning/content/60.html</a><br>(<strong>全面介绍了</strong>)</p></blockquote><p>简单认识一下设计界面上的那些按钮功能(网上的图，出处忘记了…)</p><p><img src="http://owudg3xs2.bkt.clouddn.com/d.png" alt=""></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>唉..突然感觉直接写代码都还要方便多了…结合软件设计搞的时间浪费的还要多…</p><ul><li>参考：</li></ul><blockquote><p><a href="https://blog.csdn.net/jclian91/article/details/77407723" target="_blank" rel="external">https://blog.csdn.net/jclian91/article/details/77407723</a></p><p><a href="https://maicss.gitbooks.io/pyqt5/content/介绍.html" target="_blank" rel="external">https://maicss.gitbooks.io/pyqt5/content/介绍.html</a><br><strong>(以上所有内容的拼接均可根据此pyqt5库中文教程来进行理解学习，还是一句话，要多动脑多动手实践。)</strong></p><p><a href="https://cuiqingcai.com/5551.html" target="_blank" rel="external">https://cuiqingcai.com/5551.html</a><br><strong>（pyquery的使用教程）</strong></p></blockquote><ul><li>关于将<em>python</em>文件打包生成app的工具库：</li></ul><blockquote><p>py2app:.py –&gt; .dmg</p><p>py2exe:.py –&gt; .exe </p></blockquote><ul><li>关于<em>css选择器</em>等其他内容的快速获取(基于<em>chrome</em>浏览器)：</li></ul><p><img src="http://owudg3xs2.bkt.clouddn.com/5%E6%9C%88-02-2018%2019-33-40.gif" alt=""></p><blockquote><p>看上方的动图，选择完之后粘贴即可得出对应的内容(可适当删除中间字段而不影响达到目的)，当然最好学会一点相关的内容，其实也不难上手。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;平时在获取爬虫之后，会不满足于仅仅得到了结果，而是想经过一个交互式的界面来进一步的完善，获取更多的功能，从而可以更好的展示数据。&lt;/p&gt;
&lt;p&gt;下面运用了&lt;em&gt;python&lt;/em&gt;的&lt;em&gt;pyqt5&lt;/em&gt;库来进行&lt;em&gt;GUI&lt;/em&gt;的设计。&lt;/p&gt;
&lt;p&gt;用&lt;
      
    
    </summary>
    
      <category term="python-GUI学习" scheme="https://liujunjie11.github.io/categories/python-GUI%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="python-GUI学习" scheme="https://liujunjie11.github.io/tags/python-GUI%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
</feed>
