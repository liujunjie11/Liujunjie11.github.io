<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LXiHa`Notes</title>
  
  <subtitle>The House Belong to Love and Freedom.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://liujunjie11.github.io/"/>
  <updated>2018-06-23T12:25:08.209Z</updated>
  <id>https://liujunjie11.github.io/</id>
  
  <author>
    <name>刘俊</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>在Jupyter Notebook中安装多种语言内核</title>
    <link href="https://liujunjie11.github.io/2018/06/04/%E5%9C%A8Jupyter-Notebook%E4%B8%AD%E5%AE%89%E8%A3%85%E5%A4%9A%E7%A7%8D%E8%AF%AD%E8%A8%80%E5%86%85%E6%A0%B8/"/>
    <id>https://liujunjie11.github.io/2018/06/04/在Jupyter-Notebook中安装多种语言内核/</id>
    <published>2018-06-04T12:33:26.000Z</published>
    <updated>2018-06-23T12:25:08.209Z</updated>
    
    <content type="html"><![CDATA[<p><em>Jupyter Notrbook</em>有一个好的编译界面，输出内容也一目了然，让人感觉像是发现了一个新大陆..</p><p>下面来说说如何在其中安装多种语言内核。</p><blockquote><p>支持的语言内核可查：<a href="https://github.com/jupyter/jupyter/wiki/Jupyter-kernels" target="_blank" rel="external">https://github.com/jupyter/jupyter/wiki/Jupyter-kernels</a></p></blockquote><h1 id="安装python2内核"><a href="#安装python2内核" class="headerlink" title="安装python2内核"></a>安装<em>python2</em>内核</h1><p>因为我的默认已经安装了<em>python3</em>，所以就在此讲解一下如何安装<em>python2</em>内核。</p><ul><li>在<em>notebook</em>为开启情况下，依次输入命令：</li></ul><p><code>pip install ipykernel</code></p><p><code>python2 -m ipykernel install</code></p><blockquote><p>参考：<a href="https://www.jianshu.com/p/8b90c2f12856" target="_blank" rel="external">https://www.jianshu.com/p/8b90c2f12856</a></p></blockquote><h1 id="安装R内核"><a href="#安装R内核" class="headerlink" title="安装R内核"></a>安装<em>R</em>内核</h1><p>上面的文章也有相关的介绍了。</p><p>但是在<em>anaconda</em>中一行命令即可完成下载：</p><p><code>conda install r-essential</code></p><p>或者是</p><p><code>conda  install -c r r-essentials</code></p><blockquote><p>参考：<a href="https://kangliping.wordpress.com/2017/09/15/anaconda_r/" target="_blank" rel="external">https://kangliping.wordpress.com/2017/09/15/anaconda_r/</a></p></blockquote><p><strong>下载第一次可能有几个包不成功，我经过重新输入命令行之后再次下载得到了解决。</strong></p><h1 id="安装bash内核"><a href="#安装bash内核" class="headerlink" title="安装bash内核"></a>安装<em>bash</em>内核</h1><p>新开一个终端，依次使用命令行：</p><p><code>pip install bash_kernel</code></p><p><code>python -m bash_kernel.install</code></p><blockquote><p>参考：<a href="https://blog.csdn.net/SA14023053/article/details/52053649" target="_blank" rel="external">https://blog.csdn.net/SA14023053/article/details/52053649</a></p></blockquote><h1 id="安装基于Scala的spark应用"><a href="#安装基于Scala的spark应用" class="headerlink" title="安装基于Scala的spark应用"></a>安装基于<em>Scala</em>的<em>spark</em>应用</h1><blockquote><p>具体移步：<a href="https://blog.csdn.net/Xmo_jiao/article/details/72674687" target="_blank" rel="external">https://blog.csdn.net/Xmo_jiao/article/details/72674687</a></p></blockquote><p>其中需要的内容在<em>spark</em>启动页面中都能找到。没办法，内容太多，又懒得写..</p><p><strong>但是需要注意的每次均要启动spark再进行进一步的编程操作。在已经安装<em>spark</em>的前提下输入命令行：<code>spark-shell</code>启动spark。</strong></p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>输入以下命令行查看已安装的内核列表：</p><p><code>jupyter kernelspec list</code></p><p>先写这么多，以后有需要再进行补充。</p><p><strong>关于在下载完之后发现启动内核失败(dead kernel的情况)</strong></p><p>可参考以下链接：</p><ol><li><p><a href="https://blog.csdn.net/liangdagongjue/article/details/79533538" target="_blank" rel="external">https://blog.csdn.net/liangdagongjue/article/details/79533538</a></p></li><li><p><a href="https://blog.csdn.net/wobeatit/article/details/78885339" target="_blank" rel="external">https://blog.csdn.net/wobeatit/article/details/78885339</a></p></li></ol><blockquote><p>即实际上就是我将<em>Anaconda</em>升级之后出现了以上的<code>dead kernel</code>的情况，后来发现真的是软件更新没有跟上的问题，将<em>notebook</em>之类的一并更新一遍即可解决。</p></blockquote><p>实际使用命令行如下：</p><p><code>conda upgrade notebook</code></p><p><code>conda upgrade jupyter</code></p><p><code>conda update mkl</code></p><p>一并更新之后重新打开会发现一切都可以正常使用了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;Jupyter Notrbook&lt;/em&gt;有一个好的编译界面，输出内容也一目了然，让人感觉像是发现了一个新大陆..&lt;/p&gt;
&lt;p&gt;下面来说说如何在其中安装多种语言内核。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;支持的语言内核可查：&lt;a href=&quot;https://g
      
    
    </summary>
    
      <category term="Notebook" scheme="https://liujunjie11.github.io/categories/Notebook/"/>
    
    
      <category term="Notebook" scheme="https://liujunjie11.github.io/tags/Notebook/"/>
    
  </entry>
  
  <entry>
    <title>Mac下载2018CAD破解</title>
    <link href="https://liujunjie11.github.io/2018/05/29/Mac%E4%B8%8B%E8%BD%BD2018CAD%E7%A0%B4%E8%A7%A3/"/>
    <id>https://liujunjie11.github.io/2018/05/29/Mac下载2018CAD破解/</id>
    <published>2018-05-29T11:25:20.000Z</published>
    <updated>2018-05-29T11:30:49.404Z</updated>
    
    <content type="html"><![CDATA[<p>最近因为选修课要用到<em>CAD</em>，用的恰好是<em>Mac book</em>，就在此记录</p><h1 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h1><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>先去官网下载好2018的试用版：<a href="https://www.autodesk.com.cn/products/autocad/free-trial#0" target="_blank" rel="external">https://www.autodesk.com.cn/products/autocad/free-trial#0</a></p><blockquote><p><strong>需要注意的是：选择企业注册就好，不然很麻烦…</strong></p></blockquote><h1 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h1><h2 id="参考以下文章即可"><a href="#参考以下文章即可" class="headerlink" title="参考以下文章即可.."></a>参考以下文章即可..</h2><ul><li>参考：<a href="http://www.anyxz.com/index.php/2902.html" target="_blank" rel="external">http://www.anyxz.com/index.php/2902.html</a></li></ul><blockquote><p>因为我只是完成作业就卸载了..所以一个试用版就足够..</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近因为选修课要用到&lt;em&gt;CAD&lt;/em&gt;，用的恰好是&lt;em&gt;Mac book&lt;/em&gt;，就在此记录&lt;/p&gt;
&lt;h1 id=&quot;第一步&quot;&gt;&lt;a href=&quot;#第一步&quot; class=&quot;headerlink&quot; title=&quot;第一步&quot;&gt;&lt;/a&gt;第一步&lt;/h1&gt;&lt;h2 id=&quot;下载
      
    
    </summary>
    
      <category term="Mac软件教程" scheme="https://liujunjie11.github.io/categories/Mac%E8%BD%AF%E4%BB%B6%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="Mac软件教程" scheme="https://liujunjie11.github.io/tags/Mac%E8%BD%AF%E4%BB%B6%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>理解常用传统算法的合集资源总结</title>
    <link href="https://liujunjie11.github.io/2018/05/10/%E7%90%86%E8%A7%A3%E5%B8%B8%E7%94%A8%E4%BC%A0%E7%BB%9F%E7%AE%97%E6%B3%95%E7%9A%84%E5%90%88%E9%9B%86%E8%B5%84%E6%BA%90%E6%80%BB%E7%BB%93/"/>
    <id>https://liujunjie11.github.io/2018/05/10/理解常用传统算法的合集资源总结/</id>
    <published>2018-05-10T13:13:35.000Z</published>
    <updated>2018-05-14T09:22:26.636Z</updated>
    
    <content type="html"><![CDATA[<p>平时学习算法是为了理解其中的原理以及思想，另外还有各种算法之间的比较以及应用场景。下面是一些常用常见的传统算法，我在<em>YouTube</em>上找了一些可简单理解其原理思想的视频，真正的做到通俗易懂！</p><p>另外关于算法的各种时间复杂度以及空间复杂度均在此小列出来。关于以下各种算法的应用场景实际上还是需要自己去结合这些算法的思想去选择的，就不在此多说了。</p><blockquote><p>参考了许多的网页，包括<em>YouTube</em>，<em>维基百科</em>等灯，也从中学习到了许多，就是在此汇总一下。<strong>另外参考的网页就不一一列出来了，感谢他们/她们的付出与分享。</strong></p></blockquote><p><strong>主要参考：</strong></p><ul><li><p><a href="http://wiki.jikexueyuan.com/project/data-structure-sorting/insertion-sort.html" target="_blank" rel="external">http://wiki.jikexueyuan.com/project/data-structure-sorting/insertion-sort.html</a></p></li><li><p><a href="https://github.com/francistao/LearningNotes/blob/master/Part3/Algorithm/Sort/面试中的%2010%20大排序算法总结.md" target="_blank" rel="external">https://github.com/francistao/LearningNotes/blob/master/Part3/Algorithm/Sort/面试中的%2010%20大排序算法总结.md</a></p></li><li><p>常用排序算法总结(一):<a href="http://www.cnblogs.com/eniac12/p/5329396.html" target="_blank" rel="external">http://www.cnblogs.com/eniac12/p/5329396.html</a></p></li><li><p>常用排序算法总结(二):<a href="http://www.cnblogs.com/eniac12/p/5332117.html" target="_blank" rel="external">http://www.cnblogs.com/eniac12/p/5332117.html</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;平时学习算法是为了理解其中的原理以及思想，另外还有各种算法之间的比较以及应用场景。下面是一些常用常见的传统算法，我在&lt;em&gt;YouTube&lt;/em&gt;上找了一些可简单理解其原理思想的视频，真正的做到通俗易懂！&lt;/p&gt;
&lt;p&gt;另外关于算法的各种时间复杂度以及空间复杂度均在此小列
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://liujunjie11.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="https://liujunjie11.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>python3爬虫与GUI:基于有道词典的词典小工具</title>
    <link href="https://liujunjie11.github.io/2018/05/07/python3%E7%88%AC%E8%99%AB%E4%B8%8EGUI-%E5%9F%BA%E4%BA%8E%E6%9C%89%E9%81%93%E8%AF%8D%E5%85%B8%E7%9A%84%E8%AF%8D%E5%85%B8%E5%B0%8F%E5%B7%A5%E5%85%B7/"/>
    <id>https://liujunjie11.github.io/2018/05/07/python3爬虫与GUI-基于有道词典的词典小工具/</id>
    <published>2018-05-07T10:48:58.000Z</published>
    <updated>2018-05-08T08:49:10.828Z</updated>
    
    <content type="html"><![CDATA[<p>最近看到了一篇文章，一个基于<em>有道</em>的词典小工具，心血来潮，想着自己来写一个试试看。</p><blockquote><p>下面我将用<em>python</em>完成接口的对接(即进行抓包)，并且用<em>pyQT5</em>实现对应的GUI界面。接下来就是事件机制的编写了，这样任务就完成了。</p></blockquote><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>在分析的过程中需要分析网页中的<em>JS</em>代码，因为有道现在使用加密算法来进行翻译结果的加密了。下面一一进行简单的说明。</p><p>首先用<em>Chrome浏览器</em>打开<a href="http://fanyi.youdao.com/" target="_blank" rel="external">有道在线翻译页面</a>，随便输入一个中文，会自动检测翻译成英文。(在我们已经都知道有道现在是加密的情况下我就不废话太多了，下面直接挑重点的说。)打开其自带的开发者工具查看到相关的包信息：</p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-05-08%20%E4%B8%8B%E5%8D%884.17.22.png" alt=""></p><blockquote><p>如果多翻译试几次翻译会发现上图所指的两个参数是持续变化的，还有一个<code>i</code>是输入的词，这个是在正常不过的，没什么疑义。</p></blockquote><h2 id="找到相应的JS整体代码"><a href="#找到相应的JS整体代码" class="headerlink" title="找到相应的JS整体代码"></a>找到相应的JS整体代码</h2><p>为了知道加密算法的过程以及整个流程是怎么一回事，找到网页的整体<em>JS</em>代码是唯一的选择。</p><p>先借助<em>火狐浏览器</em>分析翻译的接口，可快速的发现<em>JS</em>代码的所在处：</p><p><img src="http://owudg3xs2.bkt.clouddn.com/5%E6%9C%88-08-2018%2016-32-38.gif" alt=""></p><p>知道了<em>JS</em>文件的所在处，我们可在<em>Chrome浏览器</em>下找到这个地址：</p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-05-08%20%E4%B8%8B%E5%8D%884.20.45.png" alt=""></p><p>新建标签页打开：</p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-05-08%20%E4%B8%8B%E5%8D%884.21.11.png" alt=""></p><blockquote><p>发现这是一个混淆的<em>JS</em>代码，需要进行格式化才可知道其庐山真面目！<br>推荐两个反混淆的网站：<br><a href="http://tool.oschina.net/codeformat/js" target="_blank" rel="external">http://tool.oschina.net/codeformat/js</a> ，<a href="http://www.bm8.com.cn/jsConfusion/" target="_blank" rel="external">http://www.bm8.com.cn/jsConfusion/</a></p></blockquote><p>将混淆的代码复制粘贴在以上任意的一个网站，选择点击格式化之后即可得最终正解代码，之后为了查找关键词，我将这些代码编入一个文件中(<em>Mac</em>直接用文本编辑创建新文件即可。)：</p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-05-08%20%E4%B8%8B%E5%8D%884.22.49.png" alt=""></p><blockquote><p>格式化之后的JS代码一览。</p></blockquote><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-05-08%20%E4%B8%8B%E5%8D%884.23.13.png" alt=""></p><blockquote><p>之后查找关键词<code>salt</code>，找到对应上方的所指的参数位置。其中的乱码不用管，对分析代码没什么影响。</p></blockquote><h2 id="分析内容过程"><a href="#分析内容过程" class="headerlink" title="分析内容过程"></a>分析内容过程</h2><p>分析了一下之后，在<em>Chrome浏览器</em>中运行一下相关的代码，然后进入<a href="http://tool.chinaz.com/Tools/unixtime.aspx" target="_blank" rel="external">关于时间戳转换的网站</a>进行简单的转换，会发现这是一个有关时间戳的随机生成的一串数字：</p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-05-08%20%E4%B8%8B%E5%8D%884.23.13.png" alt=""></p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-05-08%20%E4%B8%8B%E5%8D%884.23.42.png" alt=""></p><blockquote><p>结合上下文(即<code>salt</code>关键词的上下一点范围即可)，发现有<em>md5</em>算法的字样出现了。</p></blockquote><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-05-08%20%E4%B8%8B%E5%8D%884.27.05.png" alt=""></p><blockquote><p>代码中关键的相关的内容。之后我们会用<em>python</em>来模拟这些代码来进行相关参数的输出。</p></blockquote><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-05-08%20%E4%B8%8B%E5%8D%884.29.07.png" alt=""></p><blockquote><p>用<em>Chrome</em>试着运行一下。</p></blockquote><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-05-08%20%E4%B8%8B%E5%8D%884.30.43.png" alt=""></p><blockquote><p>将运行之后的数字填入转换得出结果。</p></blockquote><p>在得知了两个随着翻译变化的关键词之一<code>salt</code>的生成原理之后，再来看看最后一个突破点，即找到关键词<code>sign</code>的生成原理，在这之后利用<em>python</em>模仿运行生成再代人相关的参数即可完成需要的翻译结果的输出。</p><p>其实往上看一点点就能发现诀窍了：</p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-05-08%20%E4%B8%8B%E5%8D%884.23.42.png" alt=""></p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-05-08%20%E4%B8%8B%E5%8D%884.31.13.png" alt=""></p><blockquote><p>结合<em>md5算法</em>以及必要的几个参数即可得出<code>sign</code>的生成值。</p></blockquote><p>这样一来思路就都清晰明了了，仅仅需要代码的实现了。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>以下代码已经套上了结合<em>pyQt5</em>开发出来了GUI的整体代码。</p><blockquote><p>关于<em>pyQt5</em>不清楚可参考我之前的相关博文，或者是利用好搜索引擎。</p></blockquote><pre><code>&apos;&apos;&apos;Created on 2018年5月8日@author: junjieliu&apos;&apos;&apos;&quot;&quot;&quot;函数目标：基于有道的GUI搜索小工具编写时间：2018-5-08&quot;&quot;&quot;import time import requestsimport hashlibimport randomimport jsonimport sysfrom PyQt5.QtCore import QCoreApplicationfrom PyQt5.QtWidgets import (QPushButton, QWidget, QLabel, QLineEdit, QTextEdit, QGridLayout, QApplication,    QComboBox)class Example(QWidget):    def __init__(self):        super().__init__()        self.initUI()    def save_translateResult(self, word):        &quot;&quot;&quot;        本函数用于翻译结果的返回。        &quot;&quot;&quot;        r = str(int(time.time() * 1000 + random.randint(1, 10)))  # 模仿JS代码的仿写        S = &apos;fanyideskweb&apos;        n = word        D = &quot;ebSeFb%=XZ%T[KZ)c(sy!&quot;  # 在完整的JS代码中可找到        o = hashlib.md5((S + n + str(r) + D).encode(&apos;utf-8&apos;)).hexdigest()        data = {            &apos;i&apos;: word,            &apos;from&apos;: &apos;AUTO&apos;,            &apos;to&apos;: &apos;AUTO&apos;,            &apos;smartresult&apos;: &apos;dict&apos;,            &apos;client&apos;: S,            &apos;salt&apos;: r,            &apos;sign&apos;: o,            &apos;doctype&apos;: &apos;json&apos;,            &apos;version&apos;: &apos;2.1&apos;,            &apos;keyfrom&apos;: &apos;fanyi.web&apos;,            &apos;action&apos;: &apos;FY_BY_REALTIME&apos;,            &apos;typoResult&apos;: &apos;false&apos;        }        url = &apos;http://fanyi.youdao.com/translate_o?smartresult=dict&amp;smartresult=rule&apos;        # 在代理中需要加入cookies信息，否则会出现代码错误信息的返回        header = {            &apos;Cookie&apos;: &apos;OUTFOX_SEARCH_USER_ID=; _ntes_nnid=25aff2b1480f17471ca1585f6f2f4293,1512024136653;  JSESSIONID=aaa3TFIg-JJJN4xEog6mw; ___rl__test__cookies=1525691300664&apos;,            &apos;Referer&apos;: &apos;http://fanyi.youdao.com/&apos;,            &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.139 Safari/537.36&apos;        }        response = requests.post(url=url, headers=header, data=data)        response.encoding = &apos;utf-8&apos;        translateResult = json.loads(response.text)[&quot;translateResult&quot;][0][0][&apos;tgt&apos;]        return translateResult    def take_test(self, word):        &quot;&quot;&quot;        本函数用于输出测试。        &quot;&quot;&quot;        try:            return self.save_translateResult(word)        except AttributeError:            return &quot;输入点有误/输出出现问题！！&quot;    def initUI(self):        # 组件添加        combo = QComboBox(self)        combo.addItem(&apos;有道词典&apos;)        label = QLabel(&quot;请输入:&quot;)        line = QLineEdit()        button_1 = QPushButton(&apos;开始翻译&apos;, self)        button_2 = QPushButton(&apos;退出&apos;, self)        button_3 = QPushButton(&apos;清空&apos;, self)        result = QTextEdit()        # 布局设置        grip = QGridLayout()        grip.setSpacing(4)        grip.addWidget(label, 1, 0)        grip.addWidget(line, 2, 0)        grip.addWidget(button_3, 2, 1)        grip.addWidget(button_1, 3, 0)        grip.addWidget(button_2, 3, 1)        grip.addWidget(result, 4, 0)        self.setLayout(grip)        combo.move(500, 0)        # 基于Macbook设置基本的快捷键以及推出程序的信号槽        button_1.setShortcut(&apos;return&apos;)        button_2.setShortcut(&apos;command+q&apos;)        button_2.clicked.connect(QCoreApplication.instance().quit)        button_3.setShortcut(&apos;esc&apos;)        def translate():            &quot;&quot;&quot;            本函数用于返回翻译按钮之后的结果输出！            &quot;&quot;&quot;            result.setText(self.take_test(line.text()))        button_1.clicked.connect(translate)        def clear():            &quot;&quot;&quot;            本函数用于输入输出框的清空！            &quot;&quot;&quot;            line.setText(&quot;&quot;)            result.setText(&quot;&quot;)        button_3.clicked.connect(clear)        # 设置窗口大小        self.setGeometry(500, 150, 600, 500)        self.setWindowTitle(&quot;有道翻译小工具&quot;)        self.show()if __name__ == &quot;__main__&quot;:    app = QApplication(sys.argv)    ex = Example()    sys.exit(app.exec_())</code></pre><blockquote><p><strong>上面的<em>cookies</em>值是必须要的！否则会出现错误，当然，在上面的代码我的<em>cookies</em>数值我进行了更改，如果需要测试运行，可加上自己浏览器上有道在线翻译的<em>cookies</em>。</strong></p></blockquote><p>运行演示：</p><p><img src="http://owudg3xs2.bkt.clouddn.com/5%E6%9C%88-08-2018%2016-32-56.gif" alt=""></p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><ul><li>代码中的模块可参考：</li></ul><p><em>1.</em> JavaScript parseInt() 函数：<a href="http://www.w3school.com.cn/js/jsref_parseInt.asp" target="_blank" rel="external">http://www.w3school.com.cn/js/jsref_parseInt.asp</a></p><p><em>2.</em> time.time()：返回当前时间的时间戳。：<a href="http://qinxuye.me/article/details-about-time-module-in-python/" target="_blank" rel="external">http://qinxuye.me/article/details-about-time-module-in-python/</a></p><p><em>3.</em> random.randint：<a href="https://www.cnblogs.com/yd1227/archive/2011/03/18/1988015.html" target="_blank" rel="external">https://www.cnblogs.com/yd1227/archive/2011/03/18/1988015.html</a></p><p><em>4.</em> hashlib:<a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014319556588648dd1fb0047a34d0c945ee33e8f4c90cc000" target="_blank" rel="external">https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014319556588648dd1fb0047a34d0c945ee33e8f4c90cc000</a></p><blockquote><p>其他的自行查找。特别是<em>pyQt5</em>这个库，可查看我之前写的文章作为参考：<a href="https://liujunjie11.github.io/2018/04/28/python3爬虫与GUI：一个简易的搜索实用小工具/#more">https://liujunjie11.github.io/2018/04/28/python3爬虫与GUI：一个简易的搜索实用小工具/#more</a></p></blockquote><ul><li>参考：</li></ul><p><em>1.</em>  <a href="http://study.163.com/course/courseLearn.htm?courseId=1004108008#/learn/video?lessonId=1047998193&amp;courseId=1004108008" target="_blank" rel="external">http://study.163.com/course/courseLearn.htm?courseId=1004108008#/learn/video?lessonId=1047998193&amp;courseId=1004108008</a></p><p><em>2.</em>  <a href="https://cuiqingcai.com/5024.html" target="_blank" rel="external">https://cuiqingcai.com/5024.html</a></p><p><em>3.</em>  <a href="https://blog.csdn.net/karmacode/article/details/79145728" target="_blank" rel="external">https://blog.csdn.net/karmacode/article/details/79145728</a></p><p><em>4.</em>  <a href="https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014319556588648dd1fb0047a34d0c945ee33e8f4c90cc000" target="_blank" rel="external">https://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/0014319556588648dd1fb0047a34d0c945ee33e8f4c90cc000</a></p><p><em>5.</em>  <a href="http://qinxuye.me/article/details-about-time-module-in-python/" target="_blank" rel="external">http://qinxuye.me/article/details-about-time-module-in-python/</a></p><p><em>6.</em>  <a href="https://www.cnblogs.com/yd1227/archive/2011/03/18/1988015.html" target="_blank" rel="external">https://www.cnblogs.com/yd1227/archive/2011/03/18/1988015.html</a></p><p>关于<em>python</em>的加密算法以及加密原理：</p><p><em>1.</em>  <a href="https://www.oudahe.com/p/python/z545/" target="_blank" rel="external">https://www.oudahe.com/p/python/z545/</a></p><p><em>2.</em>  <a href="https://www.oudahe.com/p/python/z545/" target="_blank" rel="external">https://www.oudahe.com/p/python/z545/</a></p><blockquote><p>最后不懂的模块知识可利用好搜索引擎。</p></blockquote><p>实际上也参考了我自己的文章：</p><blockquote><p><a href="https://liujunjie11.github.io/2018/04/28/python3爬虫与GUI：一个简易的搜索实用小工具/#more">https://liujunjie11.github.io/2018/04/28/python3爬虫与GUI：一个简易的搜索实用小工具/#more</a></p></blockquote><p>以及<em>pyqt5</em>的官网教程：</p><blockquote><p><a href="https://maicss.gitbooks.io/pyqt5/content/事件和信号.html" target="_blank" rel="external">https://maicss.gitbooks.io/pyqt5/content/事件和信号.html</a></p></blockquote><ul><li>关于将python文件打包生成app的工具库：</li></ul><blockquote><p><strong>py2app:.py –&gt; .dmg</strong></p><p><strong>py2exe:.py –&gt; .exe</strong></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近看到了一篇文章，一个基于&lt;em&gt;有道&lt;/em&gt;的词典小工具，心血来潮，想着自己来写一个试试看。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;下面我将用&lt;em&gt;python&lt;/em&gt;完成接口的对接(即进行抓包)，并且用&lt;em&gt;pyQT5&lt;/em&gt;实现对应的GUI界面。接下来就
      
    
    </summary>
    
      <category term="python爬虫与GUI" scheme="https://liujunjie11.github.io/categories/python%E7%88%AC%E8%99%AB%E4%B8%8EGUI/"/>
    
    
      <category term="python爬虫与GUI" scheme="https://liujunjie11.github.io/tags/python%E7%88%AC%E8%99%AB%E4%B8%8EGUI/"/>
    
  </entry>
  
  <entry>
    <title>(转)五大常用算法总结</title>
    <link href="https://liujunjie11.github.io/2018/05/07/%E8%BD%AC-%E4%BA%94%E5%A4%A7%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>https://liujunjie11.github.io/2018/05/07/转-五大常用算法总结/</id>
    <published>2018-05-07T04:22:27.000Z</published>
    <updated>2018-05-07T07:30:31.485Z</updated>
    
    <content type="html"><![CDATA[<p>本文转自：</p><blockquote><p><strong>博客园：<a href="http://www.cnblogs.com/steven_oyj/archive/2010/05/22/1741370.html" target="_blank" rel="external">http://www.cnblogs.com/steven_oyj/archive/2010/05/22/1741370.html</a></strong><br><strong>作者：红脸书生</strong></p></blockquote><hr><h1 id="分治算法"><a href="#分治算法" class="headerlink" title="分治算法"></a>分治算法</h1><h2 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><p>   在计算机科学中，分治法是一种很重要的算法。字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。这个技巧是很多高效算法的基础，如排序算法(快速排序，归并排序)，傅立叶变换(快速傅立叶变换)……</p><p>   任何一个可以用计算机求解的问题所需的计算时间都与其规模有关。问题的规模越小，越容易直接求解，解题所需的计算时间也越少。例如，对于n个元素的排序问题，当n=1时，不需任何计算。n=2时，只要作一次比较即可排好序。n=3时只要作3次比较即可，…。而当n较大时，问题就不那么容易处理了。要想直接解决一个规模较大的问题，有时是相当困难的。</p><h2 id="二、基本思想及策略"><a href="#二、基本思想及策略" class="headerlink" title="二、基本思想及策略"></a>二、基本思想及策略</h2><p>   <strong>分治法的设计思想是：</strong>将一个难以直接解决的大问题，分割成一些规模较小的相同问题，以便各个击破，分而治之。</p><p>   <strong>分治策略是：</strong>对于一个规模为n的问题，若该问题可以容易地解决（比如说规模n较小）则直接解决，否则将其分解为k个规模较小的子问题，这些子问题互相独立且与原问题形式相同，递归地解这些子问题，然后将各子问题的解合并得到原问题的解。这种算法设计策略叫做分治法。</p><p>   如果原问题可分割成k个子问题，1&lt;k≤n，且这些子问题都可解并可利用这些子问题的解求出原问题的解，那么这种分治法就是可行的。由分治法产生的子问题往往是原问题的较小模式，这就为使用递归技术提供了方便。在这种情况下，反复应用分治手段，可以使子问题与原问题类型一致而其规模却不断缩小，最终使子问题缩小到很容易直接求出其解。这自然导致递归过程的产生。分治与递归像一对孪生兄弟，经常同时应用在算法设计之中，并由此产生许多高效算法。</p><h2 id="三、分治法适用的情况"><a href="#三、分治法适用的情况" class="headerlink" title="三、分治法适用的情况"></a>三、分治法适用的情况</h2><ul><li><p>分治法所能解决的问题一般具有以下几个特征：</p><p>（1) 该问题的规模缩小到一定的程度就可以容易地解决</p><p>（2) 该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质。</p><p>（3) 利用该问题分解出的子问题的解可以合并为该问题的解；</p><p>（4) 该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子子问题。</p></li></ul><blockquote><p>第一条特征是绝大多数问题都可以满足的，因为问题的计算复杂性一般是随着问题规模的增加而增加；</p><p>第二条特征是应用分治法的前提它也是大多数问题可以满足的，此特征反映了递归思想的应用；、</p><p>第三条特征是关键，能否利用分治法完全取决于问题是否具有第三条特征，如果具备了第一条和第二条特征，而不具备第三条特征，则可以考虑用贪心法或动态规划法。</p><p>第四条特征涉及到分治法的效率，如果各子问题是不独立的则分治法要做许多不必要的工作，重复地解公共的子问题，此时虽然可用分治法，但一般用动态规划法较好。</p></blockquote><h2 id="四、分治法的基本步骤"><a href="#四、分治法的基本步骤" class="headerlink" title="四、分治法的基本步骤"></a>四、分治法的基本步骤</h2><p>分治法在每一层递归上都有三个步骤：</p><ul><li><p>step1 分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题；</p></li><li><p>step2 解决：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题</p></li><li><p>step3 合并：将各个子问题的解合并为原问题的解。</p></li></ul><p>它的一般的算法设计模式如下：</p><pre><code>Divide-and-Conquer(P)1. if |P|≤n02. then return(ADHOC(P))3. 将P分解为较小的子问题 P1 ,P2 ,...,Pk4. for i←1 to k5. do yi ← Divide-and-Conquer(Pi) △ 递归解决Pi6. T ← MERGE(y1,y2,...,yk) △ 合并子问题7. return(T)</code></pre><blockquote><p>   其中|P|表示问题P的规模；n0为一阈值，表示当问题P的规模不超过n0时，问题已容易直接解出，不必再继续分解。ADHOC(P)是该分治法中的基本子算法，用于直接解小规模的问题P。因此，当P的规模不超过n0时直接用算法ADHOC(P)求解。算法MERGE(y1,y2,…,yk)是该分治法中的合并子算法，用于将P的子问题P1 ,P2 ,…,Pk的相应的解y1,y2,…,yk合并为P的解。</p></blockquote><h2 id="五、分治法的复杂性分析"><a href="#五、分治法的复杂性分析" class="headerlink" title="五、分治法的复杂性分析"></a>五、分治法的复杂性分析</h2><p>   一个分治法将规模为n的问题分成k个规模为n／m的子问题去解。设分解阀值n0=1，且adhoc解规模为1的问题耗费1个单位时间。再设将原问题分解为k个子问题以及用merge将k个子问题的解合并为原问题的解需用f(n)个单位时间。用T(n)表示该分治法解规模为|P|=n的问题所需的计算时间，则有：</p><p> T（n）= k T(n/m)+f(n)</p><p>  通过迭代法求得方程的解：</p><p>  递归方程及其解只给出n等于m的方幂时T(n)的值，但是如果认为T(n)足够平滑，那么由n等于m的方幂时T(n)的值可以估计T(n)的增长速度。通常假定T(n)是单调上升的，从而当mi≤n&lt;mi+1时，T(mi)≤T(n)&lt;T(mi+1)。 </p><h2 id="六、可使用分治法求解的一些经典问题"><a href="#六、可使用分治法求解的一些经典问题" class="headerlink" title="六、可使用分治法求解的一些经典问题"></a>六、可使用分治法求解的一些经典问题</h2><p> （1）二分搜索<br> （2）大整数乘法<br> （3）Strassen矩阵乘法<br> （4）棋盘覆盖<br> （5）合并排序<br> （6）快速排序<br> （7）线性时间选择</p><p> （8）最接近点对问题<br> （9）循环赛日程表<br> （10）汉诺塔</p><h2 id="七、依据分治法设计程序时的思维过程"><a href="#七、依据分治法设计程序时的思维过程" class="headerlink" title="七、依据分治法设计程序时的思维过程"></a>七、依据分治法设计程序时的思维过程</h2><blockquote><p>   实际上就是类似于数学归纳法，找到解决本问题的求解方程公式，然后根据方程公式设计递归程序。</p></blockquote><p>1、一定是先找到最小问题规模时的求解方法</p><p>2、然后考虑随着问题规模增大时的求解方法</p><p>3、找到求解的递归函数式后（各种规模或因子），设计递归程序即可。</p><h1 id="动态规划算法"><a href="#动态规划算法" class="headerlink" title="动态规划算法"></a>动态规划算法</h1><h2 id="一、基本概念-1"><a href="#一、基本概念-1" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><p>   动态规划过程是：每次决策依赖于当前状态，又随即引起状态的转移。一个决策序列就是在变化的状态中产生出来的，所以，这种多阶段最优化决策解决问题的过程就称为动态规划。</p><h2 id="二、基本思想与策略"><a href="#二、基本思想与策略" class="headerlink" title="二、基本思想与策略"></a>二、基本思想与策略</h2><p>   基本思想与分治法类似，也是将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，前一子问题的解，为后一子问题的求解提供了有用的信息。在求解任一子问题时，列出各种可能的局部解，通过决策保留那些有可能达到最优的局部解，丢弃其他局部解。依次解决各子问题，最后一个子问题就是初始问题的解。</p><p>   由于动态规划解决的问题多数有重叠子问题这个特点，为减少重复计算，对每一个子问题只解一次，将其不同阶段的不同状态保存在一个二维数组中。</p><blockquote><p> 与分治法最大的差别是：适合于用动态规划法求解的问题，经分解后得到的子问题往往不是互相独立的（即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解）。</p></blockquote><h2 id="三、适用的情况"><a href="#三、适用的情况" class="headerlink" title="三、适用的情况"></a>三、适用的情况</h2><p>能采用动态规划求解的问题的一般要具有3个性质：</p><ul><li><p>最优化原理：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。</p></li><li><p>无后效性：即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关。</p></li><li><p>有重叠子问题：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势）</p></li></ul><h2 id="四、求解的基本步骤"><a href="#四、求解的基本步骤" class="headerlink" title="四、求解的基本步骤"></a>四、求解的基本步骤</h2><p>   动态规划所处理的问题是一个多阶段决策问题，一般由初始状态开始，通过对中间阶段决策的选择，达到结束状态。这些决策形成了一个决策序列，同时确定了完成整个过程的一条活动路线(通常是求最优的活动路线)。如图所示。动态规划的设计都有着一定的模式，一般要经历以下几个步骤。</p><blockquote><p>   初始状态→│决策１│→│决策２│→…→│决策ｎ│→结束状态<br>                      图1 动态规划决策过程示意图</p></blockquote><p>   (1)划分阶段：按照问题的时间或空间特征，把问题分为若干个阶段。在划分阶段时，注意划分后的阶段一定要是有序的或者是可排序的，否则问题就无法求解。</p><p>   (2)确定状态和状态变量：将问题发展到各个阶段时所处于的各种客观情况用不同的状态表示出来。当然，状态的选择要满足无后效性。</p><p>   (3)确定决策并写出状态转移方程：因为决策和状态转移有着天然的联系，状态转移就是根据上一阶段的状态和决策来导出本阶段的状态。所以如果确定了决策，状态转移方程也就可写出。但事实上常常是反过来做，根据相邻两个阶段的状态之间的关系来确定决策方法和状态转移方程。</p><p>   (4)寻找边界条件：给出的状态转移方程是一个递推式，需要一个递推的终止条件或边界条件。一般，只要解决问题的阶段、状态和状态转移决策确定了，就可以写出状态转移方程（包括边界条件）。</p><p>实际应用中可以按以下几个简化的步骤进行设计：</p><pre><code>（1）分析最优解的性质，并刻画其结构特征。（2）递归的定义最优解。（3）以自底向上或自顶向下的记忆化方式（备忘录法）计算出最优值（4）根据计算最优值时得到的信息，构造问题的最优解</code></pre><h2 id="五、算法实现的说明"><a href="#五、算法实现的说明" class="headerlink" title="五、算法实现的说明"></a>五、算法实现的说明</h2><p>   动态规划的主要难点在于理论上的设计，也就是上面4个步骤的确定，一旦设计完成，实现部分就会非常简单。使用动态规划求解问题，最重要的就是确定动态规划三要素：</p><p>（1）问题的阶段 </p><p>（2）每个阶段的状态</p><p>（3）从前一个阶段转化到后一个阶段之间的递推关系。</p><p>   递推关系必须是从次小的问题开始到较大的问题之间的转化，从这个角度来说，动态规划往往可以用递归程序来实现，不过因为递推可以充分利用前面保存的子问题的解来减少重复计算，所以对于大规模问题来说，有递归不可比拟的优势，这也是动态规划算法的核心之处。</p><p>   确定了动态规划的这三要素，整个求解过程就可以用一个最优决策表来描述，最优决策表是一个二维表，其中行表示决策的阶段，列表示问题状态，表格需要填写的数据一般对应此问题的在某个阶段某个状态下的最优值（如最短路径，最长公共子序列，最大价值等），填表的过程就是根据递推关系，从1行1列开始，以行或者列优先的顺序，依次填写表格，最后根据整个表格的数据通过简单的取舍或者运算求得问题的最优解。</p><pre><code>f(n,m)=max{f(n-1,m), f(n-1,m-w[n])+P(n,m)}</code></pre><h2 id="六、动态规划算法基本框架"><a href="#六、动态规划算法基本框架" class="headerlink" title="六、动态规划算法基本框架"></a>六、动态规划算法基本框架</h2><p>代码：</p><pre><code>for(j=1; j&lt;=m; j=j+1) // 第一个阶段   xn[j] = 初始值; for(i=n-1; i&gt;=1; i=i-1)// 其他n-1个阶段   for(j=1; j&gt;=f(i); j=j+1)//f(i)与i有关的表达式     xi[j]=j=max（或min）{g(xi-1[j1:j2]), ......, g(xi-1[jk:jk+1])};t = g(x1[j1:j2]); // 由子问题的最优解求解整个问题的最优解的方案print(x1[j1]);for(i=2; i&lt;=n-1; i=i+1）{       t = t-xi-1[ji];     for(j=1; j&gt;=f(i); j=j+1)        if(t=xi[ji])             break;}</code></pre><h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><h2 id="一、基本概念："><a href="#一、基本概念：" class="headerlink" title="一、基本概念："></a>一、基本概念：</h2><p>   所谓贪心算法是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的仅是在某种意义上的局部最优解。</p><p>   贪心算法没有固定的算法框架，算法设计的关键是贪心策略的选择。必须注意的是，贪心算法不是对所有问题都能得到整体最优解，选择的贪心策略必须具备无后效性，即某个状态以后的过程不会影响以前的状态，只与当前状态有关。</p><p>   所以对所采用的贪心策略一定要仔细分析其是否满足无后效性。</p><h2 id="二、贪心算法的基本思路："><a href="#二、贪心算法的基本思路：" class="headerlink" title="二、贪心算法的基本思路："></a>二、贪心算法的基本思路：</h2><p>1.建立数学模型来描述问题。</p><p>2.把求解的问题分成若干个子问题。</p><p>3.对每一子问题求解，得到子问题的局部最优解。</p><p>4.把子问题的解局部最优解合成原来解问题的一个解。</p><h2 id="三、贪心算法适用的问题"><a href="#三、贪心算法适用的问题" class="headerlink" title="三、贪心算法适用的问题"></a>三、贪心算法适用的问题</h2><p>   贪心策略适用的前提是：局部最优策略能导致产生全局最优解。实际上，贪心算法适用的情况很少。一般，对一个问题分析是否适用于贪心算法，可以先选择该问题下的几个实际数据进行分析，就可做出判断。</p><h2 id="四、贪心算法的实现框架"><a href="#四、贪心算法的实现框架" class="headerlink" title="四、贪心算法的实现框架"></a>四、贪心算法的实现框架</h2><pre><code>从问题的某一初始解出发；while （能朝给定总目标前进一步）{       利用可行的决策，求出可行解的一个解元素；}由所有解元素组合成问题的一个可行解；</code></pre><h2 id="五、贪心策略的选择"><a href="#五、贪心策略的选择" class="headerlink" title="五、贪心策略的选择"></a>五、贪心策略的选择</h2><p>   因为用贪心算法只能通过解局部最优解的策略来达到全局最优解，因此，一定要注意判断问题是否适合采用贪心算法策略，找到的解是否一定是问题的最优解。</p><h2 id="六、例题分析"><a href="#六、例题分析" class="headerlink" title="六、例题分析"></a>六、例题分析</h2><pre><code>下面是一个可以试用贪心算法解的题目，贪心解的确不错，可惜不是最优解。[背包问题]有一个背包，背包容量是M=150。有7个物品，物品可以分割成任意大小。要求尽可能让装入背包中的物品总价值最大，但不能超过总容量。物品 A B C D E F G重量 35 30 60 50 40 10 25价值 10 40 30 50 35 40 30分析：目标函数： ∑pi最大约束条件是装入的物品总重量不超过背包容量：∑wi&lt;=M( M=150)（1）根据贪心的策略，每次挑选价值最大的物品装入背包，得到的结果是否最优？（2）每次挑选所占重量最小的物品装入是否能得到最优解？（3）每次选取单位重量价值最大的物品，成为解本题的策略。值得注意的是，贪心算法并不是完全不可以使用，贪心策略一旦经过证明成立后，它就是一种高效的算法。贪心算法还是很常见的算法之一，这是由于它简单易行，构造贪心策略不是很困难。可惜的是，它需要证明后才能真正运用到题目的算法中。一般来说，贪心算法的证明围绕着：整个问题的最优解一定由在贪心策略中存在的子问题的最优解得来的。对于例题中的3种贪心策略，都是无法成立（无法被证明）的，解释如下：（1）贪心策略：选取价值最大者。反例：W=30物品：A B C重量：28 12 12价值：30 20 20根据策略，首先选取物品A，接下来就无法再选取了，可是，选取B、C则更好。（2）贪心策略：选取重量最小。它的反例与第一种策略的反例差不多。（3）贪心策略：选取单位重量价值最大的物品。反例：W=30物品：A B C重量：28 20 10价值：28 20 10根据策略，三种物品单位重量价值一样，程序无法依据现有策略作出判断，如果选择A，则答案错误。</code></pre><h1 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h1><h2 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h2><p>   回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。</p><p>   回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。</p><p>   许多复杂的，规模较大的问题都可以使用回溯法，有“通用解题方法”的美称。</p><h2 id="2、基本思想"><a href="#2、基本思想" class="headerlink" title="2、基本思想"></a>2、基本思想</h2><p>   在包含问题的所有解的解空间树中，按照深度优先搜索的策略，从根结点出发深度探索解空间树。当探索到某一结点时，要先判断该结点是否包含问题的解，如果包含，就从该结点出发继续探索下去，如果该结点不包含问题的解，则逐层向其祖先结点回溯。（其实回溯法就是对隐式图的深度优先搜索算法）。</p><p>   若用回溯法求问题的所有解时，要回溯到根，且根结点的所有可行的子树都要已被搜索遍才结束。</p><p>   而若使用回溯法求任一个解时，只要搜索到问题的一个解就可以结束。</p><p>3、<strong>用回溯法解题的一般步骤：</strong></p><p>（1）针对所给问题，确定问题的解空间：首先应明确定义问题的解空间，问题的解空间应至少包含问题的一个（最优）解。</p><p>（2）确定结点的扩展搜索规则</p><p>（3）以深度优先方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索。</p><h2 id="4、算法框架"><a href="#4、算法框架" class="headerlink" title="4、算法框架"></a>4、算法框架</h2><h3 id="（1）问题框架"><a href="#（1）问题框架" class="headerlink" title="（1）问题框架"></a>（1）问题框架</h3><pre><code>设问题的解是一个n维向量(a1,a2,………,an),约束条件是ai(i=1,2,3,…..,n)之间满足某种条件，记为f(ai)。</code></pre><h3 id="（2）非递归回溯框架"><a href="#（2）非递归回溯框架" class="headerlink" title="（2）非递归回溯框架"></a>（2）非递归回溯框架</h3><pre><code> 1: int a[n],i; 2: 初始化数组a[]; 3: i = 1; 4: while (i&gt;0(有路可走)   and  (未达到目标))  // 还未回溯到头 5: { 6:     if(i &gt; n)                                              // 搜索到叶结点 7:     {    8:           搜索到一个解，输出； 9:     }10:     else                                                   // 处理第i个元素11:     { 12:           a[i]第一个可能的值；13:           while(a[i]在不满足约束条件且在搜索空间内)</code></pre><h3 id="3）递归的算法框架"><a href="#3）递归的算法框架" class="headerlink" title="3）递归的算法框架"></a>3）递归的算法框架</h3><blockquote><p>回溯法是对解空间的深度优先搜索，在一般情况下使用递归函数来实现回溯法比较简单，其中i为搜索的深度，框架如下：</p></blockquote><pre><code> 1: int a[n]; 2: try(int i) 3: { 4:     if(i&gt;n) 5:        输出结果; 6:      else 7:     { 8:        for(j = 下界; j &lt;= 上界; j=j+1)  // 枚举i所有可能的路径 9:        {10:            if(fun(j))                 // 满足限界函数和约束条件11:              {12:                 a[i] = j;13:               ...                         // 其他操作</code></pre><h1 id="分支限界法"><a href="#分支限界法" class="headerlink" title="分支限界法"></a>分支限界法</h1><h2 id="一、基本描述"><a href="#一、基本描述" class="headerlink" title="一、基本描述"></a>一、基本描述</h2><p>   类似于回溯法，也是一种在问题的解空间树T上搜索问题解的算法。但在一般情况下，分支限界法与回溯法的求解目标不同。回溯法的求解目标是找出T中满足约束条件的所有解，而分支限界法的求解目标则是找出满足约束条件的一个解，或是在满足约束条件的解中找出使某一目标函数值达到极大或极小的解，即在某种意义下的最优解。</p><h3 id="（1）分支搜索算法"><a href="#（1）分支搜索算法" class="headerlink" title="（1）分支搜索算法"></a>（1）分支搜索算法</h3><blockquote><p>所谓“分支”就是采用广度优先的策略，依次搜索E-结点的所有分支，也就是所有相邻结点，抛弃不满足约束条件的结点，其余结点加入活结点表。然后从表中选择一个结点作为下一个E-结点，继续搜索。</p></blockquote><p>选择下一个E-结点的方式不同，则会有几种不同的分支搜索方式。</p><ul><li><p>FIFO搜索</p></li><li><p>LIFO搜索</p></li><li><p>优先队列式搜索</p></li></ul><h3 id="（2）分支限界搜索算法"><a href="#（2）分支限界搜索算法" class="headerlink" title="（2）分支限界搜索算法"></a>（2）分支限界搜索算法</h3><h2 id="二、分支限界法的一般过程"><a href="#二、分支限界法的一般过程" class="headerlink" title="二、分支限界法的一般过程"></a>二、分支限界法的一般过程</h2><blockquote><p>由于求解目标不同，导致分支限界法与回溯法在解空间树T上的搜索方式也不相同。回溯法以深度优先的方式搜索解空间树T，而分支限界法则以广度优先或以最小耗费优先的方式搜索解空间树T。</p></blockquote><p><strong>分支限界法的搜索策略是：</strong></p><p>在扩展结点处，先生成其所有的儿子结点（分支），然后再从当前的活结点表中选择下一个扩展对点。为了有效地选择下一扩展结点，以加速搜索的进程，在每一活结点处，计算一个函数值（限界），并根据这些已计算出的函数值，从当前活结点表中选择一个最有利的结点作为扩展结点，使搜索朝着解空间树上有最优解的分支推进，以便尽快地找出一个最优解。</p><p>分支限界法常以广度优先或以最小耗费（最大效益）优先的方式搜索问题的解空间树。问题的解空间树是表示问题解空间的一棵有序树，常见的有子集树和排列树。在搜索问题的解空间树时，分支限界法与回溯法对当前扩展结点所使用的扩展方式不同。在分支限界法中，每一个活结点只有一次机会成为扩展结点。活结点一旦成为扩展结点，就一次性产生其所有儿子结点。在这些儿子结点中，那些导致不可行解或导致非最优解的儿子结点被舍弃，其余儿子结点被子加入活结点表中。此后，从活结点表中取下一结点成为当前扩展结点，并重复上述结点扩展过程。这个过程一直持续到找到所求的解或活结点表为空时为止。</p><h2 id="三、回溯法和分支限界法的一些区别"><a href="#三、回溯法和分支限界法的一些区别" class="headerlink" title="三、回溯法和分支限界法的一些区别"></a>三、回溯法和分支限界法的一些区别</h2><blockquote><p>有一些问题其实无论用回溯法还是分支限界法都可以得到很好的解决，但是另外一些则不然。也许我们需要具体一些的分析——到底何时使用分支限界而何时使用回溯呢？</p></blockquote><h3 id="回溯法和分支限界法的一些区别："><a href="#回溯法和分支限界法的一些区别：" class="headerlink" title="回溯法和分支限界法的一些区别："></a>回溯法和分支限界法的一些区别：</h3><ul><li><p>方法对解空间树的搜索方式       </p></li><li><p>存储结点的常用数据结构      </p></li><li><p>结点存储特性常用应用</p></li></ul><blockquote><p><strong>回溯法深度优先搜索堆栈活结点的所有可行子结点被遍历后才被从栈中弹出找出满足约束条件的所有解</strong></p><p><strong>分支限界法广度优先或最小消耗优先搜索队列、优先队列每个结点只有一次成为活结点的机会找出满足约束条件的一个解或特定意义下的最优解</strong></p></blockquote><p><strong>策略是面向问题的，算法是面向实现的。</strong></p><h1 id="一、不同算法策略特点小结"><a href="#一、不同算法策略特点小结" class="headerlink" title="一、不同算法策略特点小结"></a>一、不同算法策略特点小结</h1><h2 id="1、贪心策略"><a href="#1、贪心策略" class="headerlink" title="1、贪心策略"></a>1、贪心策略</h2><ul><li><p>贪心策略一方面是求解过程比较简单的算法，另一方面它又是对能适用问题的条件要求最严格（即适用范围很小）的算法。</p></li><li><p>贪心策略解决问题是按一定顺序，在只考虑当前局部信息的情况下，就做出一定的决策，最终得出问题的解。</p></li></ul><blockquote><p>即：通过局部最优决策能得到全局最优决策</p></blockquote><h2 id="2、递推策略"><a href="#2、递推策略" class="headerlink" title="2、递推策略"></a>2、递推策略</h2><p>   递推也是由当前问题的逐步解决从而得到整个问题的解，依赖于信息间本身的递推关系，每一步不需要决策参与到算法中，更多用于计算</p><h2 id="3、递归策略"><a href="#3、递归策略" class="headerlink" title="3、递归策略"></a>3、递归策略</h2><p>   递归常常用于分治算法、动态规划算法中。</p><p>   递归是利用大问题与其子问题间的递推关系来解决问题的。</p><p>   能采用递归策略的算法一般有以下特征：</p><p>   （1）为求解规模为N的问题，设法将它分解成规模较小的问题，然后从这些小问题的解方便地构造出大问题的解</p><p>   （2）并且这些规模较小的问题也能采用同样的分解和综合方法，分解成更小的问题，并从这些更小的问题的解构造出规模较大问题的解</p><p>   （3）特别的，当规模N = 1时，能直接得解</p><h2 id="4、枚举策略"><a href="#4、枚举策略" class="headerlink" title="4、枚举策略"></a>4、枚举策略</h2><p>   对问题所有的解逐一尝试，从而找出问题的真正解。一般用于决策类问题，很难找到大、小规模之间的关系，也不易对问题进行分解。</p><h2 id="5、递归回溯策略"><a href="#5、递归回溯策略" class="headerlink" title="5、递归回溯策略"></a>5、递归回溯策略</h2><p>   类似于枚举，通过尝试遍历问题各个可能解的通路，当发现此路不通时，回溯到上一步继续尝试别的通路。</p><h2 id="6、分治策略"><a href="#6、分治策略" class="headerlink" title="6、分治策略"></a>6、分治策略</h2><p>   分治一般用于较复杂的问题，必须可以逐步被分解为容易解决的独立的子问题，这些子问题解决后，进而将它们的解“合成”，就得到较大问题的解，最终合成为总问题的解。</p><h2 id="7、动态规划策略"><a href="#7、动态规划策略" class="headerlink" title="7、动态规划策略"></a>7、动态规划策略</h2><p>   与贪心类似，也是通过多阶段决策过程来解决问题。每个阶段决策的结果是一个决策结果序列，这个结果序列中，最终哪一个是最优的结果，取决于以后每个阶段的决策，当然每次决策结果序列都必须进行存储。因此是“高效率，高消费的算法”。</p><p>   同时，它又与递归法类似，当问题不能分解为独立的阶段，却又符合最优化原理时，就可以使用动态规划法，通过递归决策过程，逐步找出子问题的最优解，从而决策出问题的解。</p><h1 id="二、算法策略间的关系"><a href="#二、算法策略间的关系" class="headerlink" title="二、算法策略间的关系"></a>二、算法策略间的关系</h1><h2 id="1、对问题进行分解的算法策略——分治法与动态规划法"><a href="#1、对问题进行分解的算法策略——分治法与动态规划法" class="headerlink" title="1、对问题进行分解的算法策略——分治法与动态规划法"></a>1、对问题进行分解的算法策略——分治法与动态规划法</h2><ul><li><p><strong>共同点：</strong></p><p> （1）分治法与动态规划法实际上都是递归思想的运用</p><p> （2）二者的根本策略都是对问题进行分解，找到大规模与小规模的关系，然后通过解小规模的解，得出大规模的解</p></li><li><p><strong>不同点：</strong>适用于分治法的问题分解成子问题后，各子问题间无公共子子问题，而动态规划法相反。</p></li></ul><blockquote><p><strong>动态规划法 = 分治算法思想 + 解决子问题间的冗余情况</strong></p></blockquote><h2 id="2、多阶段逐步解决问题的策略——贪心算法、递推法、递归法和动态规划法"><a href="#2、多阶段逐步解决问题的策略——贪心算法、递推法、递归法和动态规划法" class="headerlink" title="2、多阶段逐步解决问题的策略——贪心算法、递推法、递归法和动态规划法"></a>2、多阶段逐步解决问题的策略——贪心算法、递推法、递归法和动态规划法</h2><p>   <strong>贪心算法</strong>：每一步都根据策略得到一个结果，并传递到下一步，自顶向下，一步一步地做出贪心决策。</p><p>   <strong>动态规划算法</strong>：每一步决策得到的不是一个唯一结果，而是一组中间结果（且这些结果在以后各步可能得到多次引用），只是每一步都使问题的规模逐步缩小，最终得到问题的一个结果。</p><p>   <strong>递推、递归法：</strong>注重每一步之间的关系，决策的因素较少。递推法是根据关系从前向后推导，从小规模问题的结论推解出大问题的解。而递归法是根据关系从后向前使大问题转化为小问题，最后同样由小规模问题的解推解出大问题的解。</p><h2 id="3、全面逐一尝试、比较——蛮力法、枚举法、递归回溯法"><a href="#3、全面逐一尝试、比较——蛮力法、枚举法、递归回溯法" class="headerlink" title="3、全面逐一尝试、比较——蛮力法、枚举法、递归回溯法"></a>3、全面逐一尝试、比较——蛮力法、枚举法、递归回溯法</h2><p>蛮力策略（即枚举和递归回溯）：</p><p>   当问题找不到信息间的相互关系、也不能将问题分解为独立的子问题，就只有把全部解都列出来之后，才能判定和推断出问题的解。</p><blockquote><p>蛮力策略适用于规模不大的问题。</p></blockquote><p>（1）枚举法：实现依赖于循环。所以一个枚举法只针对一个特定问题规模的情况，例如：八重循环嵌套解八皇后问题的算法。</p><p>（2）递归回溯法：适用于任意指定规模的情况，例如：递归回溯法解N皇后问题。</p><h2 id="4、算法策略的中心思想"><a href="#4、算法策略的中心思想" class="headerlink" title="4、算法策略的中心思想"></a>4、算法策略的中心思想</h2><p>   用算法策略将解决问题的过程归结为：用算法的基本工具“循环机制和递归机制”实现。</p><h1 id="三、算法策略侧重的问题类型"><a href="#三、算法策略侧重的问题类型" class="headerlink" title="三、算法策略侧重的问题类型"></a>三、算法策略侧重的问题类型</h1><p>一般常遇到的问题分为四类：</p><p>（1）判定性问题：可用递推法、递归法</p><p>（2）计算问题：可用递推法、递归法</p><p>（3）最优化问题：贪心算法、分治法、动态规划法、枚举法</p><p>（4）构造性问题：贪心算法、分治法、广度优先搜索、深度优先搜索</p><p>好</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文转自：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;博客园：&lt;a href=&quot;http://www.cnblogs.com/steven_oyj/archive/2010/05/22/1741370.html&quot; target=&quot;_blank&quot; rel=&quot;ex
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://liujunjie11.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="https://liujunjie11.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>python3爬取拉勾网职位信息</title>
    <link href="https://liujunjie11.github.io/2018/05/05/python3%E7%88%AC%E5%8F%96%E6%8B%89%E5%8B%BE%E7%BD%91%E8%81%8C%E4%BD%8D%E4%BF%A1%E6%81%AF/"/>
    <id>https://liujunjie11.github.io/2018/05/05/python3爬取拉勾网职位信息/</id>
    <published>2018-05-05T10:05:56.000Z</published>
    <updated>2018-05-06T14:38:37.256Z</updated>
    
    <content type="html"><![CDATA[<p>爬取拉勾网的最大障碍：<strong>普通模块难以实现翻页爬取。</strong>自己加了参数<code>page</code>，经过抓包查询之后也达不到我的理想要求。</p><p>没办法了，只好用<em>selenium</em>模块结合浏览器来实现边翻页边爬取了。</p><blockquote><p>实际上比较浪费系统资源，这种情况不得已还是尽量别用的好。</p></blockquote><p>在此记录下主要的过程，包括实现的代码。</p><p>还是要说明一下：<strong>不懂的地方还是需要自己去查询了解，代码不过就是几个模块的知识运用罢了。</strong></p><h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>启动<em>Chrome**webdriver</em>插件，之后复制其所在地址，加入代码中启动<em>selenium</em>模块程序。</p><p><img src="http://owudg3xs2.bkt.clouddn.com/5%E6%9C%88-06-2018%2022-29-25.gif" alt=""></p><blockquote><p>启动插件。</p></blockquote><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-05-06%20%E4%B8%8B%E5%8D%8810.28.45.png" alt=""></p><blockquote><p>本机此插件所在的目录位置。</p></blockquote><h2 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h2><p>经过简单的分析，发现页面的切换的同时URL没有任何的改变(这就是我为何要用<em>selenium</em>来爬取的原因！)：</p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-05-06%20%E4%B8%8B%E5%8D%8810.32.58.png" alt=""></p><p>我们的目标是，点击在此符合条件的发布公司链接，进入招聘信息详细的界面爬取详细的所有需要的信息：</p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-05-06%20%E4%B8%8B%E5%8D%8810.34.40.png" alt=""></p><blockquote><p>一一进入进行爬取。</p></blockquote><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-05-06%20%E4%B8%8B%E5%8D%8810.35.34.png" alt=""></p><blockquote><p>进入之后详细的招聘信息页面。</p></blockquote><p>那么思路一下就出来了：<strong>用selenium模块实现翻页的功能，并且返回对应页面的源代码，并且一一进行分析提取即可。</strong></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre><code>&quot;&quot;&quot;函数目标：翻页爬取拉勾网的职位信息编写时间：2018-05-05&quot;&quot;&quot;from selenium import webdriverfrom selenium.webdriver.common.by import Byfrom selenium.webdriver.support import expected_conditions as ECfrom selenium.webdriver.support.wait import WebDriverWaitfrom pyquery import PyQuery as pqfrom urllib.parse import quoteimport requestsimport reimport time# 启动对象驱动，并且设置预期的等待时间browser = webdriver.Chrome(&apos;/Users/junjieliu/Downloads/webdirver小插件/chromedriver&apos;)wait = WebDriverWait(browser, 10)def page_content(pages):    &quot;&quot;&quot;    返回每一页的页面源代码，顾名知义，从URL中可知许多的筛选信息了，可自行选择，    在此仅以职位关键词职位作为输入。    &quot;&quot;&quot;    print(&apos;-&apos; * 10 + &apos;正在爬取第&apos; + str(pages) + &apos;页的内容&apos; + &apos;.&apos; * 6)    keyword = &apos;数据分析师&apos;  # 职位关键词    url = &apos;https://www.lagou.com/jobs/list_&apos; + quote(keyword) + &apos;?&apos; + &apos;px=default&amp;gx=实习&amp;gj=&amp;xl=本科&amp;isSchoolJob=1&amp;city=全国#filterBox&apos;     browser.get(url)    if pages &gt; 1:        # 如果页面数大于1页则启用自动翻页        next_botton = wait.until(                    EC.element_to_be_clickable((By.CSS_SELECTOR, &apos;#s_position_list &gt; div.item_con_pager &gt; div &gt; span.pager_next&apos;)))        next_botton.click()    # 指定要爬取区域,非必须要写    wait.until(            EC.presence_of_element_located((By.CSS_SELECTOR, &apos;#s_position_list &gt; ul &gt; li.con_list_item&apos;)))    print(&apos;爬取此页源码成功！以下是本页一系列相关的内容：&apos;)    informations_save()def informations_save():    &quot;&quot;&quot;    一一进入内部URL，爬取详细的招聘信息！    &quot;&quot;&quot;    source_code = browser.page_source    doc = pq(source_code)    url = re.findall(r&apos;class=&quot;position_link&quot;.*?href=&quot;(.*?)&quot;&apos;, source_code, re.S)  # @UndefinedVariable      for i in range(0, len(url)):        header = {        &apos;Connection&apos;: &apos;keep-alive&apos;,        &apos;Host&apos;: &apos;www.lagou.com&apos;,        &apos;Upgrade-Insecure-Requests&apos;: &apos;1&apos;,        &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.139 Safari/537.36&apos;    }        response = requests.get(url=url[i], headers=header)        response.encoding = &apos;utf-8&apos;        doc1 = pq(response.text)        infor = {            &apos;company&apos;:doc1.find(&apos;body &gt; div.position-head &gt; div &gt; div.position-content-l &gt; div &gt; div.company&apos;).text(),  # 公司名称            &apos;infor_url&apos;:doc1.find(&apos;#job_company &gt; dt &gt; a&apos;).attr(&apos;href&apos;),  # 此公司详细介绍网站            &apos;position&apos;:doc1.find(&apos;body &gt; div.position-head &gt; div &gt; div.position-content-l &gt; div &gt; span.name&apos;).text(),  # 职位            &apos;salary&apos;:doc1.find(&apos;body &gt; div.position-head &gt; div &gt; div.position-content-l &gt; dd &gt; p:nth-child(1) &gt; span.salary&apos;).text(),  # 工资            &apos;locale&apos;:doc1.find(&apos;#job_detail &gt; dd.job-address.clearfix &gt; input[type=&quot;hidden&quot;]:nth-child(6)&apos;).text().replace(&apos;/&apos;, &apos;&apos;),  # 地点            &apos;place&apos;:doc1.find(&apos;#job_detail &gt; dd.job-address.clearfix &gt; div.work_addr&apos;).text(),  # 具体位置            &apos;required&apos;:doc1.find(&apos;div.position-content-l &gt; dd &gt; p:nth-child(1) &gt; span:nth-child(3)&apos;).text().replace(&apos;/&apos;, &apos;&apos;),  # 经验要求            &apos;education&apos;:doc1.find(&apos;div.position-content-l &gt; dd &gt; p:nth-child(1) &gt; span:nth-child(4)&apos;).text().replace(&apos;/&apos;, &apos;&apos;),  # 学历要求            &apos;job_nature&apos;:doc1.find(&apos;div.position-content-l &gt; dd &gt; p:nth-child(1) &gt; span:nth-child(5)&apos;).text().replace(&apos;/&apos;, &apos;&apos;),  # 工作性质            &apos;attract&apos;:doc1.find(&apos;#job_detail &gt; dd.job-advantage&apos;).text().replace(&apos;\n&apos;, &apos; &apos;),  # 工作诱惑            &apos;describe&apos;:doc1.find(&apos;#job_detail &gt; dd.job_bt&apos;).text().replace(&apos;\n&apos;, &apos; &apos;)  # 工作描述        }        print(infor)         if __name__ == &quot;__main__&quot;:    pages = 6  # 总的页面数，从网页第一面就可知了，6是测试用的数字页码    for i in range(1, pages + 1):        page_content(i)        time.sleep(20)</code></pre><blockquote><p>最后我选择将爬取的内容保存至一个<code>.txt</code>文件下。</p></blockquote><h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-05-06%20%E4%B8%8B%E5%8D%8810.27.19.png" alt=""></p><blockquote><p>运行之后的效果，有些爬取不了，明明源代码都没什么变化…</p></blockquote><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><ul><li><p>这个代码的模型并不能爬取页面上对应的全部内容，这个我也是有点疑惑。</p></li><li><p>有时会跳到需要登录的界面，重新来几次就行了，总有一次能爬取。</p></li></ul><p>有不懂的知识可参考：<a href="https://cuiqingcai.com/5630.html" target="_blank" rel="external">https://cuiqingcai.com/5630.html</a></p><blockquote><p>以及相关的模块的官网亦可。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;爬取拉勾网的最大障碍：&lt;strong&gt;普通模块难以实现翻页爬取。&lt;/strong&gt;自己加了参数&lt;code&gt;page&lt;/code&gt;，经过抓包查询之后也达不到我的理想要求。&lt;/p&gt;
&lt;p&gt;没办法了，只好用&lt;em&gt;selenium&lt;/em&gt;模块结合浏览器来实现边翻页边爬取了。&lt;/
      
    
    </summary>
    
      <category term="python爬虫" scheme="https://liujunjie11.github.io/categories/python%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="python爬虫" scheme="https://liujunjie11.github.io/tags/python%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法书籍资源共享</title>
    <link href="https://liujunjie11.github.io/2018/05/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%A6%E7%B1%8D%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB/"/>
    <id>https://liujunjie11.github.io/2018/05/04/数据结构与算法书籍资源共享/</id>
    <published>2018-05-04T11:15:05.000Z</published>
    <updated>2018-05-04T11:20:25.483Z</updated>
    
    <content type="html"><![CDATA[<ul><li>计算机程序设计艺术(卷1～卷四全)：</li></ul><blockquote><p><a href="https://pan.baidu.com/s/1922E16LZR0iXZHZQCgsbLg" target="_blank" rel="external">https://pan.baidu.com/s/1922E16LZR0iXZHZQCgsbLg</a></p></blockquote><ul><li>算法导论(第三版)：</li></ul><blockquote><p><a href="https://pan.baidu.com/s/1XqAeeJx803rcVCx7QMA62g" target="_blank" rel="external">https://pan.baidu.com/s/1XqAeeJx803rcVCx7QMA62g</a></p></blockquote><p>以上资源来于网络，感谢默默分享的人们！</p><p>还有一些其他的金典书籍，我都没怎么看啊..</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;计算机程序设计艺术(卷1～卷四全)：&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://pan.baidu.com/s/1922E16LZR0iXZHZQCgsbLg&quot; target=&quot;_blank&quot; rel=&quot;extern
      
    
    </summary>
    
      <category term="书籍" scheme="https://liujunjie11.github.io/categories/%E4%B9%A6%E7%B1%8D/"/>
    
    
      <category term="书籍" scheme="https://liujunjie11.github.io/tags/%E4%B9%A6%E7%B1%8D/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络知识总结</title>
    <link href="https://liujunjie11.github.io/2018/05/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    <id>https://liujunjie11.github.io/2018/05/02/计算机网络知识总结/</id>
    <published>2018-05-02T13:12:31.000Z</published>
    <updated>2018-05-07T07:34:32.090Z</updated>
    
    <content type="html"><![CDATA[<p>计算机网络也是计算机基础重要的一部分。</p><p>本来打算总结下关于计算机网络基础知识，发现下面的这些课件总结的已经非常好了，所以在此分享，我就不说多了…</p><blockquote><p>下载课件：<a href="https://pan.baidu.com/s/1uodpU6E8n050QyazgdLXVw" target="_blank" rel="external">https://pan.baidu.com/s/1uodpU6E8n050QyazgdLXVw</a></p></blockquote><ul><li>说明：</li></ul><p>课件来源：《数据通信与计算机网络》</p><p>还有以下这个：</p><blockquote><p>下载课件：<a href="https://pan.baidu.com/s/1oCHb3GkybHn7vI-cvMCJIA" target="_blank" rel="external">https://pan.baidu.com/s/1oCHb3GkybHn7vI-cvMCJIA</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;计算机网络也是计算机基础重要的一部分。&lt;/p&gt;
&lt;p&gt;本来打算总结下关于计算机网络基础知识，发现下面的这些课件总结的已经非常好了，所以在此分享，我就不说多了…&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;下载课件：&lt;a href=&quot;https://pan.baidu.com/s
      
    
    </summary>
    
      <category term="计算机网络" scheme="https://liujunjie11.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="https://liujunjie11.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>我对学习计算机基础的一些心得见解</title>
    <link href="https://liujunjie11.github.io/2018/04/29/%E6%88%91%E5%AF%B9%E5%AD%A6%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BF%83%E5%BE%97%E8%A7%81%E8%A7%A3/"/>
    <id>https://liujunjie11.github.io/2018/04/29/我对学习计算机基础的一些心得见解/</id>
    <published>2018-04-29T12:54:29.000Z</published>
    <updated>2018-04-29T13:26:28.269Z</updated>
    
    <content type="html"><![CDATA[<p>最近总是遇到了许多的瓶颈…即感觉认识的知道的太少了。</p><p>在前些天看到了一些关于<em>python</em>的优化内容之后，加上之前用<em>python</em>也有一段时间了，突然的感觉到一些基础细节才是最重要的，我意识到了<strong>这往往可能就是人与人技术之间的一个分水岭，也往往是突破瓶颈关键点，也往往能决定一个人技术的所在点。基础细节知识是能决定一个人能走多远的</strong></p><p>平时在写程序时不应满足于功能的实现，更加应当注意那些可优化的细节问题，就好比一个算法的时间复杂度与空间复杂度一样的，写的每一个程序(无论那种编程语言)均有可优化的最优解选择。在我平时因为涉及的数据规模不大，这种问题目前是看不出来的，如果运用到的是一个数据规模大的问题上，优化必然是重要的，不可或缺的。</p><p>平时想问题总是感觉能联想到的知识太少，回过头来看，发现自己对计算机的认识本来也不够全面(注意是全面！而非透彻！)。这往往也限制了我许多的想象，从而造成了我的瓶颈突出明显。</p><p>说了这么多，只是想说一个问题：<strong>计算机基础知识(包括编程基础知识)是能决定一个人技术的高度的。</strong>至少我现在就有这种感觉，写一个程序不应满足于功能的实现，更应探索最优解的选择。<strong>这往往就是技术<code>好</code>与<code>坏</code>的一个区分标准吧。</strong></p><p>关于如何学习以上说的基础知识，我有一些见解在此想要说明一下。</p><ul><li><p>知识尽量要了解全面，不能为了速度而一知半解的，那样只会浪费时间，最后还是什么都不知道。</p></li><li><p>有些知识可能会引起我们的好奇，想要进一步理解透彻(彻彻底底)，但是这其中却是有太多的知识链关联着的…这点我深有体会。如果顺着知识链步步了解，我们的确也能学习到许多的知识，但是最后会发现其实这些在我们实际需要中根本没有多大的作用，仅仅当时作为一种科普了，当然现在学习到的知识也是以后我们技术的一种铺垫，如果实在有兴趣就当我没说，兴趣是学习一种知识最好的引导。</p></li><li><p>有些是需要理解透彻的，有些(大部分)可能仅仅是需要了解一下就好的。</p></li><li><p>根据目前的需求来进行学习也是一种好的驱动力。</p></li><li><p>一些必要的基础知识是需要了解的，比如学习了计算机概论，那一般以后买电脑时就会有自己的一些见解了。学习了数据结构与算法基础之后，编程时就不会仅仅以达到目的而“不择手段”编写程序了，因为再学习了这些基础知识之后我们脑子里必然会有一些规则“约束”了。</p></li></ul><p>最后，我还是想说，对于底层的电路什么的那种我想我是不愿也是不情愿接触的…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近总是遇到了许多的瓶颈…即感觉认识的知道的太少了。&lt;/p&gt;
&lt;p&gt;在前些天看到了一些关于&lt;em&gt;python&lt;/em&gt;的优化内容之后，加上之前用&lt;em&gt;python&lt;/em&gt;也有一段时间了，突然的感觉到一些基础细节才是最重要的，我意识到了&lt;strong&gt;这往往可能就是人与
      
    
    </summary>
    
      <category term="学习笔记" scheme="https://liujunjie11.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="学习笔记" scheme="https://liujunjie11.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>python3爬虫与GUI：一个简易的搜索实用小工具</title>
    <link href="https://liujunjie11.github.io/2018/04/28/python3%E7%88%AC%E8%99%AB%E4%B8%8EGUI%EF%BC%9A%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93%E7%9A%84%E6%90%9C%E7%B4%A2%E5%AE%9E%E7%94%A8%E5%B0%8F%E5%B7%A5%E5%85%B7/"/>
    <id>https://liujunjie11.github.io/2018/04/28/python3爬虫与GUI：一个简易的搜索实用小工具/</id>
    <published>2018-04-28T02:31:30.000Z</published>
    <updated>2018-05-02T13:04:39.933Z</updated>
    
    <content type="html"><![CDATA[<p>平时在获取爬虫之后，会不满足于仅仅得到了结果，而是想经过一个交互式的界面来进一步的完善，获取更多的功能，从而可以更好的展示数据。</p><p>下面运用了<em>python</em>的<em>pyqt5</em>库来进行<em>GUI</em>的设计。</p><p>用<em>pyqt5</em>这个库实现简单的界面化有两种方法：</p><ul><li><p>编写代码(一般为几十行代码足够了)。</p></li><li><p>结合<em>QT Creator</em>来进行界面设计，加入信号与槽的机制，槽这一方面还是需要编写相应的几行代码。</p></li></ul><blockquote><p>下面一一进行简单的介绍。</p></blockquote><h2 id="代码编写方式"><a href="#代码编写方式" class="headerlink" title="代码编写方式"></a>代码编写方式</h2><p>假设我已经利用爬虫写出来了<em>百度百科</em>，<em>维基百科</em>的接口的代码程序，接下来仅仅需要设计好界面，再者之后利用好信号与槽的机制将接口代码与界面相连接即可完成一个简易的搜索实用小工具了。</p><p>在此简单理解一下信号与槽机制以及所谓的事件机制：<strong>比如我们有一个按钮，点击此按钮便弹出一个写有‘Hello’的窗口，点击到弹出新窗口的这一过程，有个响应的过程，我们可以理解为发送信号(点击按钮)，之后有弹出新窗口(响应),而这一系列过程包括弹出的内容我们可称之为事件。</strong></p><blockquote><p>关于学习<em>pyqt5</em>库的中文教程地址：<a href="https://maicss.gitbooks.io/pyqt5/content/事件和信号.html" target="_blank" rel="external">https://maicss.gitbooks.io/pyqt5/content/事件和信号.html</a></p></blockquote><p>从头开始看一下，之后再看这一篇大概就知道简单的交互式界面是如何生成的了。</p><p>简单描述一下思路：<strong>先设计布局好界面(包括定义好相关按钮的快捷键)，写入爬虫代码，信号与槽机制的连接设定，即完成了此次的任务。</strong></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code>import sysimport urllib.request  from bs4 import BeautifulSoupimport refrom urllib.parse import quote from PyQt5.QtWidgets import (QPushButton, QWidget, QLabel, QLineEdit, QTextEdit, QGridLayout, QApplication,    QComboBox)from PyQt5.QtCore import QCoreApplicationclass Example(QWidget):     def __init__(self):        &apos;&apos;&apos;        初始化        &apos;&apos;&apos;        super().__init__()        self.initUI()    def baidu_baike(self, entry):          &apos;&apos;&apos;        百度百科词条内容爬取代码        entry：词条        因为太懒了..所以爬取的代码没有自己写..        &apos;&apos;&apos;        url = &apos;https://baike.baidu.com/item/&apos; + urllib.parse.quote(entry)        html = urllib.request.urlopen(url)          content = html.read().decode(&apos;utf-8&apos;)        html.close()        # lxml器进行解析        soup = BeautifulSoup(content, &quot;lxml&quot;)          text = soup.find(&apos;div&apos;, class_=&quot;lemma-summary&quot;).children  # 簡介部分        intro_text = &apos;&apos;        # 数据爬取        for x in text:            word = re.sub(re.compile(r&quot;&lt;(.+?)&gt;&quot;), &apos;&apos;, str(x))            words = re.sub(re.compile(r&quot;\[(.+?)\]&quot;), &apos;&apos;, word)            intro_text += words        return intro_text  # 返回文本(str格式)    def intro_final(self, entry):          &apos;&apos;&apos;        异常处理        &apos;&apos;&apos;        try:            return self.baidu_baike(entry)        except AttributeError:            return &quot;词条定义不够清晰/词条目前未成立！&quot;    def initUI(self):        # GUI布局及控件放置        search_label = QLabel(&quot;请输入搜索词条：&quot;)        search_item = QLineEdit()        combo = QComboBox(self)        combo.addItem(&quot;百度百科&quot;)        combo.addItem(&quot;维基百科(不可用)&quot;)        btn1 = QPushButton(&quot;开始搜索&quot;, self)        # shortcut快捷键的设置        btn1.setShortcut(&apos;return&apos;)        btn2 = QPushButton(&quot;清空&quot;, self)        btn2.setShortcut(&apos;esc&apos;)        btn3 = QPushButton(&apos;退出&apos;, self)        btn3.setShortcut(&apos;command+q&apos;)        btn3.setShortcut(&apos;Ctrl+q&apos;)        btn3.clicked.connect(QCoreApplication.instance().quit)        search_result = QTextEdit()        grid = QGridLayout()        grid.setSpacing(5)        grid.addWidget(search_label, 1, 0)        grid.addWidget(btn3, 2, 1)        grid.addWidget(search_item, 2, 0)        grid.addWidget(btn1, 3, 0)        grid.addWidget(btn2, 3, 1)        grid.addWidget(search_result, 4, 0, 5 , 0)        self.setLayout(grid)        # 信号机制的设置，定义为一个方法作为反映的对象，这里很好理解        def search():            &apos;&apos;&apos;            搜索信号反映的响应            &apos;&apos;&apos;            search_result.setText(self.intro_final(search_item.text()))        btn1.clicked.connect(search)        def clear():            &apos;&apos;&apos;            清空信号反映的响应            &apos;&apos;&apos;            search_result.setText(&quot;&quot;)            search_item.setText(&quot;&quot;)        btn2.clicked.connect(clear)        # 设置窗口大小        self.setGeometry(500, 150, 600, 500)        self.setWindowTitle(&quot;搜索引擎GUI&quot;)        self.show()if __name__ == &quot;__main__&quot;:    app = QApplication(sys.argv)    ex = Example()    sys.exit(app.exec_())</code></pre><blockquote><p>以上有不懂的地方均可在<a href="https://maicss.gitbooks.io/pyqt5/content/hello_world.html" target="_blank" rel="external">pyqt5中文教程</a>中找到思路。</p></blockquote><h3 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h3><p><img src="http://owudg3xs2.bkt.clouddn.com/5%E6%9C%88-02-2018%2019-31-44.gif" alt=""></p><h2 id="结合QT-Creator的界面设计"><a href="#结合QT-Creator的界面设计" class="headerlink" title="结合QT Creator的界面设计"></a>结合<em>QT Creator</em>的界面设计</h2><p>结合<em>QT Creator</em>的界面，我们肯定会想到：那当我们进行界面设计完成之后，就算是转化为<code>.py</code>的<em>python</em>脚本，那我们又该如何定义信号与槽的机制以及事件的机制呢？</p><p>下面的解说就是解决这个疑惑的。</p><p>第一步当然是去官网下载好软件了。</p><blockquote><p>参考此篇文章：<a href="https://blog.csdn.net/win_turn/article/details/50465127" target="_blank" rel="external">https://blog.csdn.net/win_turn/article/details/50465127</a></p></blockquote><p><strong>话不多说了，下载的时候其实有一个坑，即要记得下载有调试的那个版本，否则在设计界面时无法得到运行。</strong></p><h3 id="创建文件并且设计"><a href="#创建文件并且设计" class="headerlink" title="创建文件并且设计"></a>创建文件并且设计</h3><p>在这里仅仅是为了达到解说的目的所以简单设计一下就好，说说设计下面的思路：<strong>定义一个按钮(名为确定)，一个输入框，一个输出框，达到的目的是从输入框输入文字，按下确定按钮，输出框中输出与输入框一致的内容。</strong></p><p>创建新的文件过程如图所示：</p><p><img src="http://owudg3xs2.bkt.clouddn.com/5%E6%9C%88-02-2018%2019-42-52.gif" alt=""></p><blockquote><p>总之就是如上图一路点击下去即可。</p></blockquote><p>之后会发现有这样的界面出现：</p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-05-02%20%E4%B8%8B%E5%8D%887.43.59.png" alt=""></p><p>这个<em>mainwindow.ui</em>不说就能轻易知道就是用它来进行界面设计的。双击它即可进入设计界面(如图1)，当然可选择<em>Qt Designer</em>进行设计(对其右键可弹出选项，如图2)。</p><ul><li>图1</li></ul><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-05-02%20%E4%B8%8B%E5%8D%887.49.34.png" alt=""></p><ul><li>图2</li></ul><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-05-02%20%E4%B8%8B%E5%8D%887.47.52.png" alt=""></p><p>为了尽快达到写完的目的，我简单的来进行一下示范…</p><p>先在界面中，设计一个按钮：</p><p><img src="http://owudg3xs2.bkt.clouddn.com/5%E6%9C%88-02-2018%2020-15-04.gif" alt=""></p><p>然后添加下面两种组件：</p><p><img src="http://owudg3xs2.bkt.clouddn.com/5%E6%9C%88-02-2018%2020-15-15.gif" alt=""></p><p><img src="http://owudg3xs2.bkt.clouddn.com/5%E6%9C%88-02-2018%2020-15-38.gif" alt=""></p><h3 id="定义信号与槽"><a href="#定义信号与槽" class="headerlink" title="定义信号与槽"></a>定义信号与槽</h3><p>在这之前先将设计好的转为<code>.py</code><em>python</em>脚本文件。<code>cd</code>到相应的文件的目录下(即上面的<em>mainwindow.ui</em>所在的目录。注意，此步非常重要！)利用命令行：<code>pyuic5 -o  mainwindow.py mainwindow.ui</code></p><blockquote><p>关于此命令行具体可参考：<a href="https://blog.csdn.net/yingmutongxue/article/details/8487348" target="_blank" rel="external">https://blog.csdn.net/yingmutongxue/article/details/8487348</a><br><strong>(在此需要注意的是，我使用的是<em>pyqt5</em>，所以对应的命令行应当是pyuic5开头，若是<em>pyqt4</em>，则为pyuic4开头了。)</strong></p></blockquote><p>这样在本目录下即可找到转为后的<em>python</em>文件了。</p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-05-02%20%E4%B8%8B%E5%8D%889.04.04.png" alt=""></p><p>再者，我们需要在这个文件实现上面说的思路，即相应的信号与槽机制的代码。因为时间问题，就不在此实现了(是真的写不下去了…)。</p><p>在完成之后，我们直接将此调入<em>eclipse</em>的工程目录下(我用的是<em>eclipse</em>)，之后我们直接调用此文件即可。</p><pre><code>import sysfrom PyQt5.QtWidgets import QApplication , QMainWindowfrom mainwindow import *if __name__ == &apos;__main__&apos;:#     主函数    app = QtWidgets.QApplication(sys.argv)    MainWindow = QtWidgets.QMainWindow()    ui = Ui_MainWindow()    ui.setupUi(MainWindow)    MainWindow.show()    sys.exit(app.exec_())</code></pre><blockquote><p>这样即可完成结合软件设计界面，并在<em>python</em>中运行的一条龙服务了…</p><p>其实在<em>Qt creator</em>中就有信号与槽机制以及快捷键的设置了，这个可参考：<a href="https://wizardforcel.gitbooks.io/qt-beginning/content/60.html" target="_blank" rel="external">https://wizardforcel.gitbooks.io/qt-beginning/content/60.html</a><br>(<strong>全面介绍了</strong>)</p></blockquote><p>简单认识一下设计界面上的那些按钮功能(网上的图，出处忘记了…)</p><p><img src="http://owudg3xs2.bkt.clouddn.com/d.png" alt=""></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>唉..突然感觉直接写代码都还要方便多了…结合软件设计搞的时间浪费的还要多…</p><ul><li>参考：</li></ul><blockquote><p><a href="https://blog.csdn.net/jclian91/article/details/77407723" target="_blank" rel="external">https://blog.csdn.net/jclian91/article/details/77407723</a></p><p><a href="https://maicss.gitbooks.io/pyqt5/content/介绍.html" target="_blank" rel="external">https://maicss.gitbooks.io/pyqt5/content/介绍.html</a><br><strong>(以上所有内容的拼接均可根据此pyqt5库中文教程来进行理解学习，还是一句话，要多动脑多动手实践。)</strong></p><p><a href="https://cuiqingcai.com/5551.html" target="_blank" rel="external">https://cuiqingcai.com/5551.html</a><br><strong>（pyquery的使用教程）</strong></p></blockquote><ul><li>关于将<em>python</em>文件打包生成app的工具库：</li></ul><blockquote><p>py2app:.py –&gt; .dmg</p><p>py2exe:.py –&gt; .exe </p></blockquote><ul><li>关于<em>css选择器</em>等其他内容的快速获取(基于<em>chrome</em>浏览器)：</li></ul><p><img src="http://owudg3xs2.bkt.clouddn.com/5%E6%9C%88-02-2018%2019-33-40.gif" alt=""></p><blockquote><p>看上方的动图，选择完之后粘贴即可得出对应的内容(可适当删除中间字段而不影响达到目的)，当然最好学会一点相关的内容，其实也不难上手。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;平时在获取爬虫之后，会不满足于仅仅得到了结果，而是想经过一个交互式的界面来进一步的完善，获取更多的功能，从而可以更好的展示数据。&lt;/p&gt;
&lt;p&gt;下面运用了&lt;em&gt;python&lt;/em&gt;的&lt;em&gt;pyqt5&lt;/em&gt;库来进行&lt;em&gt;GUI&lt;/em&gt;的设计。&lt;/p&gt;
&lt;p&gt;用&lt;
      
    
    </summary>
    
      <category term="python-GUI学习" scheme="https://liujunjie11.github.io/categories/python-GUI%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="python-GUI学习" scheme="https://liujunjie11.github.io/tags/python-GUI%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>关于Mac的快捷键及fn键设置</title>
    <link href="https://liujunjie11.github.io/2018/04/27/%E5%85%B3%E4%BA%8EMac%E7%9A%84%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%8F%8Afn%E9%94%AE%E8%AE%BE%E7%BD%AE/"/>
    <id>https://liujunjie11.github.io/2018/04/27/关于Mac的快捷键及fn键设置/</id>
    <published>2018-04-27T05:06:18.000Z</published>
    <updated>2018-04-27T07:36:01.031Z</updated>
    
    <content type="html"><![CDATA[<p>最近因为需要，就花了点时间看了一下。本文用于记录下一些常用的在<em>Mac</em>下的一些设置。</p><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><p>关于在认识<em>Macbook</em>的一些快捷键时，进入步骤：<code>系统偏好设置</code> –&gt; <code>键盘</code>–&gt;<code>快捷键</code>–&gt; <code>左边栏</code>。一个一个都看看，发现快捷键系统的都在。</p><p><img src="http://owudg3xs2.bkt.clouddn.com/4%E6%9C%88-27-2018%2015-27-50.gif" alt=""></p><blockquote><p>当然可根据需要自行更改。</p></blockquote><h2 id="fn健的设置"><a href="#fn健的设置" class="headerlink" title="fn健的设置"></a>fn健的设置</h2><p>按下<em>fn</em>健可显示<code>F1</code>～<code>F12</code>的按键，关于如何设置在特定的软件打开时无需按此就显示<code>F1</code>～<code>F12</code>的按键：<code>系统偏好设置</code> –&gt; <code>键盘</code>–&gt;<code>快捷键</code>–&gt;<code>(fn)功能键</code>–&gt;添加软件即可。在这之后会发现打开相应的软件之后，无需按下<em>fn</em>健即可显示出<code>F1</code>～<code>F12</code>的按键了。</p><p><img src="http://owudg3xs2.bkt.clouddn.com/4%E6%9C%88-27-2018%2015-28-06.gif" alt=""></p><h2 id="关于设置文件的默认打开方式"><a href="#关于设置文件的默认打开方式" class="headerlink" title="关于设置文件的默认打开方式"></a>关于设置文件的默认打开方式</h2><p>例子：右键打开一个文件，点击<code>显示简介</code>–&gt;<code>打开方式</code>–&gt;选择好想要默认打开用的软件–&gt;<code>全部更改</code>。再次打开此类型的文件均以选定的软件打开显示。</p><p><img src="http://owudg3xs2.bkt.clouddn.com/4%E6%9C%88-27-2018%2015-28-21.gif" alt=""></p><h2 id="关闭软件通知"><a href="#关闭软件通知" class="headerlink" title="关闭软件通知"></a>关闭软件通知</h2><p>有时用的破解软件经常提醒要更新…<code>系统偏好设置</code> –&gt; <code>通知</code>。里面设置停止通知即可。</p><p><img src="http://owudg3xs2.bkt.clouddn.com/4%E6%9C%88-27-2018%2015-28-39.gif" alt=""></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>如果有时发现没有相关的内容，可先重新启动，再次进行操作。不仅此类型的问题需要重新启动，只要是发现很系统奇怪跟往常不一致时均可通过重新启动来解决。</p><p>以后有需要用的上的再补上。</p><blockquote><p>主要资料可参考<em>Apple</em>官网的说明即可。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近因为需要，就花了点时间看了一下。本文用于记录下一些常用的在&lt;em&gt;Mac&lt;/em&gt;下的一些设置。&lt;/p&gt;
&lt;h2 id=&quot;快捷键&quot;&gt;&lt;a href=&quot;#快捷键&quot; class=&quot;headerlink&quot; title=&quot;快捷键&quot;&gt;&lt;/a&gt;快捷键&lt;/h2&gt;&lt;p&gt;关于在认识&lt;em
      
    
    </summary>
    
      <category term="Mac教程笔记" scheme="https://liujunjie11.github.io/categories/Mac%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Mac教程笔记" scheme="https://liujunjie11.github.io/tags/Mac%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>关于Jupyter Notebook的简单使用</title>
    <link href="https://liujunjie11.github.io/2018/04/21/%E5%85%B3%E4%BA%8EJupyter-Notebook%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <id>https://liujunjie11.github.io/2018/04/21/关于Jupyter-Notebook的简单使用/</id>
    <published>2018-04-21T12:37:03.000Z</published>
    <updated>2018-04-21T13:43:33.581Z</updated>
    
    <content type="html"><![CDATA[<p>关于<em>Jupyter Notebook</em>的介绍就不在此多说了。</p><p>官网教程：</p><blockquote><p><a href="https://jupyter-notebook.readthedocs.io/en/stable/notebook.html" target="_blank" rel="external">https://jupyter-notebook.readthedocs.io/en/stable/notebook.html</a></p></blockquote><p>直接开始介绍整个流程好了。</p><p>先下载<em>Anaconda</em>，里面有包含了现成的<em>Jupyter Notebook</em>，之后我们打开<em>Anaconda</em>客户端即可直接使用<em>Jupyter Notebook</em>了。</p><blockquote><p><em>Anaconda</em>官网：<a href="https://www.anaconda.com/download/#macos" target="_blank" rel="external">https://www.anaconda.com/download/#macos</a></p><p>其中有两个版本，选择需要的下载的版本与完成之后打开的<em>Jupyter Notebook</em>中的<em>python</em>版本是一致的。</p></blockquote><p>打开客户端，进入<em>Jupyter Notebook</em>：</p><p><img src="http://owudg3xs2.bkt.clouddn.com/4%E6%9C%88-21-2018%2020-55-27.gif" alt=""></p><p>在<em>Jupyter Notebook</em>中新建一个文本：</p><p><img src="http://owudg3xs2.bkt.clouddn.com/4%E6%9C%88-21-2018%2020-55-59.gif" alt=""></p><p>在创建了一个脚本文件之后的界面上的小图标各有不同的功能，可以自己点击一下就知道是怎么回事了，再不然可结合文档来进行操作即可。再者接下来就是根据个人的需要来进行编码了，更多的功能暂时用不到，可参考上面的官网教程。</p><blockquote><p>关于<em>Ipython</em>教程可参考：<a href="https://itacey.gitbooks.io/learning_ipython/content/第一章.html" target="_blank" rel="external">https://itacey.gitbooks.io/learning_ipython/content/第一章.html</a></p><p>关于在<em>Mac</em>中使用<em>Jupyter Notebook</em>编码时的快捷键可参考：<a href="https://www.jianshu.com/p/20f6a77dd23c" target="_blank" rel="external">https://www.jianshu.com/p/20f6a77dd23c</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;关于&lt;em&gt;Jupyter Notebook&lt;/em&gt;的介绍就不在此多说了。&lt;/p&gt;
&lt;p&gt;官网教程：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://jupyter-notebook.readthedocs.io/en/stable/notebo
      
    
    </summary>
    
      <category term="python" scheme="https://liujunjie11.github.io/categories/python/"/>
    
    
      <category term="python" scheme="https://liujunjie11.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>搭建Django开发环境</title>
    <link href="https://liujunjie11.github.io/2018/04/19/%E6%90%AD%E5%BB%BADjango%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
    <id>https://liujunjie11.github.io/2018/04/19/搭建Django开发环境/</id>
    <published>2018-04-19T11:00:28.000Z</published>
    <updated>2018-04-19T11:34:00.935Z</updated>
    
    <content type="html"><![CDATA[<p>老早就想将一些数据库里的数据来进行交互式的实现了，之前看了有主要的两种方法：</p><ul><li><p>一是<em>pyQt5</em>这个库，结合<em>Qt creator</em>来进行完成。</p></li><li><p>另外就是通过网页形式来进行交互式的实现了。</p></li></ul><blockquote><p>在接触了前者之后发现学习的时间成本比较高一些，所以打算选择后者了…</p></blockquote><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>在终端使用命令行：<code>pip3 install Django</code></p><blockquote><p>默认<em>python3</em>进行。<em>python2</em>:<code>pip install Django</code>。两者均会下载<em>Django</em>库的最新版本，亦可指定下载那个版本。</p></blockquote><h3 id="测试安装："><a href="#测试安装：" class="headerlink" title="测试安装："></a>测试安装：</h3><p>在编译器中：</p><pre><code>import django  # @UnresolvedImportif __name__ == &apos;__main__&apos;:        print(django.get_version())</code></pre><blockquote><p><strong>在<em>eclipse</em>中会提示导入Django库找不到，但是运行是可以成功的，加上# @UnresolvedImport 让错误提示不再提示。</strong></p></blockquote><p>在终端，先打开<em>python</em>的编译环境，依次输入：</p><pre><code>import djangoprint(django.get_version())</code></pre><blockquote><p>以上两者均会输出下载的<em>Django</em>版本号。</p></blockquote><h2 id="测试Django运行"><a href="#测试Django运行" class="headerlink" title="测试Django运行"></a>测试Django运行</h2><h3 id="项目建立"><a href="#项目建立" class="headerlink" title="项目建立"></a>项目建立</h3><p><code>cd</code> 至编译器或者是IDE的开发环境的目录下，使用创建项目命令：<code>django-admin startproject mysite</code><strong>（其中的mysite是项目名称）</strong>：</p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-19%20%E4%B8%8B%E5%8D%887.33.13.png" alt=""></p><p>创建项目成功之后刷新在编译器的目录，我的是<em>eclipse</em>，可看到项目目录出来了：</p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-19%20%E4%B8%8B%E5%8D%887.30.32.png" alt=""></p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>在上面的基础下<code>cd</code>至新建的项目之下，启动主文件：<code>python manage.py runserver</code>，打开链接<a href="http://127.0.0.1:8000/" target="_blank" rel="external">http://127.0.0.1:8000/</a></p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-19%20%E4%B8%8B%E5%8D%887.30.55.png" alt=""></p><p>出现了Django成功运行的网页：</p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-19%20%E4%B8%8B%E5%8D%887.31.09.png" alt=""></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><ul><li><p>在<em>eclipse</em>中的导入<em>Django</em>提示错误，实际上运行无障碍。</p></li><li><p>详细可参考：</p></li></ul><p><strong><a href="https://docs.djangoproject.com/en/2.0/intro/tutorial01/" target="_blank" rel="external">https://docs.djangoproject.com/en/2.0/intro/tutorial01/</a></strong></p><p><strong><a href="https://www.w3cschool.cn/django/dl5b8ozt.html" target="_blank" rel="external">https://www.w3cschool.cn/django/dl5b8ozt.html</a></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;老早就想将一些数据库里的数据来进行交互式的实现了，之前看了有主要的两种方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;一是&lt;em&gt;pyQt5&lt;/em&gt;这个库，结合&lt;em&gt;Qt creator&lt;/em&gt;来进行完成。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;另外就是通过网页形式来进行交互式的
      
    
    </summary>
    
      <category term="Django" scheme="https://liujunjie11.github.io/categories/Django/"/>
    
    
      <category term="Django" scheme="https://liujunjie11.github.io/tags/Django/"/>
    
  </entry>
  
  <entry>
    <title>关于Parallels Desktop13的简单使用</title>
    <link href="https://liujunjie11.github.io/2018/04/17/%E5%85%B3%E4%BA%8EParallels-Desktop13%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <id>https://liujunjie11.github.io/2018/04/17/关于Parallels-Desktop13的简单使用/</id>
    <published>2018-04-17T01:44:20.000Z</published>
    <updated>2018-04-17T02:03:53.583Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>Parallels Desktop13破解版的下载以及简单的操作可见：<a href="https://blog.csdn.net/weixin_41000111/article/details/79428402" target="_blank" rel="external">https://blog.csdn.net/weixin_41000111/article/details/79428402</a></strong></p></blockquote><p>本文仅仅是做一些补充。</p><h2 id="关于新建一个虚拟机"><a href="#关于新建一个虚拟机" class="headerlink" title="关于新建一个虚拟机"></a>关于新建一个虚拟机</h2><p>比如已经有了一个<em>win</em>系统的虚拟机，想建一个<em>Linux</em>的虚拟机。如下图所示，打开在右上角的<em>Parallels Desktop</em>的小图标，点击<code>新建..</code>即可。</p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-17%20%E4%B8%8A%E5%8D%889.42.25.png" alt=""></p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-17%20%E4%B8%8A%E5%8D%889.42.37.png" alt=""></p><blockquote><p>之后的安装步骤会有点不一致，不过容易上手。</p></blockquote><h2 id="关于Parallels-Desktop13的扩展功能"><a href="#关于Parallels-Desktop13的扩展功能" class="headerlink" title="关于Parallels Desktop13的扩展功能"></a>关于<em>Parallels Desktop13</em>的扩展功能</h2><p>打开在右上角的<em>Parallels Desktop</em>的小图标中的<em>偏好设置</em>，如下图所示下载<em>Toolbox</em>。打开之后发现会有许多的小工具，比如下方的视频下载工具可下载<em>YouTube</em>上的视频文件。更多的新功能可见官网：<strong><a href="https://www.parallels.com/products/desktop/" target="_blank" rel="external">https://www.parallels.com/products/desktop/</a></strong></p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-17%20%E4%B8%8A%E5%8D%889.50.08.png" alt=""></p><p><img src="http://owudg3xs2.bkt.clouddn.com/4%E6%9C%88-17-2018%2010-01-17.gif" alt=""></p><blockquote><p>官网的介绍视频中有相关的详细介绍。</p></blockquote><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>说说体验吧。与我之前用过的虚拟机软件<em>VirtualBox</em>相较，<em>Parallels Desktop</em>明显的运行起来比前者更为流畅，更为人性化一些，并且功能更为强大。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Parallels Desktop13破解版的下载以及简单的操作可见：&lt;a href=&quot;https://blog.csdn.net/weixin_41000111/article/details/79428402&quot; target=&quot;
      
    
    </summary>
    
      <category term="Parallels Desktop" scheme="https://liujunjie11.github.io/categories/Parallels-Desktop/"/>
    
    
      <category term="Parallels Desktop" scheme="https://liujunjie11.github.io/tags/Parallels-Desktop/"/>
    
  </entry>
  
  <entry>
    <title>关于在eclipse中运行scrapy项目</title>
    <link href="https://liujunjie11.github.io/2018/04/13/%E5%85%B3%E4%BA%8E%E5%9C%A8eclipse%E4%B8%AD%E8%BF%90%E8%A1%8Cscrapy%E9%A1%B9%E7%9B%AE/"/>
    <id>https://liujunjie11.github.io/2018/04/13/关于在eclipse中运行scrapy项目/</id>
    <published>2018-04-13T11:23:05.000Z</published>
    <updated>2018-04-13T12:00:46.995Z</updated>
    
    <content type="html"><![CDATA[<p>关于在<em>eclipse</em>中运行爬虫<em>scrapy</em>框架的项目介绍如下。</p><blockquote><p><strong>scrapy官方文档：<a href="http://scrapy-chs.readthedocs.io/zh_CN/0.24/topics/shell.html" target="_blank" rel="external">http://scrapy-chs.readthedocs.io/zh_CN/0.24/topics/shell.html</a></strong></p></blockquote><p>首先打开终端将<code>cd</code>至<em>eclipse</em>目录下的（即<em>eclipse-workspace</em>），使用命令行<code>scrapy startproject tutorial</code>（其中的<em>tutorial</em>是自由选择的），之后会生成一个目录，将其目录移至一个<em>python工程</em>下。</p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-13%20%E4%B8%8B%E5%8D%887.49.25.png" alt=""></p><blockquote><p>如上图。</p></blockquote><p>在<em>spider</em>包下建立一个脚本文件（如上图我的那个<em>first</em>文件，名字随意），是用来写爬虫程序用的。之后在<em>tutorial</em>包下建立一个名为<em>cmdline</em>的脚本文件（名字随意）。</p><p>下面为了直接达到运行成功的目的，贴上测试用的代码。</p><p><strong>first.py中的代码：</strong></p><pre><code>import scrapyclass DmozSpider(scrapy.Spider):    name = &quot;first&quot; #此处很重要    allowed_domains = [&quot;dmoz.org&quot;]    start_urls = [        &quot;http://www.dmoz.org/Computers/Programming/Languages/Python/Books/&quot;,        &quot;http://www.dmoz.org/Computers/Programming/Languages/Python/Resources/&quot;    ]    def parse(self, response):        filename = response.url.split(&quot;/&quot;)[-2]        with open(filename, &apos;wb&apos;) as f:            f.write(response.body)</code></pre><p><strong>cmdline.py中的代码：</strong></p><pre><code>from scrapy.cmdline import executeif __name__ == &apos;__main__&apos;:    #第三个参数就是上方的first文件名！其他两个参数如下正常    execute(argv=[&apos;scrapy&apos;, &apos;crawl&apos;, &apos;first&apos;])</code></pre><p><strong>items.py中的代码：</strong></p><pre><code>import scrapyclass TutorialItem(scrapy.Item):    # define the fields for your item here like:    # name = scrapy.Field()    title = scrapy.Field()    link = scrapy.Field()    desc = scrapy.Field()</code></pre><blockquote><p>这个文件是与<em>first</em>文件有直接联系的。可参考官方文档介绍。</p></blockquote><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>接下来直接运行<em>cmdline.py</em>可得出结果：</p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-13%20%E4%B8%8B%E5%8D%887.50.00.png" alt=""></p><hr><h2 id="配置调试"><a href="#配置调试" class="headerlink" title="配置调试"></a>配置调试</h2><p>直接看下面的图上解说吧。</p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-13%20%E4%B8%8B%E5%8D%887.46.09.png" alt=""></p><hr><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-13%20%E4%B8%8B%E5%8D%887.46.17.png" alt=""></p><blockquote><p>接下来点击debug。</p></blockquote><hr><p><strong>最终两者均可达到输出的效果！</strong></p><p>参考：</p><p><a href="https://blog.csdn.net/otengyue/article/details/48065841" target="_blank" rel="external">https://blog.csdn.net/otengyue/article/details/48065841</a></p><p><a href="http://www.cnblogs.com/v-BigdoG-v/p/7393601.html" target="_blank" rel="external">http://www.cnblogs.com/v-BigdoG-v/p/7393601.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;关于在&lt;em&gt;eclipse&lt;/em&gt;中运行爬虫&lt;em&gt;scrapy&lt;/em&gt;框架的项目介绍如下。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;scrapy官方文档：&lt;a href=&quot;http://scrapy-chs.readthedocs.io/zh_CN/
      
    
    </summary>
    
      <category term="eclispe scrapy" scheme="https://liujunjie11.github.io/categories/eclispe-scrapy/"/>
    
    
      <category term="eclispe scrapy" scheme="https://liujunjie11.github.io/tags/eclispe-scrapy/"/>
    
  </entry>
  
  <entry>
    <title>关于eclipse的风格与主题</title>
    <link href="https://liujunjie11.github.io/2018/04/13/%E5%85%B3%E4%BA%8Eeclipse%E7%9A%84%E9%A3%8E%E6%A0%BC%E4%B8%8E%E4%B8%BB%E9%A2%98/"/>
    <id>https://liujunjie11.github.io/2018/04/13/关于eclipse的风格与主题/</id>
    <published>2018-04-13T04:56:03.000Z</published>
    <updated>2018-04-13T05:21:26.770Z</updated>
    
    <content type="html"><![CDATA[<h2 id="eclipse的界面主题更换"><a href="#eclipse的界面主题更换" class="headerlink" title="eclipse的界面主题更换"></a><em>eclipse</em>的界面主题更换</h2><p>关于我的<em>eclipse</em>的界面主题更换（目前为<em>eclipse Oxygen</em>版本），在内置中已经可以作为一种选择了。</p><p>具体看图所示即可：</p><p><img src="http://owudg3xs2.bkt.clouddn.com/4%E6%9C%88-13-2018%2013-07-55.gif" alt=""></p><blockquote><p>可供的选择有三种，其中的<em>dark</em>类型是比较护眼的，均可试试。</p></blockquote><p>实际的<em>dark</em>展示：</p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-13%20%E4%B8%8B%E5%8D%881.08.27.png" alt=""></p><hr><h2 id="eclipse代码风格更换"><a href="#eclipse代码风格更换" class="headerlink" title="eclipse代码风格更换"></a><em>eclipse</em>代码风格更换</h2><p>可参考此处：<a href="https://blog.csdn.net/zhouchangshi/article/details/37901519" target="_blank" rel="external">https://blog.csdn.net/zhouchangshi/article/details/37901519</a></p><blockquote><p>其中已经有了许多的并且详细的介绍了。</p></blockquote><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li>关于更换编译处的字体大小以及字体选择（如图）:</li></ul><p><img src="http://owudg3xs2.bkt.clouddn.com/4%E6%9C%88-13-2018%2013-11-02.gif" alt=""></p><ul><li>关于控制台的字体更改以及选择（如图）:</li></ul><p><img src="http://owudg3xs2.bkt.clouddn.com/4%E6%9C%88-13-2018%2013-10-41.gif" alt=""></p><hr><p><strong>参考：</strong></p><p><a href="https://jingyan.baidu.com/article/f96699bb9442f3894e3c1b15.html" target="_blank" rel="external">https://jingyan.baidu.com/article/f96699bb9442f3894e3c1b15.html</a></p><p><a href="https://blog.csdn.net/zhouchangshi/article/details/37901519" target="_blank" rel="external">https://blog.csdn.net/zhouchangshi/article/details/37901519</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;eclipse的界面主题更换&quot;&gt;&lt;a href=&quot;#eclipse的界面主题更换&quot; class=&quot;headerlink&quot; title=&quot;eclipse的界面主题更换&quot;&gt;&lt;/a&gt;&lt;em&gt;eclipse&lt;/em&gt;的界面主题更换&lt;/h2&gt;&lt;p&gt;关于我的&lt;em&gt;eclip
      
    
    </summary>
    
      <category term="eclipse" scheme="https://liujunjie11.github.io/categories/eclipse/"/>
    
    
      <category term="eclipse" scheme="https://liujunjie11.github.io/tags/eclipse/"/>
    
  </entry>
  
  <entry>
    <title>python3爬虫：爬取淘宝商品信息的两种方法</title>
    <link href="https://liujunjie11.github.io/2018/04/08/python3%E7%88%AC%E8%99%AB%EF%BC%9A%E7%88%AC%E5%8F%96%E6%B7%98%E5%AE%9D%E5%95%86%E5%93%81%E4%BF%A1%E6%81%AF%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
    <id>https://liujunjie11.github.io/2018/04/08/python3爬虫：爬取淘宝商品信息的两种方法/</id>
    <published>2018-04-08T10:58:00.000Z</published>
    <updated>2018-04-09T03:59:21.431Z</updated>
    
    <content type="html"><![CDATA[<p>爬取淘宝信息：</p><blockquote><p>1，可用<em>selenium</em>模块与<em>driver Chrome</em>插件自动化模拟爬取。</p><p>2， 进行抓包爬取。</p></blockquote><p><strong>下面一一进行介绍并且贴出实现代码。但是在此必须说明一下，因为时间有限，相关模块不懂的还需要自行搜索，在此不做教程解说，只提供分析思路与代码实现过程。</strong></p><blockquote><p>学习博客推荐：<a href="https://cuiqingcai.com，" target="_blank" rel="external">https://cuiqingcai.com，</a><br>实际上我也是根据此博客学习到了一些知识，也是我参考学习的唯一博客。</p></blockquote><h2 id="自动化模拟爬取"><a href="#自动化模拟爬取" class="headerlink" title="自动化模拟爬取"></a>自动化模拟爬取</h2><p>python爬虫的<em>selenium</em>模块是一个可以实现模拟浏览器相关动作，并且可跳过<em>JavaScript动态渲染</em>直接返回其网页源代码的一个自动化测试工具。如下我们需要爬取关键词为<em>MacBook Pro</em>的商品信息，可用它来实现自动翻页并且返回每一页的源代码直接进行相关信息的爬取。</p><h3 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h3><p>下面直接进行分析过程。</p><p>首先打开淘宝主页：<a href="https://www.taobao.com" target="_blank" rel="external">https://www.taobao.com</a> ，进入其中输入关键词观察一下页面，可以看到下面翻页的一些跳转功能。（以下使用的都是<em>Chrome</em>自带的<em>开发者工具</em>）</p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-08%20%E4%B8%8B%E5%8D%888.10.59.png" alt=""></p><p>因为要实现自动翻页的过程，则我们需要查看有关翻页这个功能按钮的源代码是什么样子。其中涉及到了输入框，然后点击旁边的确定按钮。</p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-08%20%E4%B8%8B%E5%8D%888.15.27.png" alt=""></p><blockquote><p>输入框对应的源代码。</p></blockquote><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-08%20%E4%B8%8B%E5%8D%888.18.39.png" alt=""></p><blockquote><p>确定按钮对应的源代码。</p></blockquote><p>在知道了以上的一些按钮信息之后我们还需要知道翻页之后目前对应的页数在哪，以便在对应的页数正确之后，可以得到对应页面的源代码，这样可直接运用一些相关的模块进行节点锁定爬取即可。</p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-08%20%E4%B8%8B%E5%8D%888.19.13.png" alt=""></p><blockquote><p>确定页数码的源代码。</p></blockquote><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-08%20%E4%B8%8B%E5%8D%887.32.20.png" alt=""></p><blockquote><p>页面上商品信息的html源代码。</p></blockquote><p>为什么要这样分析每一个相关功能的源代码？<strong>因为在selenium模块中可以实现自动化的过程，但是需要指定页面上相关的源代码才行，对于selenium来说等于开放了这个功能的接口一样。</strong></p><p><strong>思路分析：将要用相关模块挖掘源代码信息做为一个函数，将要爬取的页面源代码做为一个函数，其中实现自动翻页功能，即若是大于1，自动跳到其页面并且返回其页源代码，否则返回第一页页面的源代码。最后代入前者挖掘的函数。</strong></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code>&apos;&apos;&apos;    函数目标：    利用selenium的自动翻页进行爬去相关的内容    编写时间：    2018-04-07&apos;&apos;&apos;from selenium import webdriverfrom selenium.webdriver.common.by import Byfrom selenium.webdriver.support import expected_conditions as ECfrom selenium.webdriver.support.wait import WebDriverWaitfrom urllib.parse import quotefrom pyquery import PyQuery as pqbrowser = webdriver.Chrome(&apos;/Users/junjieliu/Downloads/小插件/chromedriver&apos;)wait = WebDriverWait(browser, 10)keys = &apos;macbookpro&apos;&apos;&apos;&apos;    函数说明：实现自动化翻页。    仅仅当需要时进行翻页的选项    &apos;&apos;&apos;def index_source(page):    print(&apos;正在爬取第&apos; + str(page) + &apos;页内容..&apos; + &apos;\n&apos; + &apos;.&apos; * 15)    url = &apos;https://s.taobao.com/search?q=&apos; + quote(keys)    browser.get(url)    # 果然页数大于1则自动翻页功能启动    if page &gt; 1:        # 输入框定位        input = wait.until(            EC.presence_of_element_located((By.CSS_SELECTOR, &apos;#mainsrp-pager div.form &gt; input.input.J_Input&apos;)))        # 确定按钮定位        button = wait.until(            EC.element_to_be_clickable((By.CSS_SELECTOR, &apos;#mainsrp-pager div.form &gt; span.btn.J_Submit&apos;)))        # 清理，输入，点击一体化        input.clear()        input.send_keys(page)        button.click()    &apos;&apos;&apos;    获取源代码，传入爬取数据的函数    获取源代码过程：    第一步确定为在那一页    第二步确定爬取内容    &apos;&apos;&apos;    wait.until(        EC.text_to_be_present_in_element((By.CSS_SELECTOR, &apos;#mainsrp-pager li.item.active &gt; span.num&apos;), str(page)))    wait.until(        EC.presence_of_element_located((By.CSS_SELECTOR, &apos;.m-itemlist .items .item&apos;)))    print(&apos;获取本页源码成功，以下为相关的信息：&apos; + &apos;\n&apos;)    get_product()&apos;&apos;&apos;    函数说明：    用pyquery爬取其中的商品内容    &apos;&apos;&apos;def get_product():    html_source = browser.page_source    doc = pq(html_source)    items = doc(&apos;#mainsrp-itemlist .items .item&apos;).items()    &apos;&apos;&apos;        以下匹配内容可查看网页源代码可知        &apos;&apos;&apos;    for item in items:        product_infos = {            &apos;img_url&apos;:&apos;https:&apos; + item.find(&apos;.pic .img&apos;).attr(&apos;data-src&apos;),  # 店铺主图片地址            &apos;product_desc&apos;:item.find(&apos;.pic .img&apos;).attr(&apos;alt&apos;),  # 商品描述            &apos;price&apos;:item.find(&apos;.price&apos;).text().replace(&apos;\n&apos;, &apos;&apos;),  # 价格            &apos;people&apos;:item.find(&apos;.deal-cnt&apos;).text(),  # 购买人数            &apos;shop_url&apos;:&apos;https:&apos; + item.find(&apos;.shop .shopname&apos;).attr(&apos;href&apos;),  # 店铺信息            &apos;shop_name&apos;:item.find(&apos;.shop&apos;).text(),  # 店铺名称            &apos;shop_location&apos;:item.find(&apos;.location&apos;).text()  # 店铺所在地            }        print(product_infos)if __name__ == &apos;__main__&apos;:    pages = 100  # 根据页面分析可知总共有100页的信息    for num in range(1, pages + 1):        index_source(num)     </code></pre><blockquote><p>当然还可以进行正则表达式的匹配来完成爬取，因为需要时间来测试相关的表达式，所以推荐用<em>pyquery</em>这个库来完成爬取工作，相比于使用过的<em>beautiful</em>模块以及正则表达式，我感觉轻松了不少。</p></blockquote><h2 id="抓包爬取"><a href="#抓包爬取" class="headerlink" title="抓包爬取"></a>抓包爬取</h2><p>以下的抓包是利用的<em>Chrome</em>浏览器完成的，在这之前说了，因为时间关系，关于抓包是什么就不在此做详细介绍了…相信你看了我下面的分析过程会隐约明白一点。</p><h3 id="分析过程-1"><a href="#分析过程-1" class="headerlink" title="分析过程"></a>分析过程</h3><p>打开淘宝主页，输入关键词，在第一页上打开<em>Chrome</em>自带的<em>开发者工具</em>，这样就可以看到第一页的源代码信息了。以下图过程可以看到我们在第一页抓到的相关的<em>淘宝API</em>的数据包。里面有相关的商品信息，均为<em>json</em>格式。</p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-08%20%E4%B8%8B%E5%8D%887.55.32.png" alt=""></p><hr><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-08%20%E4%B8%8B%E5%8D%887.56.39.png" alt=""></p><blockquote><p>其中的<em>XHR格式</em>不懂可参考此篇文章：<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest" target="_blank" rel="external">https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest</a></p></blockquote><p>浏览器新建一个标签页，打开上面的那个地址看看有什么。</p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-08%20%E4%B8%8B%E5%8D%888.24.11.png" alt=""></p><p><strong>经过一系列的测试发现了其中的那个参数<em>bcoffset=</em>是跳转的决定点，更改其值可得到不同的信息。</strong>这样我们进行思路分析就一目了然了。</p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-08%20%E4%B8%8B%E5%8D%888.21.47.png" alt=""></p><p><strong>思路分析：传入上面的说的API的URL，根据上面的那个参数的值更改，返回其中的文档信息，即可爬取到商品信息。</strong></p><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code>&apos;&apos;&apos;    函数说明：    利用抓包返回的信息直接爬取商品信息    编写时间：    2018-04-08&apos;&apos;&apos;import requestsimport reif __name__ == &apos;__main__&apos;:    # 设定爬取100页，实际上还要多...    pages = 100    for num in range(1, pages + 1):        print(&apos;开始爬取第&apos; + str(num) + &apos;页内容...&apos; + &apos;\n&apos; + &apos;.&apos; * 10)        url = &apos;https://s.taobao.com/api?_ksTS=1523191565870_226&amp;callback=jsonp227&amp;ajax=true&amp;m=customized&amp;stats_click=search_radio_all:1&amp;q=macbookpro&amp;p4ppushleft=1,48&amp;ntoffset=4&amp;s=36&amp;imgfile=&amp;initiative_id=staobaoz_20180408&amp;bcoffset=&apos; + str(num) + &apos;&amp;js=1&amp;ie=utf8&amp;rn=5bd3f39c2ca57f21abe4db8ca60ee49f&apos;        # 代理信息        header = {                &apos;cookie&apos;: &apos;t=da97f7b09403e3340cd6d50780a9385e; cna=PoshExqPgw0CAQG9KdLV29qM; hng=CN%7Czh-CN%7CCNY%7C156; thw=cn; enc=MuF%2FWOzFnau5EcbgcPck31M%2FMhER8txA4ZnjdZI2Dt8xzHdAr%2FN4f0OsOD%2FUcrNpOZWIfEG0GSbPQ8C4U%2BU70A%3D%3D; mt=ci%3D-1_1; cookie2=1f17bf1dfa8b6cf01c17d0fe7306c672; v=0; _tb_token_=eaefe3a15f0bf; JSESSIONID=0BC0D7637EFFD50CA56F8A8F4E451813; isg=BD09zFTCO5bo0p_z6P-VaFHGTJ_3cnEiA2cTwf-D2RRsNl5oySop_Xqg5Wpwlonk&apos;,                &apos;referer&apos;: &apos;https://s.taobao.com/search?q=macbookpro&amp;imgfile=&amp;js=1&amp;stats_click=search_radio_all%3A1&amp;initiative_id=staobaoz_20180408&amp;ie=utf8&amp;bcoffset=4&amp;p4ppushleft=1%2C48&amp;ntoffset=4&amp;s=0&apos;,                &apos;user-agent&apos;: &apos;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.181 Safari/537.36&apos;,                &apos;x-requested-with&apos;: &apos;XMLHttpRequest&apos;}        responed = requests.get(url=url, headers=header)        # 指定编码格式        responed.encoding = &apos;utf-8&apos;        re_text = responed.text        &apos;&apos;&apos;            进入数据清洗与筛选阶段            因为转化json格式始终失败...所以改用正则表达式来进行匹配        &apos;&apos;&apos;        print(&apos;获取源代码成功，以下为相关商品的信息：&apos;)        target = re.findall(r&apos;&quot;raw_title&quot;:&quot;(.*?)&quot;.*?&quot;pic_url&quot;:&quot;(.*?)&quot;.*?&quot;view_price&quot;:&quot;(.*?)&quot;.*?&quot;item_loc&quot;:&quot;(.*?)&quot;.*?&quot;view_sales&quot;:&quot;(.*?)&quot;.*?&quot;user_id&quot;:&quot;(.*?)&quot;.*?&quot;nick&quot;:&quot;(.*?)&quot;&apos;, re_text, re.S)  # @UndefinedVariable        for each in target:            product = {                &apos;shop_title&apos;:each[0],  # 店铺主题                &apos;pic_url&apos;:&apos;https:&apos; + each[1],  # 店铺图片地址                &apos;price&apos;:each[2],  # 价格                &apos;sales_people&apos;:each[4],  # 购买人数                &apos;shop_name&apos;:each[6],  # 店铺名称                &apos;loc&apos;:each[3],  # 店铺所在地                &apos;shop_url&apos;:&apos;https://store.taobao.com/shop/view_shop.htm?user_number_id=&apos; + each[5]  # 店铺URL地址                    }            print(product)</code></pre><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>第二种方法期间原本以为可以先转化为<em>json格式</em>来进行处理，没想到发生了<strong>json.decoder.JSONDecodeError:</strong>的错误，结果改用正则表达式进行文本的挖掘，效率也是无形中得到了提升…在此我推荐用正则表达式来处理<em>json格式</em>的文档，这样在绝大多数情况下可能会有更高的效率！</p><p>爬取到的数据可用来进行一些数据分析等等。有时想尝试用各种方法去爬取，但是因为学的东西真的多，所以就不一一尝试了，尽量使用简便的方法…不懂的朋友还需要多多学习，利用好搜索引擎！当然看书也是必须的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;爬取淘宝信息：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1，可用&lt;em&gt;selenium&lt;/em&gt;模块与&lt;em&gt;driver Chrome&lt;/em&gt;插件自动化模拟爬取。&lt;/p&gt;
&lt;p&gt;2， 进行抓包爬取。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;下面一一进
      
    
    </summary>
    
      <category term="python爬虫" scheme="https://liujunjie11.github.io/categories/python%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="python爬虫" scheme="https://liujunjie11.github.io/tags/python%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>关于记录Chromedriver的selenium.common.exceptions.WebDriverException: Message: &#39;chromedriver &#39; executable needs to be in PATH. Please see https://sites.google.com/a/chromium.org/chromedriver/home</title>
    <link href="https://liujunjie11.github.io/2018/04/05/%E5%85%B3%E4%BA%8E%E8%AE%B0%E5%BD%95Chromedriver%E7%9A%84selenium-common-exceptions-WebDriverException-Message-chromedriver-executable-needs-to-be-in-PATH-Please-see-https-sites-google-com-a-chromium-org-chromedriver-home/"/>
    <id>https://liujunjie11.github.io/2018/04/05/关于记录Chromedriver的selenium-common-exceptions-WebDriverException-Message-chromedriver-executable-needs-to-be-in-PATH-Please-see-https-sites-google-com-a-chromium-org-chromedriver-home/</id>
    <published>2018-04-05T11:46:15.000Z</published>
    <updated>2018-04-05T12:01:34.821Z</updated>
    
    <content type="html"><![CDATA[<p>最近学习一些<em>python</em>爬虫的框架，用<em>selenium</em>与<em>Chromedriver</em>插件结合<em>Chrome浏览器</em>来爬去网页源数据。</p><p>发现了如题的错误信息：</p><blockquote><p>selenium.common.exceptions.WebDriverException: Message:<br>  ‘chromedriver ‘ executable needs to be in PATH. Please see<br>  <a href="https://sites.google.com/a/chromium.org/chromedriver/home" target="_blank" rel="external">https://sites.google.com/a/chromium.org/chromedriver/home</a></p></blockquote><p>在已配置好系统环境的前提下，用如下代码指定位置，或者是将<em>Chromedriver</em>插件放在工程文件下，均得到了如上的错误信息。</p><pre><code>from selenium import webdriverbrowser = webdriver.Chrome(&apos;/Users/junjieliu/Downloads/小插件/chromedriver&apos;)</code></pre><hr><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>如下操作，先将插件打开（即表示打开运行了，<strong>在需要使用时应当一直开着</strong>），跳出来了其所在位置，将其位置复制再运行上面的代码，发现跳出来了一个<em>Chrome浏览器</em>的空白页面，这表示已经成功了！</p><p><img src="http://owudg3xs2.bkt.clouddn.com/4%E6%9C%88-05-2018%2019-56-36.gif" alt=""></p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-05%20%E4%B8%8B%E5%8D%888.00.03.png" alt=""></p><blockquote><p>成功的页面。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近学习一些&lt;em&gt;python&lt;/em&gt;爬虫的框架，用&lt;em&gt;selenium&lt;/em&gt;与&lt;em&gt;Chromedriver&lt;/em&gt;插件结合&lt;em&gt;Chrome浏览器&lt;/em&gt;来爬去网页源数据。&lt;/p&gt;
&lt;p&gt;发现了如题的错误信息：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p
      
    
    </summary>
    
      <category term="爬虫" scheme="https://liujunjie11.github.io/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="爬虫" scheme="https://liujunjie11.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>python3爬取豆瓣Top250电影信息</title>
    <link href="https://liujunjie11.github.io/2018/04/03/python3%E7%88%AC%E5%8F%96%E8%B1%86%E7%93%A3Top250%E7%94%B5%E5%BD%B1%E4%BF%A1%E6%81%AF/"/>
    <id>https://liujunjie11.github.io/2018/04/03/python3爬取豆瓣Top250电影信息/</id>
    <published>2018-04-03T14:09:36.000Z</published>
    <updated>2018-04-04T02:29:05.477Z</updated>
    
    <content type="html"><![CDATA[<p>以下是通过正则表达式爬取的<em>猫眼电影</em>以及<em>豆瓣电影</em>的相关的电影信息的代码过程。</p><hr><h2 id="爬取猫眼电影"><a href="#爬取猫眼电影" class="headerlink" title="爬取猫眼电影"></a>爬取猫眼电影</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>打开<em>Chrome</em>的调试工具，可发现相关的信息都在，并且以翻页的形式来得到更多的电影信息。</p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-04%20%E4%B8%8A%E5%8D%8810.17.59.png" alt=""></p><blockquote><p>我们可通过其爬取需要的信息，利用正则表达式来进行文本的挖掘。</p></blockquote><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code>&apos;&apos;&apos;    函数目标：    爬取猫眼电影的top100信息    编写时间：    2018-03-28&apos;&apos;&apos;&apos;&apos;&apos;import requestsimport reimport jsonif __name__ == &apos;__main__&apos;:print(&apos;猫眼电影Top100信息如下：&apos;)#循环10次，得出页面上的Top100的电影信息for i in range(0, 10):    url = &quot;http://maoyan.com/board/4?&quot;    header = {            &apos;Host&apos;:&apos;maoyan.com&apos;,            &apos;Referer&apos;:&apos;http://maoyan.com/board/4?offset=20&apos;,            &apos;User-Agent&apos;:&apos;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.181 Safari/537.36&apos;}    paramters = {            &apos;offset&apos;: i * 10}    request_tasget = requests.get(url=url, headers=header, params=paramters)    request_tasget.encoding = &apos;utf-8&apos;    # 实际上应该考虑考虑网的问题...连不上就一般没有数据返回了，找一个字符作为接口之后利用万能表达式即可    infos_list = re.findall(    r&apos;&lt;dd&gt;.*?board-index.*?&gt;(.*?)&lt;/i&gt;.*?alt.*?src=&quot;(.*?)&quot;.*?&lt;a.*?&gt;(.*?)&lt;/a&gt;.*?&quot;star&quot;&gt;(.*?)&lt;/p&gt;.*?&quot;releasetime&quot;&gt;(.*?)&lt;/p&gt;.*?&quot;integer&quot;&gt;(.*?)&lt;/i&gt;.*?&quot;fraction&quot;&gt;(.*?)&lt;/i&gt;&apos;,    request_tasget.text, re.S)  # @UndefinedVariable    #建立存储信息的字典    for each in infos_list:        yields = {                &apos;index&apos;:each[0],                &apos;image_info&apos;:each[1],                &apos;name&apos;:each[2],                &apos;actor&apos;:each[3].strip(),                &apos;time&apos;:each[4],                &apos;score&apos;:each[5] + each[6]                }        print(yields)</code></pre><h2 id="爬取豆瓣电影"><a href="#爬取豆瓣电影" class="headerlink" title="爬取豆瓣电影"></a>爬取豆瓣电影</h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>与爬取猫眼电影信息一样，都是一样的，具体的差距还是在豆瓣上爬取信息需要<em>cookie</em>，具体可参考下面的代码。</p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-04%20%E4%B8%8A%E5%8D%8810.18.27.png" alt=""></p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><pre><code>&apos;&apos;&apos;    函数目标：    爬取豆瓣Top250的电影信息    编写时间：    2018-04-01&apos;&apos;&apos;import requestsimport re if __name__ == &apos;__main__&apos;:print(&apos;以下为豆瓣Top250的电影信息：&apos;)# 从页面可看到一共有十页，每页上有25个电影的信息for i in range(0, 10):    url = &quot;https://movie.douban.com/top250?&quot;    header = {            &apos;Connection&apos;: &apos;keep-alive&apos;,            &apos;Cookie&apos;: &apos;bid=x9ipkoKiQgw; _pk_ses.100001.4cf6=*; __utma=30149280.2001666009.1522587991.1522587991.1522587991.1; __utmb=30149280.0.10.1522587991; __utmc=30149280; __utmz=30149280.1522587991.1.1.utmcsr=(direct)|utmccn=(direct)|utmcmd=(none); __utma=223695111.1530785565.1522587991.1522587991.1522587991.1; __utmb=223695111.0.10.1522587991; __utmc=223695111; __utmz=223695111.1522587991.1.1.utmcsr=(direct)|utmccn=(direct)|utmcmd=(none); ll=&quot;118146&quot;; _vwo_uuid_v2=D575771A914BC38B3B7D081C0A0296FDC|939d8f7fdff1f383a97d572dab39fa1a; _pk_id.100001.4cf6=1de732c7ac4dc22b.1522587990.1.1522588516.1522587990.; ct=y&apos;,            &apos;Host&apos;: &apos;movie.douban.com&apos;,            &apos;Referer&apos;: &apos;https://movie.douban.com/top250?start=25&amp;filter=&apos;,            &apos;Upgrade-Insecure-Requests&apos;: &apos;1&apos;,            &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.181 Safari/537.36}&apos;             }    paramters = {             &apos;start&apos;: i * 25,             &apos;filter&apos;:&apos;&apos;              }    tasget = requests.get(url=url, headers=header, params=paramters)    tasget.encoding = &apos;utf-8&apos;    # 匹配正则表达式    infos = re.findall(r&apos;&lt;li&gt;.*?&lt;em class=&quot;&quot;&gt;(.*?)&lt;/em&gt;.*?alt=.*?src=&quot;(.*?)&quot;.*?&quot;title&quot;&gt;(.*?)&lt;/span&gt;.*?class=&quot;title&quot;&gt;&amp;nbsp;/&amp;nbsp;(.*?)&lt;/span&gt;.*?&quot;other&quot;&gt;&amp;nbsp;/&amp;nbsp;(.*?)&lt;/span&gt;.*?&lt;p class=&quot;&quot;&gt;(.*?)&amp;nbsp;&amp;nbsp;&amp;nbsp;(.*?)&lt;br&gt;(.*?)&amp;nbsp;/&amp;nbsp(.*?)&amp;nbsp;/&amp;nbsp(.*?)&lt;/p&gt;.*?average&quot;&gt;(.*?)&lt;/span&gt;&apos;, tasget.text, re.S)  # @UndefinedVariable    # 建立一个空字典用于存储相关的信息    for each in infos:        yields = {            &apos;index&apos;:each[0],  # 排名            &apos;img_info&apos;:each[1],  # 照片地址            &apos;name&apos;:each[2].strip() + &quot;/&quot; + each[3].strip() + &quot;/&quot; + each[4].strip(),  # 影片名称            &apos;director&apos;:each[5].strip(),  # 导演            &apos;actor&apos;:each[6],  # 演员            &apos;time_cy&apos;:each[7].strip() + each[8],  # 上演时间及地区            &apos;type&apos;:each[9].strip(),  # 影片类型            &apos;score&apos;:each[10]  # 评分            }        print(yields)</code></pre><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>简单说说其中的含义，表达式<code>.*?</code>是一个万能的匹配式，<code>(.*?)</code>是匹配想要爬取的内容，并且每一次伴随着一个索引号，每一个索引号对应着的信息不同。利用正则表达式可方便的进行文本与代码的分开挖掘，一般在写正则表达式时用<em>html</em>代码中的一些词来进行过渡就可以方便的写出来了。</p><blockquote><p>多说无益，还是需要自己来进行代码的测试了解的。</p></blockquote><ul><li>参考的博客：<a href="https://cuiqingcai.com" target="_blank" rel="external">https://cuiqingcai.com</a></li></ul><blockquote><p>可根据此博客来学习更多的爬虫知识。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;以下是通过正则表达式爬取的&lt;em&gt;猫眼电影&lt;/em&gt;以及&lt;em&gt;豆瓣电影&lt;/em&gt;的相关的电影信息的代码过程。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;爬取猫眼电影&quot;&gt;&lt;a href=&quot;#爬取猫眼电影&quot; class=&quot;headerlink&quot; title=&quot;爬取猫眼电影&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
      <category term="python爬虫" scheme="https://liujunjie11.github.io/categories/python%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="python3爬虫" scheme="https://liujunjie11.github.io/tags/python3%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>Mac下的mysql安装以及相关的问题解决</title>
    <link href="https://liujunjie11.github.io/2018/04/03/Mac%E4%B8%8B%E7%9A%84mysql%E5%AE%89%E8%A3%85%E4%BB%A5%E5%8F%8A%E7%9B%B8%E5%85%B3%E7%9A%84%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
    <id>https://liujunjie11.github.io/2018/04/03/Mac下的mysql安装以及相关的问题解决/</id>
    <published>2018-04-03T11:48:48.000Z</published>
    <updated>2018-04-03T12:58:55.064Z</updated>
    
    <content type="html"><![CDATA[<p>最近因为学习到了爬虫的原因，存储数据需要<em>mysql</em>了，因为以前学习过其命令行，所以在之前安装过了，太久没用了，怎么开都不懂了，搞了几十分钟不想搞了，重新安装。下面记录下遇到的一些问题。</p><hr><h2 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h2><h3 id="第一种方法"><a href="#第一种方法" class="headerlink" title="第一种方法"></a>第一种方法</h3><p>进入官网下载对应<em>Mac</em>的<em>mysql</em>。</p><blockquote><p><a href="https://dev.mysql.com/downloads/mysql/" target="_blank" rel="external">官网地址</a></p></blockquote><h3 id="第二种方法"><a href="#第二种方法" class="headerlink" title="第二种方法"></a>第二种方法</h3><p>直接用命令行<code>brew Install mysql</code>。</p><blockquote><p>前提是必须安装了<em>homebrew</em>。</p></blockquote><h2 id="配置以及开启过程"><a href="#配置以及开启过程" class="headerlink" title="配置以及开启过程"></a>配置以及开启过程</h2><h3 id="配置过程"><a href="#配置过程" class="headerlink" title="配置过程"></a>配置过程</h3><p>在手动安装正后一步记下默认的密码（如下图）。</p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-03%20%E4%B8%8B%E5%8D%888.34.15.png" alt=""></p><blockquote><p>即<strong>QeV.a&gt;zGa1m3</strong>为默认密码。</p></blockquote><p>在<em>偏好系统</em>中手动打开<em>mysql</em>应用。</p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-03%20%E4%B8%8B%E5%8D%888.34.36.png" alt=""></p><p>之后打开终端，为其配置。（命令行如下依次）</p><p><code>vi ~/bash_profile</code></p><p>进入按字母<em>i</em>进入编辑模式，输入：</p><p><code>export PATH=&quot;$PATH:/usr/local/mysql/bin&quot;</code></p><blockquote><p>在此可能有疑惑，为什么可以直接<code>mysql/bin</code>？因为在我们手动下载<br><em>mysql</em>之后系统已经自动的复制了一遍，并且将其名为<em>mysql</em>，如图在<em>/usr/local/</em>可找到。</p></blockquote><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-03%20%E4%B8%8B%E5%8D%888.18.02.png" alt=""></p><hr><p>接着输入相关的命令…这时已经配置好了，按下<em>esc</em>健进入命令行模式，输入<code>：wq</code>,推出。之后为了快速见效输入<code>source ~/bash_profile</code></p><h3 id="启动过程"><a href="#启动过程" class="headerlink" title="启动过程"></a>启动过程</h3><p>输入命令行<code>mysql -uroot -p</code>,提示输入刚刚的默认密码，进入到了<em>mysql</em>的编译界面之后，我们修改默认密码，输入代码<code>set PASSWORD =PASSWORD(&#39;123456&#39;);</code></p><blockquote><p><strong>其中的<em>123456</em>为新的密码。</strong></p></blockquote><p>之后为测试是否已经修改成功，输入<code>exit();</code>推出界面，输入命令行<code>mysql -uroot -p</code>,提示输入刚刚的新密码，成功进入编译界面。</p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-03%20%E4%B8%8B%E5%8D%888.32.00.png" alt=""></p><h2 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h2><p>可参考：<a href="https://www.jianshu.com/p/b02be6026a2a" target="_blank" rel="external">https://www.jianshu.com/p/b02be6026a2a</a></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p><strong>解决问题：ERROR 1045 (28000): Access denied for user ‘root’@’localhost’ (using password: YES)</strong></p><p>可参考：<a href="https://www.digitalocean.com/community/questions/setup-mysql-on-ubuntu-droplet-getting-error-error-1045-28000-access-denied-for-user-root-localhost-using-password-yes" target="_blank" rel="external">https://www.digitalocean.com/community/questions/setup-mysql-on-ubuntu-droplet-getting-error-error-1045-28000-access-denied-for-user-root-localhost-using-password-yes</a></p><p><strong>解决进程问题</strong></p><p>可参考：<a href="https://blog.csdn.net/liumaolincycle/article/details/51896592" target="_blank" rel="external">https://blog.csdn.net/liumaolincycle/article/details/51896592</a></p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>有时下载完之后也会出现上面的那个问题，我是通过重新启动电脑之后获得了解决。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近因为学习到了爬虫的原因，存储数据需要&lt;em&gt;mysql&lt;/em&gt;了，因为以前学习过其命令行，所以在之前安装过了，太久没用了，怎么开都不懂了，搞了几十分钟不想搞了，重新安装。下面记录下遇到的一些问题。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;安装过程&quot;&gt;&lt;a href=&quot;#安装
      
    
    </summary>
    
      <category term="mysql" scheme="https://liujunjie11.github.io/categories/mysql/"/>
    
    
      <category term="mysql" scheme="https://liujunjie11.github.io/tags/mysql/"/>
    
  </entry>
  
</feed>
