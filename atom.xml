<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LXiHa`Notes</title>
  
  <subtitle>The House Belong to Love and Freedom.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://liujunjie11.github.io/"/>
  <updated>2018-05-07T04:50:09.623Z</updated>
  <id>https://liujunjie11.github.io/</id>
  
  <author>
    <name>刘俊</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>(转)五大常用算法总结</title>
    <link href="https://liujunjie11.github.io/2018/05/07/%E8%BD%AC-%E4%BA%94%E5%A4%A7%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>https://liujunjie11.github.io/2018/05/07/转-五大常用算法总结/</id>
    <published>2018-05-07T04:22:27.000Z</published>
    <updated>2018-05-07T04:50:09.623Z</updated>
    
    <content type="html"><![CDATA[<p>本文转自：</p><blockquote><p><strong>博客园：<a href="http://www.cnblogs.com/steven_oyj/archive/2010/05/22/1741370.html" target="_blank" rel="external">http://www.cnblogs.com/steven_oyj/archive/2010/05/22/1741370.html</a></strong><br><strong>作者：红脸书生</strong></p></blockquote><hr><h1 id="分治算法"><a href="#分治算法" class="headerlink" title="分治算法"></a>分治算法</h1><h2 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><p>   在计算机科学中，分治法是一种很重要的算法。字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，再把子问题分成更小的子问题……直到最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。这个技巧是很多高效算法的基础，如排序算法(快速排序，归并排序)，傅立叶变换(快速傅立叶变换)……</p><p>   任何一个可以用计算机求解的问题所需的计算时间都与其规模有关。问题的规模越小，越容易直接求解，解题所需的计算时间也越少。例如，对于n个元素的排序问题，当n=1时，不需任何计算。n=2时，只要作一次比较即可排好序。n=3时只要作3次比较即可，…。而当n较大时，问题就不那么容易处理了。要想直接解决一个规模较大的问题，有时是相当困难的。</p><h2 id="二、基本思想及策略"><a href="#二、基本思想及策略" class="headerlink" title="二、基本思想及策略"></a>二、基本思想及策略</h2><p>   <strong>分治法的设计思想是：</strong>将一个难以直接解决的大问题，分割成一些规模较小的相同问题，以便各个击破，分而治之。</p><p>   <strong>分治策略是：</strong>对于一个规模为n的问题，若该问题可以容易地解决（比如说规模n较小）则直接解决，否则将其分解为k个规模较小的子问题，这些子问题互相独立且与原问题形式相同，递归地解这些子问题，然后将各子问题的解合并得到原问题的解。这种算法设计策略叫做分治法。</p><p>   如果原问题可分割成k个子问题，1&lt;k≤n，且这些子问题都可解并可利用这些子问题的解求出原问题的解，那么这种分治法就是可行的。由分治法产生的子问题往往是原问题的较小模式，这就为使用递归技术提供了方便。在这种情况下，反复应用分治手段，可以使子问题与原问题类型一致而其规模却不断缩小，最终使子问题缩小到很容易直接求出其解。这自然导致递归过程的产生。分治与递归像一对孪生兄弟，经常同时应用在算法设计之中，并由此产生许多高效算法。</p><h2 id="三、分治法适用的情况"><a href="#三、分治法适用的情况" class="headerlink" title="三、分治法适用的情况"></a>三、分治法适用的情况</h2><ul><li><p>分治法所能解决的问题一般具有以下几个特征：</p><p>（1) 该问题的规模缩小到一定的程度就可以容易地解决</p><p>（2) 该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质。</p><p>（3) 利用该问题分解出的子问题的解可以合并为该问题的解；</p><p>（4) 该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子子问题。</p></li></ul><blockquote><p>第一条特征是绝大多数问题都可以满足的，因为问题的计算复杂性一般是随着问题规模的增加而增加；</p><p>第二条特征是应用分治法的前提它也是大多数问题可以满足的，此特征反映了递归思想的应用；、</p><p>第三条特征是关键，能否利用分治法完全取决于问题是否具有第三条特征，如果具备了第一条和第二条特征，而不具备第三条特征，则可以考虑用贪心法或动态规划法。</p><p>第四条特征涉及到分治法的效率，如果各子问题是不独立的则分治法要做许多不必要的工作，重复地解公共的子问题，此时虽然可用分治法，但一般用动态规划法较好。</p></blockquote><h2 id="四、分治法的基本步骤"><a href="#四、分治法的基本步骤" class="headerlink" title="四、分治法的基本步骤"></a>四、分治法的基本步骤</h2><p>分治法在每一层递归上都有三个步骤：</p><ul><li><p>step1 分解：将原问题分解为若干个规模较小，相互独立，与原问题形式相同的子问题；</p></li><li><p>step2 解决：若子问题规模较小而容易被解决则直接解，否则递归地解各个子问题</p></li><li><p>step3 合并：将各个子问题的解合并为原问题的解。</p></li></ul><p>它的一般的算法设计模式如下：</p><pre><code>Divide-and-Conquer(P)1. if |P|≤n02. then return(ADHOC(P))3. 将P分解为较小的子问题 P1 ,P2 ,...,Pk4. for i←1 to k5. do yi ← Divide-and-Conquer(Pi) △ 递归解决Pi6. T ← MERGE(y1,y2,...,yk) △ 合并子问题7. return(T)</code></pre><blockquote><p>   其中|P|表示问题P的规模；n0为一阈值，表示当问题P的规模不超过n0时，问题已容易直接解出，不必再继续分解。ADHOC(P)是该分治法中的基本子算法，用于直接解小规模的问题P。因此，当P的规模不超过n0时直接用算法ADHOC(P)求解。算法MERGE(y1,y2,…,yk)是该分治法中的合并子算法，用于将P的子问题P1 ,P2 ,…,Pk的相应的解y1,y2,…,yk合并为P的解。</p></blockquote><h2 id="五、分治法的复杂性分析"><a href="#五、分治法的复杂性分析" class="headerlink" title="五、分治法的复杂性分析"></a>五、分治法的复杂性分析</h2><p>   一个分治法将规模为n的问题分成k个规模为n／m的子问题去解。设分解阀值n0=1，且adhoc解规模为1的问题耗费1个单位时间。再设将原问题分解为k个子问题以及用merge将k个子问题的解合并为原问题的解需用f(n)个单位时间。用T(n)表示该分治法解规模为|P|=n的问题所需的计算时间，则有：</p><p> T（n）= k T(n/m)+f(n)</p><p>  通过迭代法求得方程的解：</p><p>  递归方程及其解只给出n等于m的方幂时T(n)的值，但是如果认为T(n)足够平滑，那么由n等于m的方幂时T(n)的值可以估计T(n)的增长速度。通常假定T(n)是单调上升的，从而当mi≤n&lt;mi+1时，T(mi)≤T(n)&lt;T(mi+1)。 </p><h2 id="六、可使用分治法求解的一些经典问题"><a href="#六、可使用分治法求解的一些经典问题" class="headerlink" title="六、可使用分治法求解的一些经典问题"></a>六、可使用分治法求解的一些经典问题</h2><p> （1）二分搜索<br> （2）大整数乘法<br> （3）Strassen矩阵乘法<br> （4）棋盘覆盖<br> （5）合并排序<br> （6）快速排序<br> （7）线性时间选择</p><p> （8）最接近点对问题<br> （9）循环赛日程表<br> （10）汉诺塔</p><h2 id="七、依据分治法设计程序时的思维过程"><a href="#七、依据分治法设计程序时的思维过程" class="headerlink" title="七、依据分治法设计程序时的思维过程"></a>七、依据分治法设计程序时的思维过程</h2><blockquote><p>   实际上就是类似于数学归纳法，找到解决本问题的求解方程公式，然后根据方程公式设计递归程序。</p></blockquote><p>1、一定是先找到最小问题规模时的求解方法</p><p>2、然后考虑随着问题规模增大时的求解方法</p><p>3、找到求解的递归函数式后（各种规模或因子），设计递归程序即可。</p><h1 id="动态规划算法"><a href="#动态规划算法" class="headerlink" title="动态规划算法"></a>动态规划算法</h1><h2 id="一、基本概念-1"><a href="#一、基本概念-1" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><p>   动态规划过程是：每次决策依赖于当前状态，又随即引起状态的转移。一个决策序列就是在变化的状态中产生出来的，所以，这种多阶段最优化决策解决问题的过程就称为动态规划。</p><h2 id="二、基本思想与策略"><a href="#二、基本思想与策略" class="headerlink" title="二、基本思想与策略"></a>二、基本思想与策略</h2><p>   基本思想与分治法类似，也是将待求解的问题分解为若干个子问题（阶段），按顺序求解子阶段，前一子问题的解，为后一子问题的求解提供了有用的信息。在求解任一子问题时，列出各种可能的局部解，通过决策保留那些有可能达到最优的局部解，丢弃其他局部解。依次解决各子问题，最后一个子问题就是初始问题的解。</p><p>   由于动态规划解决的问题多数有重叠子问题这个特点，为减少重复计算，对每一个子问题只解一次，将其不同阶段的不同状态保存在一个二维数组中。</p><blockquote><p> 与分治法最大的差别是：适合于用动态规划法求解的问题，经分解后得到的子问题往往不是互相独立的（即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解）。</p></blockquote><h2 id="三、适用的情况"><a href="#三、适用的情况" class="headerlink" title="三、适用的情况"></a>三、适用的情况</h2><p>能采用动态规划求解的问题的一般要具有3个性质：</p><ul><li><p>最优化原理：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。</p></li><li><p>无后效性：即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关。</p></li><li><p>有重叠子问题：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势）</p></li></ul><h2 id="四、求解的基本步骤"><a href="#四、求解的基本步骤" class="headerlink" title="四、求解的基本步骤"></a>四、求解的基本步骤</h2><p>   动态规划所处理的问题是一个多阶段决策问题，一般由初始状态开始，通过对中间阶段决策的选择，达到结束状态。这些决策形成了一个决策序列，同时确定了完成整个过程的一条活动路线(通常是求最优的活动路线)。如图所示。动态规划的设计都有着一定的模式，一般要经历以下几个步骤。</p><blockquote><p>   初始状态→│决策１│→│决策２│→…→│决策ｎ│→结束状态<br>                      图1 动态规划决策过程示意图</p></blockquote><p>   (1)划分阶段：按照问题的时间或空间特征，把问题分为若干个阶段。在划分阶段时，注意划分后的阶段一定要是有序的或者是可排序的，否则问题就无法求解。</p><p>   (2)确定状态和状态变量：将问题发展到各个阶段时所处于的各种客观情况用不同的状态表示出来。当然，状态的选择要满足无后效性。</p><p>   (3)确定决策并写出状态转移方程：因为决策和状态转移有着天然的联系，状态转移就是根据上一阶段的状态和决策来导出本阶段的状态。所以如果确定了决策，状态转移方程也就可写出。但事实上常常是反过来做，根据相邻两个阶段的状态之间的关系来确定决策方法和状态转移方程。</p><p>   (4)寻找边界条件：给出的状态转移方程是一个递推式，需要一个递推的终止条件或边界条件。一般，只要解决问题的阶段、状态和状态转移决策确定了，就可以写出状态转移方程（包括边界条件）。</p><p>实际应用中可以按以下几个简化的步骤进行设计：</p><pre><code>（1）分析最优解的性质，并刻画其结构特征。（2）递归的定义最优解。（3）以自底向上或自顶向下的记忆化方式（备忘录法）计算出最优值（4）根据计算最优值时得到的信息，构造问题的最优解</code></pre><h2 id="五、算法实现的说明"><a href="#五、算法实现的说明" class="headerlink" title="五、算法实现的说明"></a>五、算法实现的说明</h2><p>   动态规划的主要难点在于理论上的设计，也就是上面4个步骤的确定，一旦设计完成，实现部分就会非常简单。使用动态规划求解问题，最重要的就是确定动态规划三要素：</p><p>（1）问题的阶段 </p><p>（2）每个阶段的状态</p><p>（3）从前一个阶段转化到后一个阶段之间的递推关系。</p><p>   递推关系必须是从次小的问题开始到较大的问题之间的转化，从这个角度来说，动态规划往往可以用递归程序来实现，不过因为递推可以充分利用前面保存的子问题的解来减少重复计算，所以对于大规模问题来说，有递归不可比拟的优势，这也是动态规划算法的核心之处。</p><p>   确定了动态规划的这三要素，整个求解过程就可以用一个最优决策表来描述，最优决策表是一个二维表，其中行表示决策的阶段，列表示问题状态，表格需要填写的数据一般对应此问题的在某个阶段某个状态下的最优值（如最短路径，最长公共子序列，最大价值等），填表的过程就是根据递推关系，从1行1列开始，以行或者列优先的顺序，依次填写表格，最后根据整个表格的数据通过简单的取舍或者运算求得问题的最优解。</p><pre><code>f(n,m)=max{f(n-1,m), f(n-1,m-w[n])+P(n,m)}</code></pre><h2 id="六、动态规划算法基本框架"><a href="#六、动态规划算法基本框架" class="headerlink" title="六、动态规划算法基本框架"></a>六、动态规划算法基本框架</h2><p>代码：</p><pre><code>for(j=1; j&lt;=m; j=j+1) // 第一个阶段   xn[j] = 初始值; for(i=n-1; i&gt;=1; i=i-1)// 其他n-1个阶段   for(j=1; j&gt;=f(i); j=j+1)//f(i)与i有关的表达式     xi[j]=j=max（或min）{g(xi-1[j1:j2]), ......, g(xi-1[jk:jk+1])};t = g(x1[j1:j2]); // 由子问题的最优解求解整个问题的最优解的方案print(x1[j1]);for(i=2; i&lt;=n-1; i=i+1）{       t = t-xi-1[ji];     for(j=1; j&gt;=f(i); j=j+1)        if(t=xi[ji])             break;}</code></pre><h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><h2 id="一、基本概念："><a href="#一、基本概念：" class="headerlink" title="一、基本概念："></a>一、基本概念：</h2><p>   所谓贪心算法是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的仅是在某种意义上的局部最优解。</p><p>   贪心算法没有固定的算法框架，算法设计的关键是贪心策略的选择。必须注意的是，贪心算法不是对所有问题都能得到整体最优解，选择的贪心策略必须具备无后效性，即某个状态以后的过程不会影响以前的状态，只与当前状态有关。</p><p>   所以对所采用的贪心策略一定要仔细分析其是否满足无后效性。</p><h2 id="二、贪心算法的基本思路："><a href="#二、贪心算法的基本思路：" class="headerlink" title="二、贪心算法的基本思路："></a>二、贪心算法的基本思路：</h2><p>1.建立数学模型来描述问题。</p><p>2.把求解的问题分成若干个子问题。</p><p>3.对每一子问题求解，得到子问题的局部最优解。</p><p>4.把子问题的解局部最优解合成原来解问题的一个解。</p><h2 id="三、贪心算法适用的问题"><a href="#三、贪心算法适用的问题" class="headerlink" title="三、贪心算法适用的问题"></a>三、贪心算法适用的问题</h2><p>   贪心策略适用的前提是：局部最优策略能导致产生全局最优解。实际上，贪心算法适用的情况很少。一般，对一个问题分析是否适用于贪心算法，可以先选择该问题下的几个实际数据进行分析，就可做出判断。</p><h2 id="四、贪心算法的实现框架"><a href="#四、贪心算法的实现框架" class="headerlink" title="四、贪心算法的实现框架"></a>四、贪心算法的实现框架</h2><pre><code>从问题的某一初始解出发；while （能朝给定总目标前进一步）{       利用可行的决策，求出可行解的一个解元素；}由所有解元素组合成问题的一个可行解；</code></pre><h2 id="五、贪心策略的选择"><a href="#五、贪心策略的选择" class="headerlink" title="五、贪心策略的选择"></a>五、贪心策略的选择</h2><p>   因为用贪心算法只能通过解局部最优解的策略来达到全局最优解，因此，一定要注意判断问题是否适合采用贪心算法策略，找到的解是否一定是问题的最优解。</p><h2 id="六、例题分析"><a href="#六、例题分析" class="headerlink" title="六、例题分析"></a>六、例题分析</h2><pre><code>下面是一个可以试用贪心算法解的题目，贪心解的确不错，可惜不是最优解。[背包问题]有一个背包，背包容量是M=150。有7个物品，物品可以分割成任意大小。要求尽可能让装入背包中的物品总价值最大，但不能超过总容量。物品 A B C D E F G重量 35 30 60 50 40 10 25价值 10 40 30 50 35 40 30分析：目标函数： ∑pi最大约束条件是装入的物品总重量不超过背包容量：∑wi&lt;=M( M=150)（1）根据贪心的策略，每次挑选价值最大的物品装入背包，得到的结果是否最优？（2）每次挑选所占重量最小的物品装入是否能得到最优解？（3）每次选取单位重量价值最大的物品，成为解本题的策略。值得注意的是，贪心算法并不是完全不可以使用，贪心策略一旦经过证明成立后，它就是一种高效的算法。贪心算法还是很常见的算法之一，这是由于它简单易行，构造贪心策略不是很困难。可惜的是，它需要证明后才能真正运用到题目的算法中。一般来说，贪心算法的证明围绕着：整个问题的最优解一定由在贪心策略中存在的子问题的最优解得来的。对于例题中的3种贪心策略，都是无法成立（无法被证明）的，解释如下：（1）贪心策略：选取价值最大者。反例：W=30物品：A B C重量：28 12 12价值：30 20 20根据策略，首先选取物品A，接下来就无法再选取了，可是，选取B、C则更好。（2）贪心策略：选取重量最小。它的反例与第一种策略的反例差不多。（3）贪心策略：选取单位重量价值最大的物品。反例：W=30物品：A B C重量：28 20 10价值：28 20 10根据策略，三种物品单位重量价值一样，程序无法依据现有策略作出判断，如果选择A，则答案错误。</code></pre><h1 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h1><h2 id="1、概念"><a href="#1、概念" class="headerlink" title="1、概念"></a>1、概念</h2><p>   回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。</p><p>   回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。</p><p>   许多复杂的，规模较大的问题都可以使用回溯法，有“通用解题方法”的美称。</p><h2 id="2、基本思想"><a href="#2、基本思想" class="headerlink" title="2、基本思想"></a>2、基本思想</h2><p>   在包含问题的所有解的解空间树中，按照深度优先搜索的策略，从根结点出发深度探索解空间树。当探索到某一结点时，要先判断该结点是否包含问题的解，如果包含，就从该结点出发继续探索下去，如果该结点不包含问题的解，则逐层向其祖先结点回溯。（其实回溯法就是对隐式图的深度优先搜索算法）。</p><p>   若用回溯法求问题的所有解时，要回溯到根，且根结点的所有可行的子树都要已被搜索遍才结束。</p><p>   而若使用回溯法求任一个解时，只要搜索到问题的一个解就可以结束。</p><p>3、<strong>用回溯法解题的一般步骤：</strong></p><p>（1）针对所给问题，确定问题的解空间：首先应明确定义问题的解空间，问题的解空间应至少包含问题的一个（最优）解。</p><p>（2）确定结点的扩展搜索规则</p><p>（3）以深度优先方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索。</p><h2 id="4、算法框架"><a href="#4、算法框架" class="headerlink" title="4、算法框架"></a>4、算法框架</h2><h3 id="（1）问题框架"><a href="#（1）问题框架" class="headerlink" title="（1）问题框架"></a>（1）问题框架</h3><pre><code>设问题的解是一个n维向量(a1,a2,………,an),约束条件是ai(i=1,2,3,…..,n)之间满足某种条件，记为f(ai)。</code></pre><h3 id="（2）非递归回溯框架"><a href="#（2）非递归回溯框架" class="headerlink" title="（2）非递归回溯框架"></a>（2）非递归回溯框架</h3><pre><code> 1: int a[n],i; 2: 初始化数组a[]; 3: i = 1; 4: while (i&gt;0(有路可走)   and  (未达到目标))  // 还未回溯到头 5: { 6:     if(i &gt; n)                                              // 搜索到叶结点 7:     {    8:           搜索到一个解，输出； 9:     }10:     else                                                   // 处理第i个元素11:     { 12:           a[i]第一个可能的值；13:           while(a[i]在不满足约束条件且在搜索空间内)</code></pre><h3 id="3）递归的算法框架"><a href="#3）递归的算法框架" class="headerlink" title="3）递归的算法框架"></a>3）递归的算法框架</h3><blockquote><p>回溯法是对解空间的深度优先搜索，在一般情况下使用递归函数来实现回溯法比较简单，其中i为搜索的深度，框架如下：</p></blockquote><pre><code> 1: int a[n]; 2: try(int i) 3: { 4:     if(i&gt;n) 5:        输出结果; 6:      else 7:     { 8:        for(j = 下界; j &lt;= 上界; j=j+1)  // 枚举i所有可能的路径 9:        {10:            if(fun(j))                 // 满足限界函数和约束条件11:              {12:                 a[i] = j;13:               ...                         // 其他操作</code></pre><h1 id="分支限界法"><a href="#分支限界法" class="headerlink" title="分支限界法"></a>分支限界法</h1><h2 id="一、基本描述"><a href="#一、基本描述" class="headerlink" title="一、基本描述"></a>一、基本描述</h2><p>   类似于回溯法，也是一种在问题的解空间树T上搜索问题解的算法。但在一般情况下，分支限界法与回溯法的求解目标不同。回溯法的求解目标是找出T中满足约束条件的所有解，而分支限界法的求解目标则是找出满足约束条件的一个解，或是在满足约束条件的解中找出使某一目标函数值达到极大或极小的解，即在某种意义下的最优解。</p><h3 id="（1）分支搜索算法"><a href="#（1）分支搜索算法" class="headerlink" title="（1）分支搜索算法"></a>（1）分支搜索算法</h3><blockquote><p>所谓“分支”就是采用广度优先的策略，依次搜索E-结点的所有分支，也就是所有相邻结点，抛弃不满足约束条件的结点，其余结点加入活结点表。然后从表中选择一个结点作为下一个E-结点，继续搜索。</p></blockquote><p>选择下一个E-结点的方式不同，则会有几种不同的分支搜索方式。</p><ul><li><p>FIFO搜索</p></li><li><p>LIFO搜索</p></li><li><p>优先队列式搜索</p></li></ul><h3 id="（2）分支限界搜索算法"><a href="#（2）分支限界搜索算法" class="headerlink" title="（2）分支限界搜索算法"></a>（2）分支限界搜索算法</h3><h2 id="二、分支限界法的一般过程"><a href="#二、分支限界法的一般过程" class="headerlink" title="二、分支限界法的一般过程"></a>二、分支限界法的一般过程</h2><blockquote><p>由于求解目标不同，导致分支限界法与回溯法在解空间树T上的搜索方式也不相同。回溯法以深度优先的方式搜索解空间树T，而分支限界法则以广度优先或以最小耗费优先的方式搜索解空间树T。</p></blockquote><p><strong>分支限界法的搜索策略是：</strong></p><p>在扩展结点处，先生成其所有的儿子结点（分支），然后再从当前的活结点表中选择下一个扩展对点。为了有效地选择下一扩展结点，以加速搜索的进程，在每一活结点处，计算一个函数值（限界），并根据这些已计算出的函数值，从当前活结点表中选择一个最有利的结点作为扩展结点，使搜索朝着解空间树上有最优解的分支推进，以便尽快地找出一个最优解。</p><p>分支限界法常以广度优先或以最小耗费（最大效益）优先的方式搜索问题的解空间树。问题的解空间树是表示问题解空间的一棵有序树，常见的有子集树和排列树。在搜索问题的解空间树时，分支限界法与回溯法对当前扩展结点所使用的扩展方式不同。在分支限界法中，每一个活结点只有一次机会成为扩展结点。活结点一旦成为扩展结点，就一次性产生其所有儿子结点。在这些儿子结点中，那些导致不可行解或导致非最优解的儿子结点被舍弃，其余儿子结点被子加入活结点表中。此后，从活结点表中取下一结点成为当前扩展结点，并重复上述结点扩展过程。这个过程一直持续到找到所求的解或活结点表为空时为止。</p><h2 id="三、回溯法和分支限界法的一些区别"><a href="#三、回溯法和分支限界法的一些区别" class="headerlink" title="三、回溯法和分支限界法的一些区别"></a>三、回溯法和分支限界法的一些区别</h2><blockquote><p>有一些问题其实无论用回溯法还是分支限界法都可以得到很好的解决，但是另外一些则不然。也许我们需要具体一些的分析——到底何时使用分支限界而何时使用回溯呢？</p></blockquote><h3 id="回溯法和分支限界法的一些区别："><a href="#回溯法和分支限界法的一些区别：" class="headerlink" title="回溯法和分支限界法的一些区别："></a>回溯法和分支限界法的一些区别：</h3><ul><li><p>方法对解空间树的搜索方式       </p></li><li><p>存储结点的常用数据结构      </p></li><li><p>结点存储特性常用应用</p></li></ul><blockquote><p><strong>回溯法深度优先搜索堆栈活结点的所有可行子结点被遍历后才被从栈中弹出找出满足约束条件的所有解</strong></p><p><strong>分支限界法广度优先或最小消耗优先搜索队列、优先队列每个结点只有一次成为活结点的机会找出满足约束条件的一个解或特定意义下的最优解</strong></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文转自：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;博客园：&lt;a href=&quot;http://www.cnblogs.com/steven_oyj/archive/2010/05/22/1741370.html&quot; target=&quot;_blank&quot; rel=&quot;ex
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://liujunjie11.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="https://liujunjie11.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>python3爬取拉勾网职位信息</title>
    <link href="https://liujunjie11.github.io/2018/05/05/python3%E7%88%AC%E5%8F%96%E6%8B%89%E5%8B%BE%E7%BD%91%E8%81%8C%E4%BD%8D%E4%BF%A1%E6%81%AF/"/>
    <id>https://liujunjie11.github.io/2018/05/05/python3爬取拉勾网职位信息/</id>
    <published>2018-05-05T10:05:56.000Z</published>
    <updated>2018-05-06T14:38:37.256Z</updated>
    
    <content type="html"><![CDATA[<p>爬取拉勾网的最大障碍：<strong>普通模块难以实现翻页爬取。</strong>自己加了参数<code>page</code>，经过抓包查询之后也达不到我的理想要求。</p><p>没办法了，只好用<em>selenium</em>模块结合浏览器来实现边翻页边爬取了。</p><blockquote><p>实际上比较浪费系统资源，这种情况不得已还是尽量别用的好。</p></blockquote><p>在此记录下主要的过程，包括实现的代码。</p><p>还是要说明一下：<strong>不懂的地方还是需要自己去查询了解，代码不过就是几个模块的知识运用罢了。</strong></p><h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>启动<em>Chrome**webdriver</em>插件，之后复制其所在地址，加入代码中启动<em>selenium</em>模块程序。</p><p><img src="http://owudg3xs2.bkt.clouddn.com/5%E6%9C%88-06-2018%2022-29-25.gif" alt=""></p><blockquote><p>启动插件。</p></blockquote><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-05-06%20%E4%B8%8B%E5%8D%8810.28.45.png" alt=""></p><blockquote><p>本机此插件所在的目录位置。</p></blockquote><h2 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h2><p>经过简单的分析，发现页面的切换的同时URL没有任何的改变(这就是我为何要用<em>selenium</em>来爬取的原因！)：</p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-05-06%20%E4%B8%8B%E5%8D%8810.32.58.png" alt=""></p><p>我们的目标是，点击在此符合条件的发布公司链接，进入招聘信息详细的界面爬取详细的所有需要的信息：</p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-05-06%20%E4%B8%8B%E5%8D%8810.34.40.png" alt=""></p><blockquote><p>一一进入进行爬取。</p></blockquote><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-05-06%20%E4%B8%8B%E5%8D%8810.35.34.png" alt=""></p><blockquote><p>进入之后详细的招聘信息页面。</p></blockquote><p>那么思路一下就出来了：<strong>用selenium模块实现翻页的功能，并且返回对应页面的源代码，并且一一进行分析提取即可。</strong></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><pre><code>&quot;&quot;&quot;函数目标：翻页爬取拉勾网的职位信息编写时间：2018-05-05&quot;&quot;&quot;from selenium import webdriverfrom selenium.webdriver.common.by import Byfrom selenium.webdriver.support import expected_conditions as ECfrom selenium.webdriver.support.wait import WebDriverWaitfrom pyquery import PyQuery as pqfrom urllib.parse import quoteimport requestsimport reimport time# 启动对象驱动，并且设置预期的等待时间browser = webdriver.Chrome(&apos;/Users/junjieliu/Downloads/webdirver小插件/chromedriver&apos;)wait = WebDriverWait(browser, 10)def page_content(pages):    &quot;&quot;&quot;    返回每一页的页面源代码，顾名知义，从URL中可知许多的筛选信息了，可自行选择，    在此仅以职位关键词职位作为输入。    &quot;&quot;&quot;    print(&apos;-&apos; * 10 + &apos;正在爬取第&apos; + str(pages) + &apos;页的内容&apos; + &apos;.&apos; * 6)    keyword = &apos;数据分析师&apos;  # 职位关键词    url = &apos;https://www.lagou.com/jobs/list_&apos; + quote(keyword) + &apos;?&apos; + &apos;px=default&amp;gx=实习&amp;gj=&amp;xl=本科&amp;isSchoolJob=1&amp;city=全国#filterBox&apos;     browser.get(url)    if pages &gt; 1:        # 如果页面数大于1页则启用自动翻页        next_botton = wait.until(                    EC.element_to_be_clickable((By.CSS_SELECTOR, &apos;#s_position_list &gt; div.item_con_pager &gt; div &gt; span.pager_next&apos;)))        next_botton.click()    # 指定要爬取区域,非必须要写    wait.until(            EC.presence_of_element_located((By.CSS_SELECTOR, &apos;#s_position_list &gt; ul &gt; li.con_list_item&apos;)))    print(&apos;爬取此页源码成功！以下是本页一系列相关的内容：&apos;)    informations_save()def informations_save():    &quot;&quot;&quot;    一一进入内部URL，爬取详细的招聘信息！    &quot;&quot;&quot;    source_code = browser.page_source    doc = pq(source_code)    url = re.findall(r&apos;class=&quot;position_link&quot;.*?href=&quot;(.*?)&quot;&apos;, source_code, re.S)  # @UndefinedVariable      for i in range(0, len(url)):        header = {        &apos;Connection&apos;: &apos;keep-alive&apos;,        &apos;Host&apos;: &apos;www.lagou.com&apos;,        &apos;Upgrade-Insecure-Requests&apos;: &apos;1&apos;,        &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.139 Safari/537.36&apos;    }        response = requests.get(url=url[i], headers=header)        response.encoding = &apos;utf-8&apos;        doc1 = pq(response.text)        infor = {            &apos;company&apos;:doc1.find(&apos;body &gt; div.position-head &gt; div &gt; div.position-content-l &gt; div &gt; div.company&apos;).text(),  # 公司名称            &apos;infor_url&apos;:doc1.find(&apos;#job_company &gt; dt &gt; a&apos;).attr(&apos;href&apos;),  # 此公司详细介绍网站            &apos;position&apos;:doc1.find(&apos;body &gt; div.position-head &gt; div &gt; div.position-content-l &gt; div &gt; span.name&apos;).text(),  # 职位            &apos;salary&apos;:doc1.find(&apos;body &gt; div.position-head &gt; div &gt; div.position-content-l &gt; dd &gt; p:nth-child(1) &gt; span.salary&apos;).text(),  # 工资            &apos;locale&apos;:doc1.find(&apos;#job_detail &gt; dd.job-address.clearfix &gt; input[type=&quot;hidden&quot;]:nth-child(6)&apos;).text().replace(&apos;/&apos;, &apos;&apos;),  # 地点            &apos;place&apos;:doc1.find(&apos;#job_detail &gt; dd.job-address.clearfix &gt; div.work_addr&apos;).text(),  # 具体位置            &apos;required&apos;:doc1.find(&apos;div.position-content-l &gt; dd &gt; p:nth-child(1) &gt; span:nth-child(3)&apos;).text().replace(&apos;/&apos;, &apos;&apos;),  # 经验要求            &apos;education&apos;:doc1.find(&apos;div.position-content-l &gt; dd &gt; p:nth-child(1) &gt; span:nth-child(4)&apos;).text().replace(&apos;/&apos;, &apos;&apos;),  # 学历要求            &apos;job_nature&apos;:doc1.find(&apos;div.position-content-l &gt; dd &gt; p:nth-child(1) &gt; span:nth-child(5)&apos;).text().replace(&apos;/&apos;, &apos;&apos;),  # 工作性质            &apos;attract&apos;:doc1.find(&apos;#job_detail &gt; dd.job-advantage&apos;).text().replace(&apos;\n&apos;, &apos; &apos;),  # 工作诱惑            &apos;describe&apos;:doc1.find(&apos;#job_detail &gt; dd.job_bt&apos;).text().replace(&apos;\n&apos;, &apos; &apos;)  # 工作描述        }        print(infor)         if __name__ == &quot;__main__&quot;:    pages = 6  # 总的页面数，从网页第一面就可知了，6是测试用的数字页码    for i in range(1, pages + 1):        page_content(i)        time.sleep(20)</code></pre><blockquote><p>最后我选择将爬取的内容保存至一个<code>.txt</code>文件下。</p></blockquote><h3 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h3><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-05-06%20%E4%B8%8B%E5%8D%8810.27.19.png" alt=""></p><blockquote><p>运行之后的效果，有些爬取不了，明明源代码都没什么变化…</p></blockquote><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><ul><li><p>这个代码的模型并不能爬取页面上对应的全部内容，这个我也是有点疑惑。</p></li><li><p>有时会跳到需要登录的界面，重新来几次就行了，总有一次能爬取。</p></li></ul><p>有不懂的知识可参考：<a href="https://cuiqingcai.com/5630.html" target="_blank" rel="external">https://cuiqingcai.com/5630.html</a></p><blockquote><p>以及相关的模块的官网亦可。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;爬取拉勾网的最大障碍：&lt;strong&gt;普通模块难以实现翻页爬取。&lt;/strong&gt;自己加了参数&lt;code&gt;page&lt;/code&gt;，经过抓包查询之后也达不到我的理想要求。&lt;/p&gt;
&lt;p&gt;没办法了，只好用&lt;em&gt;selenium&lt;/em&gt;模块结合浏览器来实现边翻页边爬取了。&lt;/
      
    
    </summary>
    
      <category term="python爬虫" scheme="https://liujunjie11.github.io/categories/python%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="python爬虫" scheme="https://liujunjie11.github.io/tags/python%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法书籍资源共享</title>
    <link href="https://liujunjie11.github.io/2018/05/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%A6%E7%B1%8D%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB/"/>
    <id>https://liujunjie11.github.io/2018/05/04/数据结构与算法书籍资源共享/</id>
    <published>2018-05-04T11:15:05.000Z</published>
    <updated>2018-05-04T11:20:25.483Z</updated>
    
    <content type="html"><![CDATA[<ul><li>计算机程序设计艺术(卷1～卷四全)：</li></ul><blockquote><p><a href="https://pan.baidu.com/s/1922E16LZR0iXZHZQCgsbLg" target="_blank" rel="external">https://pan.baidu.com/s/1922E16LZR0iXZHZQCgsbLg</a></p></blockquote><ul><li>算法导论(第三版)：</li></ul><blockquote><p><a href="https://pan.baidu.com/s/1XqAeeJx803rcVCx7QMA62g" target="_blank" rel="external">https://pan.baidu.com/s/1XqAeeJx803rcVCx7QMA62g</a></p></blockquote><p>以上资源来于网络，感谢默默分享的人们！</p><p>还有一些其他的金典书籍，我都没怎么看啊..</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;计算机程序设计艺术(卷1～卷四全)：&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://pan.baidu.com/s/1922E16LZR0iXZHZQCgsbLg&quot; target=&quot;_blank&quot; rel=&quot;extern
      
    
    </summary>
    
      <category term="书籍" scheme="https://liujunjie11.github.io/categories/%E4%B9%A6%E7%B1%8D/"/>
    
    
      <category term="书籍" scheme="https://liujunjie11.github.io/tags/%E4%B9%A6%E7%B1%8D/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络知识总结</title>
    <link href="https://liujunjie11.github.io/2018/05/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    <id>https://liujunjie11.github.io/2018/05/02/计算机网络知识总结/</id>
    <published>2018-05-02T13:12:31.000Z</published>
    <updated>2018-05-02T13:18:47.590Z</updated>
    
    <content type="html"><![CDATA[<p>计算机网络也是计算机基础重要的一部分。</p><p>本来打算总结下关于计算机网络基础知识，发现下面的这些课件总结的已经非常好了，所以在此分享，我就不说多了…</p><blockquote><p>下载课件：<a href="https://pan.baidu.com/s/1uodpU6E8n050QyazgdLXVw" target="_blank" rel="external">https://pan.baidu.com/s/1uodpU6E8n050QyazgdLXVw</a></p></blockquote><ul><li>说明：</li></ul><p>课件来源：《数据通信与计算机网络》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;计算机网络也是计算机基础重要的一部分。&lt;/p&gt;
&lt;p&gt;本来打算总结下关于计算机网络基础知识，发现下面的这些课件总结的已经非常好了，所以在此分享，我就不说多了…&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;下载课件：&lt;a href=&quot;https://pan.baidu.com/s
      
    
    </summary>
    
      <category term="计算机网络" scheme="https://liujunjie11.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="https://liujunjie11.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>我对学习计算机基础的一些心得见解</title>
    <link href="https://liujunjie11.github.io/2018/04/29/%E6%88%91%E5%AF%B9%E5%AD%A6%E4%B9%A0%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BF%83%E5%BE%97%E8%A7%81%E8%A7%A3/"/>
    <id>https://liujunjie11.github.io/2018/04/29/我对学习计算机基础的一些心得见解/</id>
    <published>2018-04-29T12:54:29.000Z</published>
    <updated>2018-04-29T13:26:28.269Z</updated>
    
    <content type="html"><![CDATA[<p>最近总是遇到了许多的瓶颈…即感觉认识的知道的太少了。</p><p>在前些天看到了一些关于<em>python</em>的优化内容之后，加上之前用<em>python</em>也有一段时间了，突然的感觉到一些基础细节才是最重要的，我意识到了<strong>这往往可能就是人与人技术之间的一个分水岭，也往往是突破瓶颈关键点，也往往能决定一个人技术的所在点。基础细节知识是能决定一个人能走多远的</strong></p><p>平时在写程序时不应满足于功能的实现，更加应当注意那些可优化的细节问题，就好比一个算法的时间复杂度与空间复杂度一样的，写的每一个程序(无论那种编程语言)均有可优化的最优解选择。在我平时因为涉及的数据规模不大，这种问题目前是看不出来的，如果运用到的是一个数据规模大的问题上，优化必然是重要的，不可或缺的。</p><p>平时想问题总是感觉能联想到的知识太少，回过头来看，发现自己对计算机的认识本来也不够全面(注意是全面！而非透彻！)。这往往也限制了我许多的想象，从而造成了我的瓶颈突出明显。</p><p>说了这么多，只是想说一个问题：<strong>计算机基础知识(包括编程基础知识)是能决定一个人技术的高度的。</strong>至少我现在就有这种感觉，写一个程序不应满足于功能的实现，更应探索最优解的选择。<strong>这往往就是技术<code>好</code>与<code>坏</code>的一个区分标准吧。</strong></p><p>关于如何学习以上说的基础知识，我有一些见解在此想要说明一下。</p><ul><li><p>知识尽量要了解全面，不能为了速度而一知半解的，那样只会浪费时间，最后还是什么都不知道。</p></li><li><p>有些知识可能会引起我们的好奇，想要进一步理解透彻(彻彻底底)，但是这其中却是有太多的知识链关联着的…这点我深有体会。如果顺着知识链步步了解，我们的确也能学习到许多的知识，但是最后会发现其实这些在我们实际需要中根本没有多大的作用，仅仅当时作为一种科普了，当然现在学习到的知识也是以后我们技术的一种铺垫，如果实在有兴趣就当我没说，兴趣是学习一种知识最好的引导。</p></li><li><p>有些是需要理解透彻的，有些(大部分)可能仅仅是需要了解一下就好的。</p></li><li><p>根据目前的需求来进行学习也是一种好的驱动力。</p></li><li><p>一些必要的基础知识是需要了解的，比如学习了计算机概论，那一般以后买电脑时就会有自己的一些见解了。学习了数据结构与算法基础之后，编程时就不会仅仅以达到目的而“不择手段”编写程序了，因为再学习了这些基础知识之后我们脑子里必然会有一些规则“约束”了。</p></li></ul><p>最后，我还是想说，对于底层的电路什么的那种我想我是不愿也是不情愿接触的…</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近总是遇到了许多的瓶颈…即感觉认识的知道的太少了。&lt;/p&gt;
&lt;p&gt;在前些天看到了一些关于&lt;em&gt;python&lt;/em&gt;的优化内容之后，加上之前用&lt;em&gt;python&lt;/em&gt;也有一段时间了，突然的感觉到一些基础细节才是最重要的，我意识到了&lt;strong&gt;这往往可能就是人与
      
    
    </summary>
    
      <category term="学习笔记" scheme="https://liujunjie11.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="学习笔记" scheme="https://liujunjie11.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>python3爬虫与GUI：一个简易的搜索实用小工具</title>
    <link href="https://liujunjie11.github.io/2018/04/28/python3%E7%88%AC%E8%99%AB%E4%B8%8EGUI%EF%BC%9A%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93%E7%9A%84%E6%90%9C%E7%B4%A2%E5%AE%9E%E7%94%A8%E5%B0%8F%E5%B7%A5%E5%85%B7/"/>
    <id>https://liujunjie11.github.io/2018/04/28/python3爬虫与GUI：一个简易的搜索实用小工具/</id>
    <published>2018-04-28T02:31:30.000Z</published>
    <updated>2018-05-02T13:04:39.933Z</updated>
    
    <content type="html"><![CDATA[<p>平时在获取爬虫之后，会不满足于仅仅得到了结果，而是想经过一个交互式的界面来进一步的完善，获取更多的功能，从而可以更好的展示数据。</p><p>下面运用了<em>python</em>的<em>pyqt5</em>库来进行<em>GUI</em>的设计。</p><p>用<em>pyqt5</em>这个库实现简单的界面化有两种方法：</p><ul><li><p>编写代码(一般为几十行代码足够了)。</p></li><li><p>结合<em>QT Creator</em>来进行界面设计，加入信号与槽的机制，槽这一方面还是需要编写相应的几行代码。</p></li></ul><blockquote><p>下面一一进行简单的介绍。</p></blockquote><h2 id="代码编写方式"><a href="#代码编写方式" class="headerlink" title="代码编写方式"></a>代码编写方式</h2><p>假设我已经利用爬虫写出来了<em>百度百科</em>，<em>维基百科</em>的接口的代码程序，接下来仅仅需要设计好界面，再者之后利用好信号与槽的机制将接口代码与界面相连接即可完成一个简易的搜索实用小工具了。</p><p>在此简单理解一下信号与槽机制以及所谓的事件机制：<strong>比如我们有一个按钮，点击此按钮便弹出一个写有‘Hello’的窗口，点击到弹出新窗口的这一过程，有个响应的过程，我们可以理解为发送信号(点击按钮)，之后有弹出新窗口(响应),而这一系列过程包括弹出的内容我们可称之为事件。</strong></p><blockquote><p>关于学习<em>pyqt5</em>库的中文教程地址：<a href="https://maicss.gitbooks.io/pyqt5/content/事件和信号.html" target="_blank" rel="external">https://maicss.gitbooks.io/pyqt5/content/事件和信号.html</a></p></blockquote><p>从头开始看一下，之后再看这一篇大概就知道简单的交互式界面是如何生成的了。</p><p>简单描述一下思路：<strong>先设计布局好界面(包括定义好相关按钮的快捷键)，写入爬虫代码，信号与槽机制的连接设定，即完成了此次的任务。</strong></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code>import sysimport urllib.request  from bs4 import BeautifulSoupimport refrom urllib.parse import quote from PyQt5.QtWidgets import (QPushButton, QWidget, QLabel, QLineEdit, QTextEdit, QGridLayout, QApplication,    QComboBox)from PyQt5.QtCore import QCoreApplicationclass Example(QWidget):     def __init__(self):        &apos;&apos;&apos;        初始化        &apos;&apos;&apos;        super().__init__()        self.initUI()    def baidu_baike(self, entry):          &apos;&apos;&apos;        百度百科词条内容爬取代码        entry：词条        因为太懒了..所以爬取的代码没有自己写..        &apos;&apos;&apos;        url = &apos;https://baike.baidu.com/item/&apos; + urllib.parse.quote(entry)        html = urllib.request.urlopen(url)          content = html.read().decode(&apos;utf-8&apos;)        html.close()        # lxml器进行解析        soup = BeautifulSoup(content, &quot;lxml&quot;)          text = soup.find(&apos;div&apos;, class_=&quot;lemma-summary&quot;).children  # 簡介部分        intro_text = &apos;&apos;        # 数据爬取        for x in text:            word = re.sub(re.compile(r&quot;&lt;(.+?)&gt;&quot;), &apos;&apos;, str(x))            words = re.sub(re.compile(r&quot;\[(.+?)\]&quot;), &apos;&apos;, word)            intro_text += words        return intro_text  # 返回文本(str格式)    def intro_final(self, entry):          &apos;&apos;&apos;        异常处理        &apos;&apos;&apos;        try:            return self.baidu_baike(entry)        except AttributeError:            return &quot;词条定义不够清晰/词条目前未成立！&quot;    def initUI(self):        # GUI布局及控件放置        search_label = QLabel(&quot;请输入搜索词条：&quot;)        search_item = QLineEdit()        combo = QComboBox(self)        combo.addItem(&quot;百度百科&quot;)        combo.addItem(&quot;维基百科(不可用)&quot;)        btn1 = QPushButton(&quot;开始搜索&quot;, self)        # shortcut快捷键的设置        btn1.setShortcut(&apos;return&apos;)        btn2 = QPushButton(&quot;清空&quot;, self)        btn2.setShortcut(&apos;esc&apos;)        btn3 = QPushButton(&apos;退出&apos;, self)        btn3.setShortcut(&apos;command+q&apos;)        btn3.setShortcut(&apos;Ctrl+q&apos;)        btn3.clicked.connect(QCoreApplication.instance().quit)        search_result = QTextEdit()        grid = QGridLayout()        grid.setSpacing(5)        grid.addWidget(search_label, 1, 0)        grid.addWidget(btn3, 2, 1)        grid.addWidget(search_item, 2, 0)        grid.addWidget(btn1, 3, 0)        grid.addWidget(btn2, 3, 1)        grid.addWidget(search_result, 4, 0, 5 , 0)        self.setLayout(grid)        # 信号机制的设置，定义为一个方法作为反映的对象，这里很好理解        def search():            &apos;&apos;&apos;            搜索信号反映的响应            &apos;&apos;&apos;            search_result.setText(self.intro_final(search_item.text()))        btn1.clicked.connect(search)        def clear():            &apos;&apos;&apos;            清空信号反映的响应            &apos;&apos;&apos;            search_result.setText(&quot;&quot;)            search_item.setText(&quot;&quot;)        btn2.clicked.connect(clear)        # 设置窗口大小        self.setGeometry(500, 150, 600, 500)        self.setWindowTitle(&quot;搜索引擎GUI&quot;)        self.show()if __name__ == &quot;__main__&quot;:    app = QApplication(sys.argv)    ex = Example()    sys.exit(app.exec_())</code></pre><blockquote><p>以上有不懂的地方均可在<a href="https://maicss.gitbooks.io/pyqt5/content/hello_world.html" target="_blank" rel="external">pyqt5中文教程</a>中找到思路。</p></blockquote><h3 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h3><p><img src="http://owudg3xs2.bkt.clouddn.com/5%E6%9C%88-02-2018%2019-31-44.gif" alt=""></p><h2 id="结合QT-Creator的界面设计"><a href="#结合QT-Creator的界面设计" class="headerlink" title="结合QT Creator的界面设计"></a>结合<em>QT Creator</em>的界面设计</h2><p>结合<em>QT Creator</em>的界面，我们肯定会想到：那当我们进行界面设计完成之后，就算是转化为<code>.py</code>的<em>python</em>脚本，那我们又该如何定义信号与槽的机制以及事件的机制呢？</p><p>下面的解说就是解决这个疑惑的。</p><p>第一步当然是去官网下载好软件了。</p><blockquote><p>参考此篇文章：<a href="https://blog.csdn.net/win_turn/article/details/50465127" target="_blank" rel="external">https://blog.csdn.net/win_turn/article/details/50465127</a></p></blockquote><p><strong>话不多说了，下载的时候其实有一个坑，即要记得下载有调试的那个版本，否则在设计界面时无法得到运行。</strong></p><h3 id="创建文件并且设计"><a href="#创建文件并且设计" class="headerlink" title="创建文件并且设计"></a>创建文件并且设计</h3><p>在这里仅仅是为了达到解说的目的所以简单设计一下就好，说说设计下面的思路：<strong>定义一个按钮(名为确定)，一个输入框，一个输出框，达到的目的是从输入框输入文字，按下确定按钮，输出框中输出与输入框一致的内容。</strong></p><p>创建新的文件过程如图所示：</p><p><img src="http://owudg3xs2.bkt.clouddn.com/5%E6%9C%88-02-2018%2019-42-52.gif" alt=""></p><blockquote><p>总之就是如上图一路点击下去即可。</p></blockquote><p>之后会发现有这样的界面出现：</p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-05-02%20%E4%B8%8B%E5%8D%887.43.59.png" alt=""></p><p>这个<em>mainwindow.ui</em>不说就能轻易知道就是用它来进行界面设计的。双击它即可进入设计界面(如图1)，当然可选择<em>Qt Designer</em>进行设计(对其右键可弹出选项，如图2)。</p><ul><li>图1</li></ul><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-05-02%20%E4%B8%8B%E5%8D%887.49.34.png" alt=""></p><ul><li>图2</li></ul><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-05-02%20%E4%B8%8B%E5%8D%887.47.52.png" alt=""></p><p>为了尽快达到写完的目的，我简单的来进行一下示范…</p><p>先在界面中，设计一个按钮：</p><p><img src="http://owudg3xs2.bkt.clouddn.com/5%E6%9C%88-02-2018%2020-15-04.gif" alt=""></p><p>然后添加下面两种组件：</p><p><img src="http://owudg3xs2.bkt.clouddn.com/5%E6%9C%88-02-2018%2020-15-15.gif" alt=""></p><p><img src="http://owudg3xs2.bkt.clouddn.com/5%E6%9C%88-02-2018%2020-15-38.gif" alt=""></p><h3 id="定义信号与槽"><a href="#定义信号与槽" class="headerlink" title="定义信号与槽"></a>定义信号与槽</h3><p>在这之前先将设计好的转为<code>.py</code><em>python</em>脚本文件。<code>cd</code>到相应的文件的目录下(即上面的<em>mainwindow.ui</em>所在的目录。注意，此步非常重要！)利用命令行：<code>pyuic5 -o  mainwindow.py mainwindow.ui</code></p><blockquote><p>关于此命令行具体可参考：<a href="https://blog.csdn.net/yingmutongxue/article/details/8487348" target="_blank" rel="external">https://blog.csdn.net/yingmutongxue/article/details/8487348</a><br><strong>(在此需要注意的是，我使用的是<em>pyqt5</em>，所以对应的命令行应当是pyuic5开头，若是<em>pyqt4</em>，则为pyuic4开头了。)</strong></p></blockquote><p>这样在本目录下即可找到转为后的<em>python</em>文件了。</p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-05-02%20%E4%B8%8B%E5%8D%889.04.04.png" alt=""></p><p>再者，我们需要在这个文件实现上面说的思路，即相应的信号与槽机制的代码。因为时间问题，就不在此实现了(是真的写不下去了…)。</p><p>在完成之后，我们直接将此调入<em>eclipse</em>的工程目录下(我用的是<em>eclipse</em>)，之后我们直接调用此文件即可。</p><pre><code>import sysfrom PyQt5.QtWidgets import QApplication , QMainWindowfrom mainwindow import *if __name__ == &apos;__main__&apos;:#     主函数    app = QtWidgets.QApplication(sys.argv)    MainWindow = QtWidgets.QMainWindow()    ui = Ui_MainWindow()    ui.setupUi(MainWindow)    MainWindow.show()    sys.exit(app.exec_())</code></pre><blockquote><p>这样即可完成结合软件设计界面，并在<em>python</em>中运行的一条龙服务了…</p><p>其实在<em>Qt creator</em>中就有信号与槽机制以及快捷键的设置了，这个可参考：<a href="https://wizardforcel.gitbooks.io/qt-beginning/content/60.html" target="_blank" rel="external">https://wizardforcel.gitbooks.io/qt-beginning/content/60.html</a><br>(<strong>全面介绍了</strong>)</p></blockquote><p>简单认识一下设计界面上的那些按钮功能(网上的图，出处忘记了…)</p><p><img src="http://owudg3xs2.bkt.clouddn.com/d.png" alt=""></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>唉..突然感觉直接写代码都还要方便多了…结合软件设计搞的时间浪费的还要多…</p><ul><li>参考：</li></ul><blockquote><p><a href="https://blog.csdn.net/jclian91/article/details/77407723" target="_blank" rel="external">https://blog.csdn.net/jclian91/article/details/77407723</a></p><p><a href="https://maicss.gitbooks.io/pyqt5/content/介绍.html" target="_blank" rel="external">https://maicss.gitbooks.io/pyqt5/content/介绍.html</a><br><strong>(以上所有内容的拼接均可根据此pyqt5库中文教程来进行理解学习，还是一句话，要多动脑多动手实践。)</strong></p><p><a href="https://cuiqingcai.com/5551.html" target="_blank" rel="external">https://cuiqingcai.com/5551.html</a><br><strong>（pyquery的使用教程）</strong></p></blockquote><ul><li>关于将<em>python</em>文件打包生成app的工具库：</li></ul><blockquote><p>py2app:.py –&gt; .dmg</p><p>py2exe:.py –&gt; .exe </p></blockquote><ul><li>关于<em>css选择器</em>等其他内容的快速获取(基于<em>chrome</em>浏览器)：</li></ul><p><img src="http://owudg3xs2.bkt.clouddn.com/5%E6%9C%88-02-2018%2019-33-40.gif" alt=""></p><blockquote><p>看上方的动图，选择完之后粘贴即可得出对应的内容(可适当删除中间字段而不影响达到目的)，当然最好学会一点相关的内容，其实也不难上手。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;平时在获取爬虫之后，会不满足于仅仅得到了结果，而是想经过一个交互式的界面来进一步的完善，获取更多的功能，从而可以更好的展示数据。&lt;/p&gt;
&lt;p&gt;下面运用了&lt;em&gt;python&lt;/em&gt;的&lt;em&gt;pyqt5&lt;/em&gt;库来进行&lt;em&gt;GUI&lt;/em&gt;的设计。&lt;/p&gt;
&lt;p&gt;用&lt;
      
    
    </summary>
    
      <category term="python-GUI学习" scheme="https://liujunjie11.github.io/categories/python-GUI%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="python-GUI学习" scheme="https://liujunjie11.github.io/tags/python-GUI%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>关于Mac的快捷键及fn键设置</title>
    <link href="https://liujunjie11.github.io/2018/04/27/%E5%85%B3%E4%BA%8EMac%E7%9A%84%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%8F%8Afn%E9%94%AE%E8%AE%BE%E7%BD%AE/"/>
    <id>https://liujunjie11.github.io/2018/04/27/关于Mac的快捷键及fn键设置/</id>
    <published>2018-04-27T05:06:18.000Z</published>
    <updated>2018-04-27T07:36:01.031Z</updated>
    
    <content type="html"><![CDATA[<p>最近因为需要，就花了点时间看了一下。本文用于记录下一些常用的在<em>Mac</em>下的一些设置。</p><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><p>关于在认识<em>Macbook</em>的一些快捷键时，进入步骤：<code>系统偏好设置</code> –&gt; <code>键盘</code>–&gt;<code>快捷键</code>–&gt; <code>左边栏</code>。一个一个都看看，发现快捷键系统的都在。</p><p><img src="http://owudg3xs2.bkt.clouddn.com/4%E6%9C%88-27-2018%2015-27-50.gif" alt=""></p><blockquote><p>当然可根据需要自行更改。</p></blockquote><h2 id="fn健的设置"><a href="#fn健的设置" class="headerlink" title="fn健的设置"></a>fn健的设置</h2><p>按下<em>fn</em>健可显示<code>F1</code>～<code>F12</code>的按键，关于如何设置在特定的软件打开时无需按此就显示<code>F1</code>～<code>F12</code>的按键：<code>系统偏好设置</code> –&gt; <code>键盘</code>–&gt;<code>快捷键</code>–&gt;<code>(fn)功能键</code>–&gt;添加软件即可。在这之后会发现打开相应的软件之后，无需按下<em>fn</em>健即可显示出<code>F1</code>～<code>F12</code>的按键了。</p><p><img src="http://owudg3xs2.bkt.clouddn.com/4%E6%9C%88-27-2018%2015-28-06.gif" alt=""></p><h2 id="关于设置文件的默认打开方式"><a href="#关于设置文件的默认打开方式" class="headerlink" title="关于设置文件的默认打开方式"></a>关于设置文件的默认打开方式</h2><p>例子：右键打开一个文件，点击<code>显示简介</code>–&gt;<code>打开方式</code>–&gt;选择好想要默认打开用的软件–&gt;<code>全部更改</code>。再次打开此类型的文件均以选定的软件打开显示。</p><p><img src="http://owudg3xs2.bkt.clouddn.com/4%E6%9C%88-27-2018%2015-28-21.gif" alt=""></p><h2 id="关闭软件通知"><a href="#关闭软件通知" class="headerlink" title="关闭软件通知"></a>关闭软件通知</h2><p>有时用的破解软件经常提醒要更新…<code>系统偏好设置</code> –&gt; <code>通知</code>。里面设置停止通知即可。</p><p><img src="http://owudg3xs2.bkt.clouddn.com/4%E6%9C%88-27-2018%2015-28-39.gif" alt=""></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>如果有时发现没有相关的内容，可先重新启动，再次进行操作。不仅此类型的问题需要重新启动，只要是发现很系统奇怪跟往常不一致时均可通过重新启动来解决。</p><p>以后有需要用的上的再补上。</p><blockquote><p>主要资料可参考<em>Apple</em>官网的说明即可。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近因为需要，就花了点时间看了一下。本文用于记录下一些常用的在&lt;em&gt;Mac&lt;/em&gt;下的一些设置。&lt;/p&gt;
&lt;h2 id=&quot;快捷键&quot;&gt;&lt;a href=&quot;#快捷键&quot; class=&quot;headerlink&quot; title=&quot;快捷键&quot;&gt;&lt;/a&gt;快捷键&lt;/h2&gt;&lt;p&gt;关于在认识&lt;em
      
    
    </summary>
    
      <category term="Mac教程笔记" scheme="https://liujunjie11.github.io/categories/Mac%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Mac教程笔记" scheme="https://liujunjie11.github.io/tags/Mac%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>关于Jupyter Notebook的简单使用</title>
    <link href="https://liujunjie11.github.io/2018/04/21/%E5%85%B3%E4%BA%8EJupyter-Notebook%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <id>https://liujunjie11.github.io/2018/04/21/关于Jupyter-Notebook的简单使用/</id>
    <published>2018-04-21T12:37:03.000Z</published>
    <updated>2018-04-21T13:43:33.581Z</updated>
    
    <content type="html"><![CDATA[<p>关于<em>Jupyter Notebook</em>的介绍就不在此多说了。</p><p>官网教程：</p><blockquote><p><a href="https://jupyter-notebook.readthedocs.io/en/stable/notebook.html" target="_blank" rel="external">https://jupyter-notebook.readthedocs.io/en/stable/notebook.html</a></p></blockquote><p>直接开始介绍整个流程好了。</p><p>先下载<em>Anaconda</em>，里面有包含了现成的<em>Jupyter Notebook</em>，之后我们打开<em>Anaconda</em>客户端即可直接使用<em>Jupyter Notebook</em>了。</p><blockquote><p><em>Anaconda</em>官网：<a href="https://www.anaconda.com/download/#macos" target="_blank" rel="external">https://www.anaconda.com/download/#macos</a></p><p>其中有两个版本，选择需要的下载的版本与完成之后打开的<em>Jupyter Notebook</em>中的<em>python</em>版本是一致的。</p></blockquote><p>打开客户端，进入<em>Jupyter Notebook</em>：</p><p><img src="http://owudg3xs2.bkt.clouddn.com/4%E6%9C%88-21-2018%2020-55-27.gif" alt=""></p><p>在<em>Jupyter Notebook</em>中新建一个文本：</p><p><img src="http://owudg3xs2.bkt.clouddn.com/4%E6%9C%88-21-2018%2020-55-59.gif" alt=""></p><p>在创建了一个脚本文件之后的界面上的小图标各有不同的功能，可以自己点击一下就知道是怎么回事了，再不然可结合文档来进行操作即可。再者接下来就是根据个人的需要来进行编码了，更多的功能暂时用不到，可参考上面的官网教程。</p><blockquote><p>关于<em>Ipython</em>教程可参考：<a href="https://itacey.gitbooks.io/learning_ipython/content/第一章.html" target="_blank" rel="external">https://itacey.gitbooks.io/learning_ipython/content/第一章.html</a></p><p>关于在<em>Mac</em>中使用<em>Jupyter Notebook</em>编码时的快捷键可参考：<a href="https://www.jianshu.com/p/20f6a77dd23c" target="_blank" rel="external">https://www.jianshu.com/p/20f6a77dd23c</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;关于&lt;em&gt;Jupyter Notebook&lt;/em&gt;的介绍就不在此多说了。&lt;/p&gt;
&lt;p&gt;官网教程：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://jupyter-notebook.readthedocs.io/en/stable/notebo
      
    
    </summary>
    
      <category term="python" scheme="https://liujunjie11.github.io/categories/python/"/>
    
    
      <category term="python" scheme="https://liujunjie11.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>搭建Django开发环境</title>
    <link href="https://liujunjie11.github.io/2018/04/19/%E6%90%AD%E5%BB%BADjango%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
    <id>https://liujunjie11.github.io/2018/04/19/搭建Django开发环境/</id>
    <published>2018-04-19T11:00:28.000Z</published>
    <updated>2018-04-19T11:34:00.935Z</updated>
    
    <content type="html"><![CDATA[<p>老早就想将一些数据库里的数据来进行交互式的实现了，之前看了有主要的两种方法：</p><ul><li><p>一是<em>pyQt5</em>这个库，结合<em>Qt creator</em>来进行完成。</p></li><li><p>另外就是通过网页形式来进行交互式的实现了。</p></li></ul><blockquote><p>在接触了前者之后发现学习的时间成本比较高一些，所以打算选择后者了…</p></blockquote><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>在终端使用命令行：<code>pip3 install Django</code></p><blockquote><p>默认<em>python3</em>进行。<em>python2</em>:<code>pip install Django</code>。两者均会下载<em>Django</em>库的最新版本，亦可指定下载那个版本。</p></blockquote><h3 id="测试安装："><a href="#测试安装：" class="headerlink" title="测试安装："></a>测试安装：</h3><p>在编译器中：</p><pre><code>import django  # @UnresolvedImportif __name__ == &apos;__main__&apos;:        print(django.get_version())</code></pre><blockquote><p><strong>在<em>eclipse</em>中会提示导入Django库找不到，但是运行是可以成功的，加上# @UnresolvedImport 让错误提示不再提示。</strong></p></blockquote><p>在终端，先打开<em>python</em>的编译环境，依次输入：</p><pre><code>import djangoprint(django.get_version())</code></pre><blockquote><p>以上两者均会输出下载的<em>Django</em>版本号。</p></blockquote><h2 id="测试Django运行"><a href="#测试Django运行" class="headerlink" title="测试Django运行"></a>测试Django运行</h2><h3 id="项目建立"><a href="#项目建立" class="headerlink" title="项目建立"></a>项目建立</h3><p><code>cd</code> 至编译器或者是IDE的开发环境的目录下，使用创建项目命令：<code>django-admin startproject mysite</code><strong>（其中的mysite是项目名称）</strong>：</p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-19%20%E4%B8%8B%E5%8D%887.33.13.png" alt=""></p><p>创建项目成功之后刷新在编译器的目录，我的是<em>eclipse</em>，可看到项目目录出来了：</p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-19%20%E4%B8%8B%E5%8D%887.30.32.png" alt=""></p><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>在上面的基础下<code>cd</code>至新建的项目之下，启动主文件：<code>python manage.py runserver</code>，打开链接<a href="http://127.0.0.1:8000/" target="_blank" rel="external">http://127.0.0.1:8000/</a></p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-19%20%E4%B8%8B%E5%8D%887.30.55.png" alt=""></p><p>出现了Django成功运行的网页：</p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-19%20%E4%B8%8B%E5%8D%887.31.09.png" alt=""></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><ul><li><p>在<em>eclipse</em>中的导入<em>Django</em>提示错误，实际上运行无障碍。</p></li><li><p>详细可参考：</p></li></ul><p><strong><a href="https://docs.djangoproject.com/en/2.0/intro/tutorial01/" target="_blank" rel="external">https://docs.djangoproject.com/en/2.0/intro/tutorial01/</a></strong></p><p><strong><a href="https://www.w3cschool.cn/django/dl5b8ozt.html" target="_blank" rel="external">https://www.w3cschool.cn/django/dl5b8ozt.html</a></strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;老早就想将一些数据库里的数据来进行交互式的实现了，之前看了有主要的两种方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;一是&lt;em&gt;pyQt5&lt;/em&gt;这个库，结合&lt;em&gt;Qt creator&lt;/em&gt;来进行完成。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;另外就是通过网页形式来进行交互式的
      
    
    </summary>
    
      <category term="Django" scheme="https://liujunjie11.github.io/categories/Django/"/>
    
    
      <category term="Django" scheme="https://liujunjie11.github.io/tags/Django/"/>
    
  </entry>
  
  <entry>
    <title>关于Parallels Desktop13的简单使用</title>
    <link href="https://liujunjie11.github.io/2018/04/17/%E5%85%B3%E4%BA%8EParallels-Desktop13%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <id>https://liujunjie11.github.io/2018/04/17/关于Parallels-Desktop13的简单使用/</id>
    <published>2018-04-17T01:44:20.000Z</published>
    <updated>2018-04-17T02:03:53.583Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>Parallels Desktop13破解版的下载以及简单的操作可见：<a href="https://blog.csdn.net/weixin_41000111/article/details/79428402" target="_blank" rel="external">https://blog.csdn.net/weixin_41000111/article/details/79428402</a></strong></p></blockquote><p>本文仅仅是做一些补充。</p><h2 id="关于新建一个虚拟机"><a href="#关于新建一个虚拟机" class="headerlink" title="关于新建一个虚拟机"></a>关于新建一个虚拟机</h2><p>比如已经有了一个<em>win</em>系统的虚拟机，想建一个<em>Linux</em>的虚拟机。如下图所示，打开在右上角的<em>Parallels Desktop</em>的小图标，点击<code>新建..</code>即可。</p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-17%20%E4%B8%8A%E5%8D%889.42.25.png" alt=""></p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-17%20%E4%B8%8A%E5%8D%889.42.37.png" alt=""></p><blockquote><p>之后的安装步骤会有点不一致，不过容易上手。</p></blockquote><h2 id="关于Parallels-Desktop13的扩展功能"><a href="#关于Parallels-Desktop13的扩展功能" class="headerlink" title="关于Parallels Desktop13的扩展功能"></a>关于<em>Parallels Desktop13</em>的扩展功能</h2><p>打开在右上角的<em>Parallels Desktop</em>的小图标中的<em>偏好设置</em>，如下图所示下载<em>Toolbox</em>。打开之后发现会有许多的小工具，比如下方的视频下载工具可下载<em>YouTube</em>上的视频文件。更多的新功能可见官网：<strong><a href="https://www.parallels.com/products/desktop/" target="_blank" rel="external">https://www.parallels.com/products/desktop/</a></strong></p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-17%20%E4%B8%8A%E5%8D%889.50.08.png" alt=""></p><p><img src="http://owudg3xs2.bkt.clouddn.com/4%E6%9C%88-17-2018%2010-01-17.gif" alt=""></p><blockquote><p>官网的介绍视频中有相关的详细介绍。</p></blockquote><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>说说体验吧。与我之前用过的虚拟机软件<em>VirtualBox</em>相较，<em>Parallels Desktop</em>明显的运行起来比前者更为流畅，更为人性化一些，并且功能更为强大。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Parallels Desktop13破解版的下载以及简单的操作可见：&lt;a href=&quot;https://blog.csdn.net/weixin_41000111/article/details/79428402&quot; target=&quot;
      
    
    </summary>
    
      <category term="Parallels Desktop" scheme="https://liujunjie11.github.io/categories/Parallels-Desktop/"/>
    
    
      <category term="Parallels Desktop" scheme="https://liujunjie11.github.io/tags/Parallels-Desktop/"/>
    
  </entry>
  
  <entry>
    <title>关于在eclipse中运行scrapy项目</title>
    <link href="https://liujunjie11.github.io/2018/04/13/%E5%85%B3%E4%BA%8E%E5%9C%A8eclipse%E4%B8%AD%E8%BF%90%E8%A1%8Cscrapy%E9%A1%B9%E7%9B%AE/"/>
    <id>https://liujunjie11.github.io/2018/04/13/关于在eclipse中运行scrapy项目/</id>
    <published>2018-04-13T11:23:05.000Z</published>
    <updated>2018-04-13T12:00:46.995Z</updated>
    
    <content type="html"><![CDATA[<p>关于在<em>eclipse</em>中运行爬虫<em>scrapy</em>框架的项目介绍如下。</p><blockquote><p><strong>scrapy官方文档：<a href="http://scrapy-chs.readthedocs.io/zh_CN/0.24/topics/shell.html" target="_blank" rel="external">http://scrapy-chs.readthedocs.io/zh_CN/0.24/topics/shell.html</a></strong></p></blockquote><p>首先打开终端将<code>cd</code>至<em>eclipse</em>目录下的（即<em>eclipse-workspace</em>），使用命令行<code>scrapy startproject tutorial</code>（其中的<em>tutorial</em>是自由选择的），之后会生成一个目录，将其目录移至一个<em>python工程</em>下。</p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-13%20%E4%B8%8B%E5%8D%887.49.25.png" alt=""></p><blockquote><p>如上图。</p></blockquote><p>在<em>spider</em>包下建立一个脚本文件（如上图我的那个<em>first</em>文件，名字随意），是用来写爬虫程序用的。之后在<em>tutorial</em>包下建立一个名为<em>cmdline</em>的脚本文件（名字随意）。</p><p>下面为了直接达到运行成功的目的，贴上测试用的代码。</p><p><strong>first.py中的代码：</strong></p><pre><code>import scrapyclass DmozSpider(scrapy.Spider):    name = &quot;first&quot; #此处很重要    allowed_domains = [&quot;dmoz.org&quot;]    start_urls = [        &quot;http://www.dmoz.org/Computers/Programming/Languages/Python/Books/&quot;,        &quot;http://www.dmoz.org/Computers/Programming/Languages/Python/Resources/&quot;    ]    def parse(self, response):        filename = response.url.split(&quot;/&quot;)[-2]        with open(filename, &apos;wb&apos;) as f:            f.write(response.body)</code></pre><p><strong>cmdline.py中的代码：</strong></p><pre><code>from scrapy.cmdline import executeif __name__ == &apos;__main__&apos;:    #第三个参数就是上方的first文件名！其他两个参数如下正常    execute(argv=[&apos;scrapy&apos;, &apos;crawl&apos;, &apos;first&apos;])</code></pre><p><strong>items.py中的代码：</strong></p><pre><code>import scrapyclass TutorialItem(scrapy.Item):    # define the fields for your item here like:    # name = scrapy.Field()    title = scrapy.Field()    link = scrapy.Field()    desc = scrapy.Field()</code></pre><blockquote><p>这个文件是与<em>first</em>文件有直接联系的。可参考官方文档介绍。</p></blockquote><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>接下来直接运行<em>cmdline.py</em>可得出结果：</p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-13%20%E4%B8%8B%E5%8D%887.50.00.png" alt=""></p><hr><h2 id="配置调试"><a href="#配置调试" class="headerlink" title="配置调试"></a>配置调试</h2><p>直接看下面的图上解说吧。</p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-13%20%E4%B8%8B%E5%8D%887.46.09.png" alt=""></p><hr><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-13%20%E4%B8%8B%E5%8D%887.46.17.png" alt=""></p><blockquote><p>接下来点击debug。</p></blockquote><hr><p><strong>最终两者均可达到输出的效果！</strong></p><p>参考：</p><p><a href="https://blog.csdn.net/otengyue/article/details/48065841" target="_blank" rel="external">https://blog.csdn.net/otengyue/article/details/48065841</a></p><p><a href="http://www.cnblogs.com/v-BigdoG-v/p/7393601.html" target="_blank" rel="external">http://www.cnblogs.com/v-BigdoG-v/p/7393601.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;关于在&lt;em&gt;eclipse&lt;/em&gt;中运行爬虫&lt;em&gt;scrapy&lt;/em&gt;框架的项目介绍如下。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;scrapy官方文档：&lt;a href=&quot;http://scrapy-chs.readthedocs.io/zh_CN/
      
    
    </summary>
    
      <category term="eclispe scrapy" scheme="https://liujunjie11.github.io/categories/eclispe-scrapy/"/>
    
    
      <category term="eclispe scrapy" scheme="https://liujunjie11.github.io/tags/eclispe-scrapy/"/>
    
  </entry>
  
  <entry>
    <title>关于eclipse的风格与主题</title>
    <link href="https://liujunjie11.github.io/2018/04/13/%E5%85%B3%E4%BA%8Eeclipse%E7%9A%84%E9%A3%8E%E6%A0%BC%E4%B8%8E%E4%B8%BB%E9%A2%98/"/>
    <id>https://liujunjie11.github.io/2018/04/13/关于eclipse的风格与主题/</id>
    <published>2018-04-13T04:56:03.000Z</published>
    <updated>2018-04-13T05:21:26.770Z</updated>
    
    <content type="html"><![CDATA[<h2 id="eclipse的界面主题更换"><a href="#eclipse的界面主题更换" class="headerlink" title="eclipse的界面主题更换"></a><em>eclipse</em>的界面主题更换</h2><p>关于我的<em>eclipse</em>的界面主题更换（目前为<em>eclipse Oxygen</em>版本），在内置中已经可以作为一种选择了。</p><p>具体看图所示即可：</p><p><img src="http://owudg3xs2.bkt.clouddn.com/4%E6%9C%88-13-2018%2013-07-55.gif" alt=""></p><blockquote><p>可供的选择有三种，其中的<em>dark</em>类型是比较护眼的，均可试试。</p></blockquote><p>实际的<em>dark</em>展示：</p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-13%20%E4%B8%8B%E5%8D%881.08.27.png" alt=""></p><hr><h2 id="eclipse代码风格更换"><a href="#eclipse代码风格更换" class="headerlink" title="eclipse代码风格更换"></a><em>eclipse</em>代码风格更换</h2><p>可参考此处：<a href="https://blog.csdn.net/zhouchangshi/article/details/37901519" target="_blank" rel="external">https://blog.csdn.net/zhouchangshi/article/details/37901519</a></p><blockquote><p>其中已经有了许多的并且详细的介绍了。</p></blockquote><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li>关于更换编译处的字体大小以及字体选择（如图）:</li></ul><p><img src="http://owudg3xs2.bkt.clouddn.com/4%E6%9C%88-13-2018%2013-11-02.gif" alt=""></p><ul><li>关于控制台的字体更改以及选择（如图）:</li></ul><p><img src="http://owudg3xs2.bkt.clouddn.com/4%E6%9C%88-13-2018%2013-10-41.gif" alt=""></p><hr><p><strong>参考：</strong></p><p><a href="https://jingyan.baidu.com/article/f96699bb9442f3894e3c1b15.html" target="_blank" rel="external">https://jingyan.baidu.com/article/f96699bb9442f3894e3c1b15.html</a></p><p><a href="https://blog.csdn.net/zhouchangshi/article/details/37901519" target="_blank" rel="external">https://blog.csdn.net/zhouchangshi/article/details/37901519</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;eclipse的界面主题更换&quot;&gt;&lt;a href=&quot;#eclipse的界面主题更换&quot; class=&quot;headerlink&quot; title=&quot;eclipse的界面主题更换&quot;&gt;&lt;/a&gt;&lt;em&gt;eclipse&lt;/em&gt;的界面主题更换&lt;/h2&gt;&lt;p&gt;关于我的&lt;em&gt;eclip
      
    
    </summary>
    
      <category term="eclipse" scheme="https://liujunjie11.github.io/categories/eclipse/"/>
    
    
      <category term="eclipse" scheme="https://liujunjie11.github.io/tags/eclipse/"/>
    
  </entry>
  
  <entry>
    <title>python3爬虫：爬取淘宝商品信息的两种方法</title>
    <link href="https://liujunjie11.github.io/2018/04/08/python3%E7%88%AC%E8%99%AB%EF%BC%9A%E7%88%AC%E5%8F%96%E6%B7%98%E5%AE%9D%E5%95%86%E5%93%81%E4%BF%A1%E6%81%AF%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
    <id>https://liujunjie11.github.io/2018/04/08/python3爬虫：爬取淘宝商品信息的两种方法/</id>
    <published>2018-04-08T10:58:00.000Z</published>
    <updated>2018-04-09T03:59:21.431Z</updated>
    
    <content type="html"><![CDATA[<p>爬取淘宝信息：</p><blockquote><p>1，可用<em>selenium</em>模块与<em>driver Chrome</em>插件自动化模拟爬取。</p><p>2， 进行抓包爬取。</p></blockquote><p><strong>下面一一进行介绍并且贴出实现代码。但是在此必须说明一下，因为时间有限，相关模块不懂的还需要自行搜索，在此不做教程解说，只提供分析思路与代码实现过程。</strong></p><blockquote><p>学习博客推荐：<a href="https://cuiqingcai.com，" target="_blank" rel="external">https://cuiqingcai.com，</a><br>实际上我也是根据此博客学习到了一些知识，也是我参考学习的唯一博客。</p></blockquote><h2 id="自动化模拟爬取"><a href="#自动化模拟爬取" class="headerlink" title="自动化模拟爬取"></a>自动化模拟爬取</h2><p>python爬虫的<em>selenium</em>模块是一个可以实现模拟浏览器相关动作，并且可跳过<em>JavaScript动态渲染</em>直接返回其网页源代码的一个自动化测试工具。如下我们需要爬取关键词为<em>MacBook Pro</em>的商品信息，可用它来实现自动翻页并且返回每一页的源代码直接进行相关信息的爬取。</p><h3 id="分析过程"><a href="#分析过程" class="headerlink" title="分析过程"></a>分析过程</h3><p>下面直接进行分析过程。</p><p>首先打开淘宝主页：<a href="https://www.taobao.com" target="_blank" rel="external">https://www.taobao.com</a> ，进入其中输入关键词观察一下页面，可以看到下面翻页的一些跳转功能。（以下使用的都是<em>Chrome</em>自带的<em>开发者工具</em>）</p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-08%20%E4%B8%8B%E5%8D%888.10.59.png" alt=""></p><p>因为要实现自动翻页的过程，则我们需要查看有关翻页这个功能按钮的源代码是什么样子。其中涉及到了输入框，然后点击旁边的确定按钮。</p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-08%20%E4%B8%8B%E5%8D%888.15.27.png" alt=""></p><blockquote><p>输入框对应的源代码。</p></blockquote><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-08%20%E4%B8%8B%E5%8D%888.18.39.png" alt=""></p><blockquote><p>确定按钮对应的源代码。</p></blockquote><p>在知道了以上的一些按钮信息之后我们还需要知道翻页之后目前对应的页数在哪，以便在对应的页数正确之后，可以得到对应页面的源代码，这样可直接运用一些相关的模块进行节点锁定爬取即可。</p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-08%20%E4%B8%8B%E5%8D%888.19.13.png" alt=""></p><blockquote><p>确定页数码的源代码。</p></blockquote><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-08%20%E4%B8%8B%E5%8D%887.32.20.png" alt=""></p><blockquote><p>页面上商品信息的html源代码。</p></blockquote><p>为什么要这样分析每一个相关功能的源代码？<strong>因为在selenium模块中可以实现自动化的过程，但是需要指定页面上相关的源代码才行，对于selenium来说等于开放了这个功能的接口一样。</strong></p><p><strong>思路分析：将要用相关模块挖掘源代码信息做为一个函数，将要爬取的页面源代码做为一个函数，其中实现自动翻页功能，即若是大于1，自动跳到其页面并且返回其页源代码，否则返回第一页页面的源代码。最后代入前者挖掘的函数。</strong></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code>&apos;&apos;&apos;    函数目标：    利用selenium的自动翻页进行爬去相关的内容    编写时间：    2018-04-07&apos;&apos;&apos;from selenium import webdriverfrom selenium.webdriver.common.by import Byfrom selenium.webdriver.support import expected_conditions as ECfrom selenium.webdriver.support.wait import WebDriverWaitfrom urllib.parse import quotefrom pyquery import PyQuery as pqbrowser = webdriver.Chrome(&apos;/Users/junjieliu/Downloads/小插件/chromedriver&apos;)wait = WebDriverWait(browser, 10)keys = &apos;macbookpro&apos;&apos;&apos;&apos;    函数说明：实现自动化翻页。    仅仅当需要时进行翻页的选项    &apos;&apos;&apos;def index_source(page):    print(&apos;正在爬取第&apos; + str(page) + &apos;页内容..&apos; + &apos;\n&apos; + &apos;.&apos; * 15)    url = &apos;https://s.taobao.com/search?q=&apos; + quote(keys)    browser.get(url)    # 果然页数大于1则自动翻页功能启动    if page &gt; 1:        # 输入框定位        input = wait.until(            EC.presence_of_element_located((By.CSS_SELECTOR, &apos;#mainsrp-pager div.form &gt; input.input.J_Input&apos;)))        # 确定按钮定位        button = wait.until(            EC.element_to_be_clickable((By.CSS_SELECTOR, &apos;#mainsrp-pager div.form &gt; span.btn.J_Submit&apos;)))        # 清理，输入，点击一体化        input.clear()        input.send_keys(page)        button.click()    &apos;&apos;&apos;    获取源代码，传入爬取数据的函数    获取源代码过程：    第一步确定为在那一页    第二步确定爬取内容    &apos;&apos;&apos;    wait.until(        EC.text_to_be_present_in_element((By.CSS_SELECTOR, &apos;#mainsrp-pager li.item.active &gt; span.num&apos;), str(page)))    wait.until(        EC.presence_of_element_located((By.CSS_SELECTOR, &apos;.m-itemlist .items .item&apos;)))    print(&apos;获取本页源码成功，以下为相关的信息：&apos; + &apos;\n&apos;)    get_product()&apos;&apos;&apos;    函数说明：    用pyquery爬取其中的商品内容    &apos;&apos;&apos;def get_product():    html_source = browser.page_source    doc = pq(html_source)    items = doc(&apos;#mainsrp-itemlist .items .item&apos;).items()    &apos;&apos;&apos;        以下匹配内容可查看网页源代码可知        &apos;&apos;&apos;    for item in items:        product_infos = {            &apos;img_url&apos;:&apos;https:&apos; + item.find(&apos;.pic .img&apos;).attr(&apos;data-src&apos;),  # 店铺主图片地址            &apos;product_desc&apos;:item.find(&apos;.pic .img&apos;).attr(&apos;alt&apos;),  # 商品描述            &apos;price&apos;:item.find(&apos;.price&apos;).text().replace(&apos;\n&apos;, &apos;&apos;),  # 价格            &apos;people&apos;:item.find(&apos;.deal-cnt&apos;).text(),  # 购买人数            &apos;shop_url&apos;:&apos;https:&apos; + item.find(&apos;.shop .shopname&apos;).attr(&apos;href&apos;),  # 店铺信息            &apos;shop_name&apos;:item.find(&apos;.shop&apos;).text(),  # 店铺名称            &apos;shop_location&apos;:item.find(&apos;.location&apos;).text()  # 店铺所在地            }        print(product_infos)if __name__ == &apos;__main__&apos;:    pages = 100  # 根据页面分析可知总共有100页的信息    for num in range(1, pages + 1):        index_source(num)     </code></pre><blockquote><p>当然还可以进行正则表达式的匹配来完成爬取，因为需要时间来测试相关的表达式，所以推荐用<em>pyquery</em>这个库来完成爬取工作，相比于使用过的<em>beautiful</em>模块以及正则表达式，我感觉轻松了不少。</p></blockquote><h2 id="抓包爬取"><a href="#抓包爬取" class="headerlink" title="抓包爬取"></a>抓包爬取</h2><p>以下的抓包是利用的<em>Chrome</em>浏览器完成的，在这之前说了，因为时间关系，关于抓包是什么就不在此做详细介绍了…相信你看了我下面的分析过程会隐约明白一点。</p><h3 id="分析过程-1"><a href="#分析过程-1" class="headerlink" title="分析过程"></a>分析过程</h3><p>打开淘宝主页，输入关键词，在第一页上打开<em>Chrome</em>自带的<em>开发者工具</em>，这样就可以看到第一页的源代码信息了。以下图过程可以看到我们在第一页抓到的相关的<em>淘宝API</em>的数据包。里面有相关的商品信息，均为<em>json</em>格式。</p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-08%20%E4%B8%8B%E5%8D%887.55.32.png" alt=""></p><hr><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-08%20%E4%B8%8B%E5%8D%887.56.39.png" alt=""></p><blockquote><p>其中的<em>XHR格式</em>不懂可参考此篇文章：<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest" target="_blank" rel="external">https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest</a></p></blockquote><p>浏览器新建一个标签页，打开上面的那个地址看看有什么。</p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-08%20%E4%B8%8B%E5%8D%888.24.11.png" alt=""></p><p><strong>经过一系列的测试发现了其中的那个参数<em>bcoffset=</em>是跳转的决定点，更改其值可得到不同的信息。</strong>这样我们进行思路分析就一目了然了。</p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-08%20%E4%B8%8B%E5%8D%888.21.47.png" alt=""></p><p><strong>思路分析：传入上面的说的API的URL，根据上面的那个参数的值更改，返回其中的文档信息，即可爬取到商品信息。</strong></p><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code>&apos;&apos;&apos;    函数说明：    利用抓包返回的信息直接爬取商品信息    编写时间：    2018-04-08&apos;&apos;&apos;import requestsimport reif __name__ == &apos;__main__&apos;:    # 设定爬取100页，实际上还要多...    pages = 100    for num in range(1, pages + 1):        print(&apos;开始爬取第&apos; + str(num) + &apos;页内容...&apos; + &apos;\n&apos; + &apos;.&apos; * 10)        url = &apos;https://s.taobao.com/api?_ksTS=1523191565870_226&amp;callback=jsonp227&amp;ajax=true&amp;m=customized&amp;stats_click=search_radio_all:1&amp;q=macbookpro&amp;p4ppushleft=1,48&amp;ntoffset=4&amp;s=36&amp;imgfile=&amp;initiative_id=staobaoz_20180408&amp;bcoffset=&apos; + str(num) + &apos;&amp;js=1&amp;ie=utf8&amp;rn=5bd3f39c2ca57f21abe4db8ca60ee49f&apos;        # 代理信息        header = {                &apos;cookie&apos;: &apos;t=da97f7b09403e3340cd6d50780a9385e; cna=PoshExqPgw0CAQG9KdLV29qM; hng=CN%7Czh-CN%7CCNY%7C156; thw=cn; enc=MuF%2FWOzFnau5EcbgcPck31M%2FMhER8txA4ZnjdZI2Dt8xzHdAr%2FN4f0OsOD%2FUcrNpOZWIfEG0GSbPQ8C4U%2BU70A%3D%3D; mt=ci%3D-1_1; cookie2=1f17bf1dfa8b6cf01c17d0fe7306c672; v=0; _tb_token_=eaefe3a15f0bf; JSESSIONID=0BC0D7637EFFD50CA56F8A8F4E451813; isg=BD09zFTCO5bo0p_z6P-VaFHGTJ_3cnEiA2cTwf-D2RRsNl5oySop_Xqg5Wpwlonk&apos;,                &apos;referer&apos;: &apos;https://s.taobao.com/search?q=macbookpro&amp;imgfile=&amp;js=1&amp;stats_click=search_radio_all%3A1&amp;initiative_id=staobaoz_20180408&amp;ie=utf8&amp;bcoffset=4&amp;p4ppushleft=1%2C48&amp;ntoffset=4&amp;s=0&apos;,                &apos;user-agent&apos;: &apos;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.181 Safari/537.36&apos;,                &apos;x-requested-with&apos;: &apos;XMLHttpRequest&apos;}        responed = requests.get(url=url, headers=header)        # 指定编码格式        responed.encoding = &apos;utf-8&apos;        re_text = responed.text        &apos;&apos;&apos;            进入数据清洗与筛选阶段            因为转化json格式始终失败...所以改用正则表达式来进行匹配        &apos;&apos;&apos;        print(&apos;获取源代码成功，以下为相关商品的信息：&apos;)        target = re.findall(r&apos;&quot;raw_title&quot;:&quot;(.*?)&quot;.*?&quot;pic_url&quot;:&quot;(.*?)&quot;.*?&quot;view_price&quot;:&quot;(.*?)&quot;.*?&quot;item_loc&quot;:&quot;(.*?)&quot;.*?&quot;view_sales&quot;:&quot;(.*?)&quot;.*?&quot;user_id&quot;:&quot;(.*?)&quot;.*?&quot;nick&quot;:&quot;(.*?)&quot;&apos;, re_text, re.S)  # @UndefinedVariable        for each in target:            product = {                &apos;shop_title&apos;:each[0],  # 店铺主题                &apos;pic_url&apos;:&apos;https:&apos; + each[1],  # 店铺图片地址                &apos;price&apos;:each[2],  # 价格                &apos;sales_people&apos;:each[4],  # 购买人数                &apos;shop_name&apos;:each[6],  # 店铺名称                &apos;loc&apos;:each[3],  # 店铺所在地                &apos;shop_url&apos;:&apos;https://store.taobao.com/shop/view_shop.htm?user_number_id=&apos; + each[5]  # 店铺URL地址                    }            print(product)</code></pre><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>第二种方法期间原本以为可以先转化为<em>json格式</em>来进行处理，没想到发生了<strong>json.decoder.JSONDecodeError:</strong>的错误，结果改用正则表达式进行文本的挖掘，效率也是无形中得到了提升…在此我推荐用正则表达式来处理<em>json格式</em>的文档，这样在绝大多数情况下可能会有更高的效率！</p><p>爬取到的数据可用来进行一些数据分析等等。有时想尝试用各种方法去爬取，但是因为学的东西真的多，所以就不一一尝试了，尽量使用简便的方法…不懂的朋友还需要多多学习，利用好搜索引擎！当然看书也是必须的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;爬取淘宝信息：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1，可用&lt;em&gt;selenium&lt;/em&gt;模块与&lt;em&gt;driver Chrome&lt;/em&gt;插件自动化模拟爬取。&lt;/p&gt;
&lt;p&gt;2， 进行抓包爬取。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;下面一一进
      
    
    </summary>
    
      <category term="python爬虫" scheme="https://liujunjie11.github.io/categories/python%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="python爬虫" scheme="https://liujunjie11.github.io/tags/python%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>关于记录Chromedriver的selenium.common.exceptions.WebDriverException: Message: &#39;chromedriver &#39; executable needs to be in PATH. Please see https://sites.google.com/a/chromium.org/chromedriver/home</title>
    <link href="https://liujunjie11.github.io/2018/04/05/%E5%85%B3%E4%BA%8E%E8%AE%B0%E5%BD%95Chromedriver%E7%9A%84selenium-common-exceptions-WebDriverException-Message-chromedriver-executable-needs-to-be-in-PATH-Please-see-https-sites-google-com-a-chromium-org-chromedriver-home/"/>
    <id>https://liujunjie11.github.io/2018/04/05/关于记录Chromedriver的selenium-common-exceptions-WebDriverException-Message-chromedriver-executable-needs-to-be-in-PATH-Please-see-https-sites-google-com-a-chromium-org-chromedriver-home/</id>
    <published>2018-04-05T11:46:15.000Z</published>
    <updated>2018-04-05T12:01:34.821Z</updated>
    
    <content type="html"><![CDATA[<p>最近学习一些<em>python</em>爬虫的框架，用<em>selenium</em>与<em>Chromedriver</em>插件结合<em>Chrome浏览器</em>来爬去网页源数据。</p><p>发现了如题的错误信息：</p><blockquote><p>selenium.common.exceptions.WebDriverException: Message:<br>  ‘chromedriver ‘ executable needs to be in PATH. Please see<br>  <a href="https://sites.google.com/a/chromium.org/chromedriver/home" target="_blank" rel="external">https://sites.google.com/a/chromium.org/chromedriver/home</a></p></blockquote><p>在已配置好系统环境的前提下，用如下代码指定位置，或者是将<em>Chromedriver</em>插件放在工程文件下，均得到了如上的错误信息。</p><pre><code>from selenium import webdriverbrowser = webdriver.Chrome(&apos;/Users/junjieliu/Downloads/小插件/chromedriver&apos;)</code></pre><hr><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>如下操作，先将插件打开（即表示打开运行了，<strong>在需要使用时应当一直开着</strong>），跳出来了其所在位置，将其位置复制再运行上面的代码，发现跳出来了一个<em>Chrome浏览器</em>的空白页面，这表示已经成功了！</p><p><img src="http://owudg3xs2.bkt.clouddn.com/4%E6%9C%88-05-2018%2019-56-36.gif" alt=""></p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-05%20%E4%B8%8B%E5%8D%888.00.03.png" alt=""></p><blockquote><p>成功的页面。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近学习一些&lt;em&gt;python&lt;/em&gt;爬虫的框架，用&lt;em&gt;selenium&lt;/em&gt;与&lt;em&gt;Chromedriver&lt;/em&gt;插件结合&lt;em&gt;Chrome浏览器&lt;/em&gt;来爬去网页源数据。&lt;/p&gt;
&lt;p&gt;发现了如题的错误信息：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p
      
    
    </summary>
    
      <category term="爬虫" scheme="https://liujunjie11.github.io/categories/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="爬虫" scheme="https://liujunjie11.github.io/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>python3爬取豆瓣Top250电影信息</title>
    <link href="https://liujunjie11.github.io/2018/04/03/python3%E7%88%AC%E5%8F%96%E8%B1%86%E7%93%A3Top250%E7%94%B5%E5%BD%B1%E4%BF%A1%E6%81%AF/"/>
    <id>https://liujunjie11.github.io/2018/04/03/python3爬取豆瓣Top250电影信息/</id>
    <published>2018-04-03T14:09:36.000Z</published>
    <updated>2018-04-04T02:29:05.477Z</updated>
    
    <content type="html"><![CDATA[<p>以下是通过正则表达式爬取的<em>猫眼电影</em>以及<em>豆瓣电影</em>的相关的电影信息的代码过程。</p><hr><h2 id="爬取猫眼电影"><a href="#爬取猫眼电影" class="headerlink" title="爬取猫眼电影"></a>爬取猫眼电影</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>打开<em>Chrome</em>的调试工具，可发现相关的信息都在，并且以翻页的形式来得到更多的电影信息。</p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-04%20%E4%B8%8A%E5%8D%8810.17.59.png" alt=""></p><blockquote><p>我们可通过其爬取需要的信息，利用正则表达式来进行文本的挖掘。</p></blockquote><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code>&apos;&apos;&apos;    函数目标：    爬取猫眼电影的top100信息    编写时间：    2018-03-28&apos;&apos;&apos;&apos;&apos;&apos;import requestsimport reimport jsonif __name__ == &apos;__main__&apos;:print(&apos;猫眼电影Top100信息如下：&apos;)#循环10次，得出页面上的Top100的电影信息for i in range(0, 10):    url = &quot;http://maoyan.com/board/4?&quot;    header = {            &apos;Host&apos;:&apos;maoyan.com&apos;,            &apos;Referer&apos;:&apos;http://maoyan.com/board/4?offset=20&apos;,            &apos;User-Agent&apos;:&apos;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.181 Safari/537.36&apos;}    paramters = {            &apos;offset&apos;: i * 10}    request_tasget = requests.get(url=url, headers=header, params=paramters)    request_tasget.encoding = &apos;utf-8&apos;    # 实际上应该考虑考虑网的问题...连不上就一般没有数据返回了，找一个字符作为接口之后利用万能表达式即可    infos_list = re.findall(    r&apos;&lt;dd&gt;.*?board-index.*?&gt;(.*?)&lt;/i&gt;.*?alt.*?src=&quot;(.*?)&quot;.*?&lt;a.*?&gt;(.*?)&lt;/a&gt;.*?&quot;star&quot;&gt;(.*?)&lt;/p&gt;.*?&quot;releasetime&quot;&gt;(.*?)&lt;/p&gt;.*?&quot;integer&quot;&gt;(.*?)&lt;/i&gt;.*?&quot;fraction&quot;&gt;(.*?)&lt;/i&gt;&apos;,    request_tasget.text, re.S)  # @UndefinedVariable    #建立存储信息的字典    for each in infos_list:        yields = {                &apos;index&apos;:each[0],                &apos;image_info&apos;:each[1],                &apos;name&apos;:each[2],                &apos;actor&apos;:each[3].strip(),                &apos;time&apos;:each[4],                &apos;score&apos;:each[5] + each[6]                }        print(yields)</code></pre><h2 id="爬取豆瓣电影"><a href="#爬取豆瓣电影" class="headerlink" title="爬取豆瓣电影"></a>爬取豆瓣电影</h2><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>与爬取猫眼电影信息一样，都是一样的，具体的差距还是在豆瓣上爬取信息需要<em>cookie</em>，具体可参考下面的代码。</p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-04%20%E4%B8%8A%E5%8D%8810.18.27.png" alt=""></p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><pre><code>&apos;&apos;&apos;    函数目标：    爬取豆瓣Top250的电影信息    编写时间：    2018-04-01&apos;&apos;&apos;import requestsimport re if __name__ == &apos;__main__&apos;:print(&apos;以下为豆瓣Top250的电影信息：&apos;)# 从页面可看到一共有十页，每页上有25个电影的信息for i in range(0, 10):    url = &quot;https://movie.douban.com/top250?&quot;    header = {            &apos;Connection&apos;: &apos;keep-alive&apos;,            &apos;Cookie&apos;: &apos;bid=x9ipkoKiQgw; _pk_ses.100001.4cf6=*; __utma=30149280.2001666009.1522587991.1522587991.1522587991.1; __utmb=30149280.0.10.1522587991; __utmc=30149280; __utmz=30149280.1522587991.1.1.utmcsr=(direct)|utmccn=(direct)|utmcmd=(none); __utma=223695111.1530785565.1522587991.1522587991.1522587991.1; __utmb=223695111.0.10.1522587991; __utmc=223695111; __utmz=223695111.1522587991.1.1.utmcsr=(direct)|utmccn=(direct)|utmcmd=(none); ll=&quot;118146&quot;; _vwo_uuid_v2=D575771A914BC38B3B7D081C0A0296FDC|939d8f7fdff1f383a97d572dab39fa1a; _pk_id.100001.4cf6=1de732c7ac4dc22b.1522587990.1.1522588516.1522587990.; ct=y&apos;,            &apos;Host&apos;: &apos;movie.douban.com&apos;,            &apos;Referer&apos;: &apos;https://movie.douban.com/top250?start=25&amp;filter=&apos;,            &apos;Upgrade-Insecure-Requests&apos;: &apos;1&apos;,            &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/65.0.3325.181 Safari/537.36}&apos;             }    paramters = {             &apos;start&apos;: i * 25,             &apos;filter&apos;:&apos;&apos;              }    tasget = requests.get(url=url, headers=header, params=paramters)    tasget.encoding = &apos;utf-8&apos;    # 匹配正则表达式    infos = re.findall(r&apos;&lt;li&gt;.*?&lt;em class=&quot;&quot;&gt;(.*?)&lt;/em&gt;.*?alt=.*?src=&quot;(.*?)&quot;.*?&quot;title&quot;&gt;(.*?)&lt;/span&gt;.*?class=&quot;title&quot;&gt;&amp;nbsp;/&amp;nbsp;(.*?)&lt;/span&gt;.*?&quot;other&quot;&gt;&amp;nbsp;/&amp;nbsp;(.*?)&lt;/span&gt;.*?&lt;p class=&quot;&quot;&gt;(.*?)&amp;nbsp;&amp;nbsp;&amp;nbsp;(.*?)&lt;br&gt;(.*?)&amp;nbsp;/&amp;nbsp(.*?)&amp;nbsp;/&amp;nbsp(.*?)&lt;/p&gt;.*?average&quot;&gt;(.*?)&lt;/span&gt;&apos;, tasget.text, re.S)  # @UndefinedVariable    # 建立一个空字典用于存储相关的信息    for each in infos:        yields = {            &apos;index&apos;:each[0],  # 排名            &apos;img_info&apos;:each[1],  # 照片地址            &apos;name&apos;:each[2].strip() + &quot;/&quot; + each[3].strip() + &quot;/&quot; + each[4].strip(),  # 影片名称            &apos;director&apos;:each[5].strip(),  # 导演            &apos;actor&apos;:each[6],  # 演员            &apos;time_cy&apos;:each[7].strip() + each[8],  # 上演时间及地区            &apos;type&apos;:each[9].strip(),  # 影片类型            &apos;score&apos;:each[10]  # 评分            }        print(yields)</code></pre><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>简单说说其中的含义，表达式<code>.*?</code>是一个万能的匹配式，<code>(.*?)</code>是匹配想要爬取的内容，并且每一次伴随着一个索引号，每一个索引号对应着的信息不同。利用正则表达式可方便的进行文本与代码的分开挖掘，一般在写正则表达式时用<em>html</em>代码中的一些词来进行过渡就可以方便的写出来了。</p><blockquote><p>多说无益，还是需要自己来进行代码的测试了解的。</p></blockquote><ul><li>参考的博客：<a href="https://cuiqingcai.com" target="_blank" rel="external">https://cuiqingcai.com</a></li></ul><blockquote><p>可根据此博客来学习更多的爬虫知识。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;以下是通过正则表达式爬取的&lt;em&gt;猫眼电影&lt;/em&gt;以及&lt;em&gt;豆瓣电影&lt;/em&gt;的相关的电影信息的代码过程。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;爬取猫眼电影&quot;&gt;&lt;a href=&quot;#爬取猫眼电影&quot; class=&quot;headerlink&quot; title=&quot;爬取猫眼电影&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
      <category term="python爬虫" scheme="https://liujunjie11.github.io/categories/python%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="python3爬虫" scheme="https://liujunjie11.github.io/tags/python3%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>Mac下的mysql安装以及相关的问题解决</title>
    <link href="https://liujunjie11.github.io/2018/04/03/Mac%E4%B8%8B%E7%9A%84mysql%E5%AE%89%E8%A3%85%E4%BB%A5%E5%8F%8A%E7%9B%B8%E5%85%B3%E7%9A%84%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
    <id>https://liujunjie11.github.io/2018/04/03/Mac下的mysql安装以及相关的问题解决/</id>
    <published>2018-04-03T11:48:48.000Z</published>
    <updated>2018-04-03T12:58:55.064Z</updated>
    
    <content type="html"><![CDATA[<p>最近因为学习到了爬虫的原因，存储数据需要<em>mysql</em>了，因为以前学习过其命令行，所以在之前安装过了，太久没用了，怎么开都不懂了，搞了几十分钟不想搞了，重新安装。下面记录下遇到的一些问题。</p><hr><h2 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h2><h3 id="第一种方法"><a href="#第一种方法" class="headerlink" title="第一种方法"></a>第一种方法</h3><p>进入官网下载对应<em>Mac</em>的<em>mysql</em>。</p><blockquote><p><a href="https://dev.mysql.com/downloads/mysql/" target="_blank" rel="external">官网地址</a></p></blockquote><h3 id="第二种方法"><a href="#第二种方法" class="headerlink" title="第二种方法"></a>第二种方法</h3><p>直接用命令行<code>brew Install mysql</code>。</p><blockquote><p>前提是必须安装了<em>homebrew</em>。</p></blockquote><h2 id="配置以及开启过程"><a href="#配置以及开启过程" class="headerlink" title="配置以及开启过程"></a>配置以及开启过程</h2><h3 id="配置过程"><a href="#配置过程" class="headerlink" title="配置过程"></a>配置过程</h3><p>在手动安装正后一步记下默认的密码（如下图）。</p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-03%20%E4%B8%8B%E5%8D%888.34.15.png" alt=""></p><blockquote><p>即<strong>QeV.a&gt;zGa1m3</strong>为默认密码。</p></blockquote><p>在<em>偏好系统</em>中手动打开<em>mysql</em>应用。</p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-03%20%E4%B8%8B%E5%8D%888.34.36.png" alt=""></p><p>之后打开终端，为其配置。（命令行如下依次）</p><p><code>vi ~/bash_profile</code></p><p>进入按字母<em>i</em>进入编辑模式，输入：</p><p><code>export PATH=&quot;$PATH:/usr/local/mysql/bin&quot;</code></p><blockquote><p>在此可能有疑惑，为什么可以直接<code>mysql/bin</code>？因为在我们手动下载<br><em>mysql</em>之后系统已经自动的复制了一遍，并且将其名为<em>mysql</em>，如图在<em>/usr/local/</em>可找到。</p></blockquote><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-03%20%E4%B8%8B%E5%8D%888.18.02.png" alt=""></p><hr><p>接着输入相关的命令…这时已经配置好了，按下<em>esc</em>健进入命令行模式，输入<code>：wq</code>,推出。之后为了快速见效输入<code>source ~/bash_profile</code></p><h3 id="启动过程"><a href="#启动过程" class="headerlink" title="启动过程"></a>启动过程</h3><p>输入命令行<code>mysql -uroot -p</code>,提示输入刚刚的默认密码，进入到了<em>mysql</em>的编译界面之后，我们修改默认密码，输入代码<code>set PASSWORD =PASSWORD(&#39;123456&#39;);</code></p><blockquote><p><strong>其中的<em>123456</em>为新的密码。</strong></p></blockquote><p>之后为测试是否已经修改成功，输入<code>exit();</code>推出界面，输入命令行<code>mysql -uroot -p</code>,提示输入刚刚的新密码，成功进入编译界面。</p><p><img src="http://owudg3xs2.bkt.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-04-03%20%E4%B8%8B%E5%8D%888.32.00.png" alt=""></p><h2 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h2><p>可参考：<a href="https://www.jianshu.com/p/b02be6026a2a" target="_blank" rel="external">https://www.jianshu.com/p/b02be6026a2a</a></p><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p><strong>解决问题：ERROR 1045 (28000): Access denied for user ‘root’@’localhost’ (using password: YES)</strong></p><p>可参考：<a href="https://www.digitalocean.com/community/questions/setup-mysql-on-ubuntu-droplet-getting-error-error-1045-28000-access-denied-for-user-root-localhost-using-password-yes" target="_blank" rel="external">https://www.digitalocean.com/community/questions/setup-mysql-on-ubuntu-droplet-getting-error-error-1045-28000-access-denied-for-user-root-localhost-using-password-yes</a></p><p><strong>解决进程问题</strong></p><p>可参考：<a href="https://blog.csdn.net/liumaolincycle/article/details/51896592" target="_blank" rel="external">https://blog.csdn.net/liumaolincycle/article/details/51896592</a></p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>有时下载完之后也会出现上面的那个问题，我是通过重新启动电脑之后获得了解决。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近因为学习到了爬虫的原因，存储数据需要&lt;em&gt;mysql&lt;/em&gt;了，因为以前学习过其命令行，所以在之前安装过了，太久没用了，怎么开都不懂了，搞了几十分钟不想搞了，重新安装。下面记录下遇到的一些问题。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;安装过程&quot;&gt;&lt;a href=&quot;#安装
      
    
    </summary>
    
      <category term="mysql" scheme="https://liujunjie11.github.io/categories/mysql/"/>
    
    
      <category term="mysql" scheme="https://liujunjie11.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>关于解决python中UnicodeDecodeError: &#39;ascii&#39; codec can&#39;t decode byte 0xe8 in position 67986: ordinal not in range(128)的问题</title>
    <link href="https://liujunjie11.github.io/2018/03/28/%E5%85%B3%E4%BA%8E%E8%A7%A3%E5%86%B3python%E4%B8%ADUnicodeDecodeError-ascii-codec-can-t-decode-byte-0xe8-in-position-67986-ordinal-not-in-range-128-%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://liujunjie11.github.io/2018/03/28/关于解决python中UnicodeDecodeError-ascii-codec-can-t-decode-byte-0xe8-in-position-67986-ordinal-not-in-range-128-的问题/</id>
    <published>2018-03-28T10:18:54.000Z</published>
    <updated>2018-03-28T10:26:59.245Z</updated>
    
    <content type="html"><![CDATA[<p>在学习爬虫的过程中，在运行编者的代码时出现了<em>UnicodeDecodeError: ‘ascii’ codec can’t decode byte 0xe8 in position 67986: ordinal not in range(128)</em>的编码问题。</p><p>具体原因是因为程序默认的解析编码格式发生了冲突造成的，简单来说就是需要解析的内容与<em>API</em>程序默认的解析编码格式不同，所以才会出现如上的错误。</p><p>因为是打算用<em>python</em>解析<em>JS</em>文件，所以我就贴上我的解决方案了：</p><pre><code>ctx = node.compile(open(file, encoding=&apos;utf-8&apos;).read())</code></pre><blockquote><p>加上自行规定的解码格式即可。</p></blockquote><p><strong>解决来源于GitHub论坛…</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在学习爬虫的过程中，在运行编者的代码时出现了&lt;em&gt;UnicodeDecodeError: ‘ascii’ codec can’t decode byte 0xe8 in position 67986: ordinal not in range(128)&lt;/em&gt;的编码问题
      
    
    </summary>
    
      <category term="学习笔记" scheme="https://liujunjie11.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="学习笔记" scheme="https://liujunjie11.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>关于homebrew下载出现&quot;Error/go/version missing for  gotools resource!&quot;错误的解决方案</title>
    <link href="https://liujunjie11.github.io/2018/03/28/%E5%85%B3%E4%BA%8Ehomebrew%E4%B8%8B%E8%BD%BD%E5%87%BA%E7%8E%B0Error:go:version%20missing%20for%20%20gotools%20resource!%E9%94%99%E8%AF%AF%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>https://liujunjie11.github.io/2018/03/28/关于homebrew下载出现Error:go:version missing for  gotools resource!错误的解决方案/</id>
    <published>2018-03-28T02:47:34.000Z</published>
    <updated>2018-03-28T02:48:35.030Z</updated>
    
    <content type="html"><![CDATA[<p>最近用<em>homebrew</em>下载<em>mongodb</em>，发现出现了<em>Error: go: version missing for “gotools” resource!</em>的错误，试了几次都不行，最后在谷歌用英文搜索关键词在<em>GitHub</em>的一个论坛用相关的解决方案。</p><p><strong>使用命令行</strong></p><blockquote><p><strong>git -C “$(brew –repo)” fetch –tags</strong></p></blockquote><p>之后再次输入：</p><blockquote><p><strong>brew update –force</strong></p></blockquote><p>最后再次用命令行<em>brew install mongodb</em>，发现已经能够正确成功下载了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近用&lt;em&gt;homebrew&lt;/em&gt;下载&lt;em&gt;mongodb&lt;/em&gt;，发现出现了&lt;em&gt;Error: go: version missing for “gotools” resource!&lt;/em&gt;的错误，试了几次都不行，最后在谷歌用英文搜索关键词在&lt;em&gt;GitH
      
    
    </summary>
    
      <category term="学习笔记" scheme="https://liujunjie11.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="学习笔记" scheme="https://liujunjie11.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法：线性表</title>
    <link href="https://liujunjie11.github.io/2018/03/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%9A%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    <id>https://liujunjie11.github.io/2018/03/26/数据结构与算法：线性表/</id>
    <published>2018-03-26T10:56:19.000Z</published>
    <updated>2018-04-03T12:29:47.274Z</updated>
    
    <content type="html"><![CDATA[<p>打算重新好好系统的学习数据结构了。这是开始。</p><p>因为概念已经是烂大街了，在此只记录下我用<em>java</em>或者是<em>python</em>实现相关功能的代码。</p><hr><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><h3 id="java实现"><a href="#java实现" class="headerlink" title="java实现"></a>java实现</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;打算重新好好系统的学习数据结构了。这是开始。&lt;/p&gt;
&lt;p&gt;因为概念已经是烂大街了，在此只记录下我用&lt;em&gt;java&lt;/em&gt;或者是&lt;em&gt;python&lt;/em&gt;实现相关功能的代码。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;查找&quot;&gt;&lt;a href=&quot;#查找&quot; class=&quot;hea
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://liujunjie11.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="https://liujunjie11.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>计算机基础知识：认识计算机</title>
    <link href="https://liujunjie11.github.io/2018/03/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%9A%E8%AE%A4%E8%AF%86%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    <id>https://liujunjie11.github.io/2018/03/26/计算机基础知识：认识计算机/</id>
    <published>2018-03-26T03:44:12.000Z</published>
    <updated>2018-03-26T05:12:33.821Z</updated>
    
    <content type="html"><![CDATA[<p>计算机发展到了如今这样的一个地步实在让人感兴趣…</p><p>于是看了一些书和文章，想了解了解一个计算机是如何跑起来的。</p><hr><h2 id="机器本质"><a href="#机器本质" class="headerlink" title="机器本质"></a>机器本质</h2><blockquote><p><strong>计算机的本质</strong></p></blockquote><ul><li>计算机的本质<strong>：（电脑）计算机 = 计算机器</strong></li></ul><p>没错，如今<strong>我们使用的计算机就是和我们小学时按的那个只会加减乘除计算器的本质毫无区别</strong>。使用计算机时，我们会先通过键盘或者是语音输入想要了解的信息，之后计算机会通过内部一系列的运算之后，输出相关的界面信息到我们的屏幕上。那我们可理解计算机就是一通过我们输入，然后自己默默运算完输出结果的机器。电脑电脑，正所谓脑子就是人类的<strong>计算机器</strong>，电脑不过是插上电源才能运行的计算机器。</p><p><img src="" alt=""></p><p>什么图画啊，文档内容等等均是先转化为相关的数字信息（如我们学过的二进制，十六进制等）后才在显示器上呈现出来的，所以在此可理解为什么还会有那么多各式各样的字符编码了吧。如中文编码常见的<em>GB2312</em>等。</p><blockquote><p><strong>计算机上的1与0</strong></p></blockquote><ul><li><strong>计算机是电子产品，其构造是由一些硬件组成。</strong></li></ul><p>再继续说说烂大街的绝大部分地球人都知道的事实：<strong>计算机只认识1和0</strong>。因为计算机是集成电路（IC）组成,运行起来接上电源之后需要传输数据了（即属于电子数字电路），而在数字电路中，二进制（binary）数是指用二进制记数系统，即以2为基数的记数系统表示的数字。这一系统中，通常用两个不同的符号0（代表零）和1（代表一）来表示。以2为基数代表系统是二进位制的。数字电子电路中，逻辑门的实现直接应用了二进制，因此现代的计算机和依赖计算机的设备里都用到二进制。每个数字称为一个位元（二进制位）或比特（Bit，Binary digit的缩写）。补充：<strong>比特是信息的最小单位， 字节是信息的基本单位。</strong></p><p>结合上面的说明，可知道数据都是在计算机中以1和0组成的，一是因为计算机本身的结构所致，二是因为这样可方便的转化为其他的数字类型（包括十进制之类的）。<strong>对于计算机来说，什么都是数字。只是数字的组成不同而已。</strong></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p>维基百科：<a href="https://zh.wikipedia.org/wiki/二进制" target="_blank" rel="external">https://zh.wikipedia.org/wiki/二进制</a></p></li><li><p>书籍：《计算机是怎么跑起来的》 矢泽久雄 著</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;计算机发展到了如今这样的一个地步实在让人感兴趣…&lt;/p&gt;
&lt;p&gt;于是看了一些书和文章，想了解了解一个计算机是如何跑起来的。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;机器本质&quot;&gt;&lt;a href=&quot;#机器本质&quot; class=&quot;headerlink&quot; title=&quot;机器本质&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
      <category term="计算机基础知识" scheme="https://liujunjie11.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="计算机基础知识" scheme="https://liujunjie11.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
</feed>
